(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)



Record Unary_Unary_record : Type :=
  {
    Unary_Unary_0 : Core_Base_Spec_Haxint.t_HaxInt;
  }.


#[export] Instance settable_Unary_Unary_record : Settable _ :=
  settable! (Build_Unary_Unary_record) <Unary_Unary_0>.
Notation "'Unary_Unary_record'" := Build_Unary_Unary_record.

Inductive t_UNARY : Type :=
| UNARY_ZERO
| UNARY_SUCC : t_Unary -> _.



Instance t_Clone_648246659 : Core_Clone.t_Clone ((t_Unary)) :=
  {
    Core_Clone.Clone_f_clone := fun  (self : t_Unary)=>
      Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([])));
  }.

Definition unary_to_int (s : t_Unary) : Core_Base_Spec_Haxint.t_HaxInt :=
  0 s.

Definition unary_from_int (x : Core_Base_Spec_Haxint.t_HaxInt) : t_Unary :=
  Unary_Unary (x).

Definition succ (x : t_Unary) : t_Unary :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition pred (x : t_Unary) : t_Unary :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition match_unary (s : t_Unary) : t_UNARY :=
  if
    Core_Base_Spec_Haxint.is_zero (unary_to_int (Core_Clone.Clone__f_clone (s)))
  then
    UNARY_ZERO
  else
    UNARY_SUCC (pred (s)).
