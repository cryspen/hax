(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)



Record Positive_Positive_record : Type :=
  {
    Positive_Positive_0 : Core_Base_Spec_Haxint.t_HaxInt;
  }.


#[export] Instance settable_Positive_Positive_record : Settable _ :=
  settable! (Build_Positive_Positive_record) <Positive_Positive_0>.
Notation "'Positive_Positive_record'" := Build_Positive_Positive_record.



Inductive t_POSITIVE : Type :=
| POSITIVE_XH
| POSITIVE_XO : t_Positive -> _
| POSITIVE_XI : t_Positive -> _.




Instance Core_Clone.t_Clone_585471303 : Core_Clone.t_Clone ((t_Positive)) :=
  {
    implaabbcc_t_Clone_impl__f_clone := fun  (self : t_Positive)=>
      Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([])));
  }.

Definition positive_to_int (s : t_Positive) : Core_Base_Spec_Haxint.t_HaxInt :=
  0 s.

Definition positive_from_int (x : Core_Base_Spec_Haxint.t_HaxInt) : t_Positive :=
  Positive_Positive (x).

Definition xH : t_Positive :=
  Positive_Positive (Core_Base_Spec_Haxint.v_HaxInt_ONE).

Definition xO (s : t_Positive) : t_Positive :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition xI (s : t_Positive) : t_Positive :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition match_positive__is_xH (s : t_Positive) : bool :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition match_positive__is_xO (s : t_Positive) : bool :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition match_positive (s : t_Positive) : t_POSITIVE :=
  if
    match_positive__is_xH (Core_Clone.Clone__f_clone (s))
  then
    POSITIVE_XH
  else
    if
      match_positive__is_xO (Core_Clone.Clone__f_clone (s))
    then
      POSITIVE_XO (positive_from_int (Core_Base_Spec_Haxint.div2 (positive_to_int (s))))
    else
      POSITIVE_XI (positive_from_int (Core_Base_Spec_Haxint.div2 (positive_to_int (s)))).

Definition match_positive__is_xI (s : t_Positive) : bool :=
  Rust_primitives_Hax.never_to_any (Core_Panicking.panic_fmt (Core_Fmt_Rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).
