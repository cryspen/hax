(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)



Record Unary_Unary_record : Type :=
  {
    Unary_Unary_0 : hax_core.base.spec.haxint.t_HaxInt;
  }.


#[export] Instance settable_Unary_Unary_record : Settable _ :=
  settable! (Build_Unary_Unary_record) <Unary_Unary_0>.
Notation "'Unary_Unary_record'" := Build_Unary_Unary_record.

Inductive t_UNARY : Type :=
| UNARY_ZERO
| UNARY_SUCC : t_Unary -> _.



Instance core.clone.t_Clone_754850048 : core.clone.t_Clone ((t_Unary)) :=
  {
    implaabbcc_t_Clone_impl__f_clone := fun  (self : t_Unary)=>
      rust_primitives.hax.never_to_any (core.panicking.panic_fmt (core.fmt.rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([])));
  }.

Definition unary_to_int (s : t_Unary) : hax_core.base.spec.haxint.t_HaxInt :=
  0 s.

Definition unary_from_int (x : hax_core.base.spec.haxint.t_HaxInt) : t_Unary :=
  Unary_Unary (x).

Definition succ (x : t_Unary) : t_Unary :=
  rust_primitives.hax.never_to_any (core.panicking.panic_fmt (core.fmt.rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition pred (x : t_Unary) : t_Unary :=
  rust_primitives.hax.never_to_any (core.panicking.panic_fmt (core.fmt.rt.impl_1__new_v1 ([("not yet implemented: specification needed"%string : string)]) ([]))).

Definition match_unary (s : t_Unary) : t_UNARY :=
  if
    hax_core.base.spec.haxint.is_zero (unary_to_int (core.clone.Clone__f_clone (s)))
  then
    UNARY_ZERO
  else
    UNARY_SUCC (pred (s)).
