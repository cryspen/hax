(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)







Inductive t_Option (v_T : Type) `{core.marker.t_Sized (v_T)} : Type :=
| Option_None
| Option_Some : v_T -> _.
Arguments Option_None {_} {_}.
Arguments Option_Some {_} {_}.

Definition impl_1__is_some `{v_T : Type} `{core.marker.t_Sized (v_T)} (self : t_Option ((v_T))) : bool :=
  match self with
  | Option_Some (_) =>
    (true : bool)
  | _ =>
    (false : bool)
  end.

Definition impl_1__map `{v_T : Type} `{v_U : Type} `{v_F : Type} `{core.marker.t_Sized (v_T)} `{core.marker.t_Sized (v_U)} `{core.marker.t_Sized (v_F)} `{core.ops.function.t_FnOnce (v_F) ((v_T))} `{_.(core.ops.function.FnOnce__f_Output) = v_U} (self : t_Option ((v_T))) (f : v_F) : t_Option ((v_U)) :=
  match self with
  | Option_Some (x) =>
    Option_Some (core.ops.function.FnOnce__f_call_once (f) ((x)))
  | Option_None =>
    Option_None
  end.

Definition unwrap_failed '(_ : unit) : rust_primitives.hax.t_Never :=
  core.panicking.panic (("called `Option::unwrap()` on a `None` value"%string : string)).

Definition impl_1__unwrap `{v_T : Type} `{core.marker.t_Sized (v_T)} (self : t_Option ((v_T))) `{impl_1__is_some (self_) = true} : v_T :=
  match self with
  | Option_Some (val) =>
    val
  | Option_None =>
    rust_primitives.hax.never_to_any (unwrap_failed (tt))
  end.

Definition expect_failed (msg : string) : rust_primitives.hax.t_Never :=
  core.panicking.panic_display (msg).

Definition impl_1__expect `{v_T : Type} `{core.marker.t_Sized (v_T)} (self : t_Option ((v_T))) (msg : string) : v_T :=
  match self with
  | Option_Some (val) =>
    val
  | Option_None =>
    rust_primitives.hax.never_to_any (expect_failed (msg))
  end.

Instance core.clone.t_Clone_796540786 `{v_T : Type} `{core.marker.t_Sized (v_T)} `{core.clone.t_Clone (v_T)} : core.clone.t_Clone ((t_Option ((v_T)))) :=
  {
    implaabbcc_t_Clone_impl__f_clone := fun  (self : t_Option ((v_T)))=>
      match self with
      | Option_Some (x) =>
        Option_Some (core.clone.Clone__f_clone (x))
      | Option_None =>
        Option_None
      end;
  }.
