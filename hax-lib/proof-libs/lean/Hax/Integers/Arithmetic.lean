import Hax.Result
import Hax.Integers.Basic
open Error

/-

# Arithmetic operations

The Rust arithmetic operations have their own notations, using a `?`. They
return a `Result`, that is `.fail` when arithmetic overflows occur.

-/
section Arithmetic

/-- The notation typeclass for homogeneous addition that returns a Result.  This
enables the notation `a +? b : α` where `a : α`, `b : α`. For now, there is no
heterogeneous version -/
class HaxAdd α where
  /-- `a +? b` computes the panicking sum of `a` and `b`.  The meaning of this
  notation is type-dependent. -/
  add : α → α → Result α

/-- The notation typeclass for homogeneous substraction that returns a Result.
This enables the notation `a -? b : α` where `a : α`, `b : α`. For now, there is
no heterogeneous version -/
class HaxSub α where
  /-- `a -? b` computes the panicking substraction of `a` and `b`.
  The meaning of this notation is type-dependent. -/
  sub : α → α → Result α

/-- The notation typeclass for homogeneous multiplication that returns a Result.
This enables the notation `a *? b : Result α` where `a b : α`. For now, there is
no heterogeneous version -/
class HaxMul α where
  /-- `a -? b` computes the panicking multiplication of `a` and `b`.  The
  meaning of this notation is type-dependent. -/
  mul : α → α → Result α

/-- The notation typeclass for homogeneous division that returns a Result.  This
enables the notation `a /? b : Result α` where `a b : α`. For now, there is no
heterogeneous version -/
class HaxDiv α where
  /-- `a -? b` computes the panicking multiplication of `a` and `b`.  The
  meaning of this notation is type-dependent. -/
  div : α → α → Result α

/-- The typeclass behind the notation `a >>>? b : Result α` where `a b : α`. -/
class HaxShiftRight α where
  /-- `a >>>? b` computes the panicking right-shift of `a` by `b`.  The meaning
  of this notation is type-dependent. It panics if `b` exceeds the size of `a`.
  -/
  shiftRight : α → α → Result α

/-- The notation typeclass for remainder.  This enables the notation `a %? b :
Result α` where `a b : α`.  -/
class HaxRem α where
  /-- `a %? b` computes the panicking remainder upon dividing `a` by `b`.  The
  meaning of this notation is type-dependent. It panics if b is zero -/
  rem : α → α → Result α

@[inherit_doc] infixl:65 " +? "   => HaxAdd.add
@[inherit_doc] infixl:65 " -? "   => HaxSub.sub
@[inherit_doc] infixl:70 " *? "   => HaxMul.mul
@[inherit_doc] infixl:75 " >>>? " => HaxShiftRight.shiftRight
@[inherit_doc] infixl:70 " %? "   => HaxRem.rem
@[inherit_doc] infixl:70 " /? "   => HaxDiv.div
infixl:58 " ^^^? " => fun a b => pure (HXor.hXor a b)

/- Until notations are not introduced by the Lean backend, explicit hax-names
  are also provided -/
@[simp, spec]
def hax_machine_int_add {α} [HaxAdd α] (x y: α) : Result α := x +? y
@[simp, spec]
def hax_machine_int_sub {α} [HaxSub α] (x y: α) : Result α := x -? y
@[simp, spec]
def hax_machine_int_mul {α} [HaxMul α] (x y: α) : Result α := x *? y
@[simp, spec]
def hax_machine_int_div {α} [HaxDiv α] (x y: α) : Result α := x /? y
@[simp, spec]
def hax_machine_int_rem {α} [HaxRem α] (x y: α) : Result α := x %? y
@[simp, spec]
def hax_machine_int_shr {α} [HaxShiftRight α] (a b: α) : Result α := a >>>? b
@[simp, spec]
def hax_machine_int_bitxor {α} [HXor α α α] (a b: α) : Result α := a ^^^? b
@[simp, spec]
def ops_arith_Neg_neg {α} [Neg α] (x:α) : Result α := pure (-x)

@[simp, spec]
def hax_machine_int_eq {α} (x y: α) [BEq α] : Result Bool := pure (x == y)
@[simp, spec]
def hax_machine_int_ne {α} (x y: α) [BEq α] : Result Bool := pure (x != y)
@[simp, spec]
def hax_machine_int_lt {α} (x y: α) [(LT α)] [Decidable (x < y)] : Result Bool :=
  pure (x < y)
@[simp, spec]
def hax_machine_int_le {α} (x y: α) [(LE α)] [Decidable (x ≤ y)] : Result Bool :=
  pure (x ≤ y)
@[simp, spec]
def hax_machine_int_gt {α} (x y: α) [(LT α)] [Decidable (x > y)] : Result Bool :=
  pure (x > y)
@[simp, spec]
def hax_machine_int_ge {α} (x y: α) [(LE α)] [Decidable (x ≥ y)] : Result Bool :=
  pure (x ≥ y)

/-

# Wrapping operations

Rust also has total arithmetic operations, renamed by hax (with disambiguator)
for each implementation of typeclasses

-/

@[simp, spec]
def num__8_impl_wrapping_add (x y: u32) : Result u32 := pure (x + y)

@[simp, spec]
def num__8_impl_rotate_left (x: u32) (n: Nat) : Result u32 :=
  pure (UInt32.ofBitVec (BitVec.rotateLeft x.toBitVec n))


/-- Hax-generated bounded integers -/
abbrev hax__autogenerated_refinement__BoundedUsize_BoundedUsize
  (lo: USize) (hi: USize) := USize
--  {u : usize // lo ≤ u ∧ u ≤ hi}
-- Todo : make it into a proper subtype


def num__8_impl_from_le_bytes (x: Vector u8 4) : u32 :=
  x[0].toUInt32
  + (x[1].toUInt32 <<< 8)
  + (x[2].toUInt32 <<< 16)
  + (x[3].toUInt32 <<< 24)

def num__8_impl_to_le_bytes (x:u32) : Result (Vector u8 4) :=
  #v[
    (x % 256).toUInt8,
    (x >>> 8 % 256).toUInt8,
    (x >>> 16 % 256).toUInt8,
    (x >>> 24 % 256).toUInt8,
  ]


end Arithmetic
