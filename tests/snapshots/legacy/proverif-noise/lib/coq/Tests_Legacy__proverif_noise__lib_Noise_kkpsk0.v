(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)







Record HandshakeStateI0_record : Type :=
  {
    HandshakeStateI0_f_st : t_SymmetricState;
    HandshakeStateI0_f_psk : t_Vec ((t_u8)) ((t_Global));
    HandshakeStateI0_f_s : t_KeyPair;
    HandshakeStateI0_f_e : t_KeyPair;
    HandshakeStateI0_f_rs : t_Vec ((t_u8)) ((t_Global));
  }.






#[export] Instance settable_HandshakeStateI0_record : Settable _ :=
  settable! (Build_HandshakeStateI0_record) <HandshakeStateI0_f_st; HandshakeStateI0_f_psk; HandshakeStateI0_f_s; HandshakeStateI0_f_e; HandshakeStateI0_f_rs>.

Record HandshakeStateI1_record : Type :=
  {
    HandshakeStateI1_f_st : t_SymmetricState;
    HandshakeStateI1_f_s : t_KeyPair;
    HandshakeStateI1_f_e : t_KeyPair;
  }.




#[export] Instance settable_HandshakeStateI1_record : Settable _ :=
  settable! (Build_HandshakeStateI1_record) <HandshakeStateI1_f_st; HandshakeStateI1_f_s; HandshakeStateI1_f_e>.

Record HandshakeStateR0_record : Type :=
  {
    HandshakeStateR0_f_st : t_SymmetricState;
    HandshakeStateR0_f_psk : t_Vec ((t_u8)) ((t_Global));
    HandshakeStateR0_f_s : t_KeyPair;
    HandshakeStateR0_f_e : t_KeyPair;
    HandshakeStateR0_f_rs : t_Vec ((t_u8)) ((t_Global));
  }.






#[export] Instance settable_HandshakeStateR0_record : Settable _ :=
  settable! (Build_HandshakeStateR0_record) <HandshakeStateR0_f_st; HandshakeStateR0_f_psk; HandshakeStateR0_f_s; HandshakeStateR0_f_e; HandshakeStateR0_f_rs>.

Record HandshakeStateR1_record : Type :=
  {
    HandshakeStateR1_f_st : t_SymmetricState;
    HandshakeStateR1_f_e : t_KeyPair;
    HandshakeStateR1_f_rs : t_Vec ((t_u8)) ((t_Global));
    HandshakeStateR1_f_re : t_Vec ((t_u8)) ((t_Global));
  }.





#[export] Instance settable_HandshakeStateR1_record : Settable _ :=
  settable! (Build_HandshakeStateR1_record) <HandshakeStateR1_f_st; HandshakeStateR1_f_e; HandshakeStateR1_f_rs; HandshakeStateR1_f_re>.

Record Transport_record : Type :=
  {
    Transport_f_send : t_CipherState;
    Transport_f_recv : t_CipherState;
    Transport_f_handshake_hash : t_Vec ((t_u8)) ((t_Global));
  }.




#[export] Instance settable_Transport_record : Settable _ :=
  settable! (Build_Transport_record) <Transport_f_send; Transport_f_recv; Transport_f_handshake_hash>.

Record ProtocolName_record : Type :=
  {
    ProtocolName_0 : t_Array (t_u8) ((36 : t_usize));
  }.


#[export] Instance settable_ProtocolName_record : Settable _ :=
  settable! (Build_ProtocolName_record) <ProtocolName_0>.
Notation "'ProtocolName_ProtocolName_record'" := Build_ProtocolName_record.

Definition v_Noise_KKpsk0_25519_ChaChaPoly_SHA256 : t_ProtocolName :=
  ProtocolName ([(78 : t_u8); (111 : t_u8); (105 : t_u8); (115 : t_u8); (101 : t_u8); (95 : t_u8); (75 : t_u8); (75 : t_u8); (112 : t_u8); (115 : t_u8); (107 : t_u8); (48 : t_u8); (95 : t_u8); (50 : t_u8); (53 : t_u8); (53 : t_u8); (49 : t_u8); (57 : t_u8); (95 : t_u8); (67 : t_u8); (104 : t_u8); (97 : t_u8); (67 : t_u8); (104 : t_u8); (97 : t_u8); (80 : t_u8); (111 : t_u8); (108 : t_u8); (121 : t_u8); (95 : t_u8); (83 : t_u8); (72 : t_u8); (65 : t_u8); (50 : t_u8); (53 : t_u8); (54 : t_u8)]).

Definition initialize_initiator (prologue : t_Slice t_u8) (psk : t_Vec ((t_u8)) ((t_Global))) (s : t_KeyPair) (e : t_KeyPair) (rs : t_Slice t_u8) : t_HandshakeStateI0 :=
  let st := initialize_symmetric (unsize (0 v_Noise_KKpsk0_25519_ChaChaPoly_SHA256)) in
  let st := mix_hash (st) (prologue) in
  let st := mix_hash (st) (f_deref (f_public_key s)) in
  let st := mix_hash (st) (rs) in
  HandshakeStateI0 (psk) (st) (s) (e) (impl__to_vec (rs)).

Definition initialize_responder (prologue : t_Slice t_u8) (psk : t_Vec ((t_u8)) ((t_Global))) (s : t_KeyPair) (e : t_KeyPair) (rs : t_Slice t_u8) : t_HandshakeStateR0 :=
  let st := initialize_symmetric (unsize (0 v_Noise_KKpsk0_25519_ChaChaPoly_SHA256)) in
  let st := mix_hash (st) (prologue) in
  let st := mix_hash (st) (rs) in
  let st := mix_hash (st) (f_deref (f_public_key s)) in
  HandshakeStateR0 (st) (psk) (s) (e) (impl__to_vec (rs)).

Definition write_message1 (hs : t_HandshakeStateI0) (payload : t_Slice t_u8) : t_Result (((t_HandshakeStateI1*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let HandshakeStateI0 (st, psk, s, e, rs) := hs in
  let st := mix_key_and_hash (st) (f_deref (psk)) in
  let st := mix_hash (st) (f_deref (f_public_key e)) in
  let st := mix_key (st) (f_deref (f_public_key e)) in
  let es := dh (e) (f_deref (rs)) in
  let st := mix_key (st) (f_deref (es)) in
  let ss := dh (s) (f_deref (rs)) in
  let st := mix_key (st) (f_deref (ss)) in
  let (st,ciphertext) := encrypt_and_hash (st) (payload) in
  Result_Ok (let hs := HandshakeStateI1 (st) (s) (e) in
  Result_Ok ((hs,ciphertext)))).

Definition read_message1 (hs : t_HandshakeStateR0) (ciphertext : t_Slice t_u8) : t_Result (((t_HandshakeStateR1*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let HandshakeStateR0 (st, psk, s, e, rs) := hs in
  let re := f_index (ciphertext) (Range ((0 : t_usize)) (v_DHLEN)) in
  let ciphertext := f_index (ciphertext) (Range (v_DHLEN) (impl__len (ciphertext))) in
  let st := mix_key_and_hash (st) (f_deref (psk)) in
  let st := mix_hash (st) (re) in
  let st := mix_key (st) (re) in
  let es := dh (s) (re) in
  let st := mix_key (st) (f_deref (es)) in
  let ss := dh (s) (f_deref (rs)) in
  let st := mix_key (st) (f_deref (ss)) in
  let (st,plaintext) := decrypt_and_hash (st) (ciphertext) in
  Result_Ok (let hs := HandshakeStateR1 (st) (e) (rs) (impl__to_vec (re)) in
  Result_Ok ((hs,plaintext)))).

Definition write_message2 (hs : t_HandshakeStateR1) (payload : t_Slice t_u8) : t_Result (((t_Transport*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let HandshakeStateR1 (st, e, rs, re) := hs in
  let st := mix_hash (st) (f_deref (f_public_key e)) in
  let st := mix_key (st) (f_deref (f_public_key e)) in
  let ee := dh (e) (f_deref (re)) in
  let st := mix_key (st) (f_deref (ee)) in
  let se := dh (e) (f_deref (rs)) in
  let st := mix_key (st) (f_deref (se)) in
  let (st,ciphertext) := encrypt_and_hash (st) (payload) in
  Result_Ok (let (c1,c2,h) := split (st) in
  let tx := Transport (c2) (c1) (h) in
  Result_Ok ((tx,ciphertext)))).

Definition read_message2 (hs : t_HandshakeStateI1) (ciphertext : t_Slice t_u8) : t_Result (((t_Transport*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let HandshakeStateI1 (st, s, e) := hs in
  let re := f_index (ciphertext) (Range ((0 : t_usize)) (v_DHLEN)) in
  let ciphertext := f_index (ciphertext) (Range (v_DHLEN) (impl__len (ciphertext))) in
  let st := mix_hash (st) (re) in
  let st := mix_key (st) (re) in
  let ee := dh (e) (re) in
  let st := mix_key (st) (f_deref (ee)) in
  let se := dh (s) (re) in
  let st := mix_key (st) (f_deref (se)) in
  let (st,plaintext) := decrypt_and_hash (st) (ciphertext) in
  Result_Ok (let (c1,c2,h) := split (st) in
  let tx := Transport (c1) (c2) (h) in
  Result_Ok ((tx,plaintext)))).

Definition write_transport (tx : t_Transport) (ad : t_Slice t_u8) (payload : t_Slice t_u8) : t_Result (((t_Transport*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let Transport (send, recv, handshake_hash) := tx in
  let (send,ciphertext) := encrypt_with_ad (send) (ad) (payload) in
  Result_Ok (let tx := Transport (send) (recv) (handshake_hash) in
  Result_Ok ((tx,ciphertext)))).

Definition read_transport (tx : t_Transport) (ad : t_Slice t_u8) (ciphertext : t_Slice t_u8) : t_Result (((t_Transport*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let Transport (send, recv, handshake_hash) := tx in
  let (recv,payload) := decrypt_with_ad (recv) (ad) (ciphertext) in
  Result_Ok (let tx := Transport (send) (recv) (handshake_hash) in
  Result_Ok ((tx,payload)))).
