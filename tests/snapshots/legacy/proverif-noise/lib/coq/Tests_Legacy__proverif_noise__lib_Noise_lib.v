(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)





Record CipherState_record : Type :=
  {
    CipherState_f_k : t_Option ((t_Vec ((t_u8)) ((t_Global))));
    CipherState_f_n : t_u64;
  }.



#[export] Instance settable_CipherState_record : Settable _ :=
  settable! (Build_CipherState_record) <CipherState_f_k; CipherState_f_n>.

Record SymmetricState_record : Type :=
  {
    SymmetricState_f_cs : t_CipherState;
    SymmetricState_f_ck : t_Vec ((t_u8)) ((t_Global));
    SymmetricState_f_h : t_Vec ((t_u8)) ((t_Global));
  }.




#[export] Instance settable_SymmetricState_record : Settable _ :=
  settable! (Build_SymmetricState_record) <SymmetricState_f_cs; SymmetricState_f_ck; SymmetricState_f_h>.

Definition initialize_key (key : t_Option ((t_Vec ((t_u8)) ((t_Global))))) : t_CipherState :=
  CipherState (key) ((0 : t_u64)).

Definition has_key (cs : t_CipherState) : bool :=
  impl__is_some (f_k cs).

Definition set_nonce (cs : t_CipherState) (n : t_u64) : t_CipherState :=
  let CipherState (k, _) := cs in
  CipherState (k) (n).

Definition encrypt_with_ad (cs : t_CipherState) (ad : t_Slice t_u8) (plaintext : t_Slice t_u8) : t_Result (((t_CipherState*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  let CipherState (k, n) := cs in
  if
    f_eq (n) ((18446744073709551615 : t_u64))
  then
    Result_Err (Error_CryptoError)
  else
    match k with
    | Option_Some (k) =>
      let cip := encrypt (f_deref (k)) (n) (ad) (plaintext) in
      Result_Ok ((CipherState (Option_Some (k)) (f_add (n) ((1 : t_u64))),cip))
    | Option_None =>
      Result_Ok ((CipherState (k) (n),impl__to_vec (plaintext)))
    end.

Definition decrypt_with_ad (cs : t_CipherState) (ad : t_Slice t_u8) (ciphertext : t_Slice t_u8) : t_Result (((t_CipherState*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let CipherState (k, n) := cs in
  if
    f_eq (n) ((18446744073709551615 : t_u64))
  then
    Result_Ok (Result_Err (Error_CryptoError))
  else
    match k with
    | Option_Some (k) =>
      let plain := decrypt (f_deref (k)) (n) (ad) (ciphertext) in
      Result_Ok (Result_Ok ((CipherState (Option_Some (k)) (f_add (n) ((1 : t_u64))),plain)))
    | Option_None =>
      Result_Ok (Result_Ok ((CipherState (k) (n),impl__to_vec (ciphertext))))
    end).

Definition rekey (cs : t_CipherState) : t_Result ((t_CipherState)) ((t_Error)) :=
  let CipherState (k, n) := cs in
  match k with
  | Option_Some (k) =>
    let new_k := rekey (f_deref (k)) in
    Result_Ok (CipherState (Option_Some (new_k)) (n))
  | Option_None =>
    Result_Err (Error_CryptoError)
  end.

Definition initialize_symmetric (protocol_name : t_Slice t_u8) : t_SymmetricState :=
  let pnlen := impl__len (protocol_name) in
  let hv : t_Vec ((t_u8)) ((t_Global)) := if
    f_lt (pnlen) (v_HASHLEN)
  then
    impl__concat (unsize ([protocol_name; f_deref (from_elem ((0 : t_u8)) (f_sub ((32 : t_usize)) (pnlen)))]))
  else
    hash (protocol_name) in
  let ck := f_clone (hv) in
  SymmetricState (initialize_key (Option_None)) (ck) (hv).

Definition mix_key (st : t_SymmetricState) (input_key_material : t_Slice t_u8) : t_SymmetricState :=
  let SymmetricState (_, ck, h) := st in
  let (ck,temp_k) := hkdf2 (f_deref (ck)) (input_key_material) in
  let temp_k := if
    f_eq (v_HASHLEN) ((64 : t_usize))
  then
    let temp_k := impl_1__truncate (temp_k) ((32 : t_usize)) in
    temp_k
  else
    temp_k in
  SymmetricState (initialize_key (Option_Some (temp_k))) (ck) (h).

Definition mix_hash (st : t_SymmetricState) (data : t_Slice t_u8) : t_SymmetricState :=
  let SymmetricState (cs, ck, h) := st in
  SymmetricState (cs) (ck) (hash (f_deref (impl__concat (unsize ([f_deref (h); data]))))).

Definition mix_key_and_hash (st : t_SymmetricState) (input_key_material : t_Slice t_u8) : t_SymmetricState :=
  let SymmetricState (_, ck, h) := st in
  let (ck,temp_h,temp_k) := hkdf3 (f_deref (ck)) (input_key_material) in
  let new_h := h in
  let new_h := impl_2__extend_from_slice (new_h) (f_deref (temp_h)) in
  let new_h := hash (f_deref (new_h)) in
  let temp_k := if
    f_eq (v_HASHLEN) ((64 : t_usize))
  then
    let temp_k := impl_1__truncate (temp_k) ((32 : t_usize)) in
    temp_k
  else
    temp_k in
  SymmetricState (initialize_key (Option_Some (temp_k))) (ck) (new_h).

Definition encrypt_and_hash (st : t_SymmetricState) (plaintext : t_Slice t_u8) : t_Result (((t_SymmetricState*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let (new_cs,ciphertext) := encrypt_with_ad (f_cs st) (f_deref (f_h st)) (plaintext) in
  Result_Ok (let new_h := f_clone (f_h st) in
  let new_h := impl_2__extend_from_slice (new_h) (f_deref (ciphertext)) in
  let new_h := hash (f_deref (new_h)) in
  Result_Ok ((SymmetricState (new_cs) (f_ck st) (new_h),ciphertext)))).

Definition decrypt_and_hash (st : t_SymmetricState) (ciphertext : t_Slice t_u8) : t_Result (((t_SymmetricState*t_Vec ((t_u8)) ((t_Global))))) ((t_Error)) :=
  run (let (new_cs,plaintext) := decrypt_with_ad (f_cs st) (f_deref (f_h st)) (ciphertext) in
  Result_Ok (let new_h := f_clone (f_h st) in
  let new_h := impl_2__extend_from_slice (new_h) (ciphertext) in
  let new_h := hash (f_deref (new_h)) in
  Result_Ok ((SymmetricState (new_cs) (f_ck st) (new_h),plaintext)))).

Definition split (st : t_SymmetricState) : (t_CipherState*t_CipherState*t_Vec ((t_u8)) ((t_Global))) :=
  let (temp_k1,temp_k2) := hkdf2 (f_deref (f_ck st)) (f_deref (impl__new (tt))) in
  let (temp_k1,temp_k2) := if
    f_eq (v_HASHLEN) ((64 : t_usize))
  then
    let temp_k1 := impl_1__truncate (temp_k1) ((32 : t_usize)) in
    let temp_k2 := impl_1__truncate (temp_k2) ((32 : t_usize)) in
    (temp_k1,temp_k2)
  else
    (temp_k1,temp_k2) in
  (initialize_key (Option_Some (temp_k1)),initialize_key (Option_Some (temp_k2)),f_h st).
