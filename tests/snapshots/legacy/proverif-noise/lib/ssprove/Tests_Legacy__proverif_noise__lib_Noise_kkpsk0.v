(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_HandshakeStateI0 : choice_type :=
  (t_SymmetricState × t_Vec int8 t_Global × t_KeyPair × t_KeyPair × t_Vec int8 t_Global).
Equations f_st (s : both t_HandshakeStateI0) : both t_SymmetricState :=
  f_st s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_SymmetricState)) : both t_SymmetricState.
Fail Next Obligation.
Equations f_psk (s : both t_HandshakeStateI0) : both (t_Vec int8 t_Global) :=
  f_psk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations f_s (s : both t_HandshakeStateI0) : both t_KeyPair :=
  f_s s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_e (s : both t_HandshakeStateI0) : both t_KeyPair :=
  f_e s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_rs (s : both t_HandshakeStateI0) : both (t_Vec int8 t_Global) :=
  f_rs s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_HandshakeStateI0 {f_st : both t_SymmetricState} {f_psk : both (t_Vec int8 t_Global)} {f_s : both t_KeyPair} {f_e : both t_KeyPair} {f_rs : both (t_Vec int8 t_Global)} : both (t_HandshakeStateI0) :=
  Build_t_HandshakeStateI0  :=
    bind_both f_rs (fun f_rs =>
      bind_both f_e (fun f_e =>
        bind_both f_s (fun f_s =>
          bind_both f_psk (fun f_psk =>
            bind_both f_st (fun f_st =>
              ret_both ((f_st,f_psk,f_s,f_e,f_rs) : (t_HandshakeStateI0))))))) : both (t_HandshakeStateI0).
Fail Next Obligation.
Notation "'Build_t_HandshakeStateI0' '[' x ']' '(' 'f_st' ':=' y ')'" := (Build_t_HandshakeStateI0 (f_st := y) (f_psk := f_psk x) (f_s := f_s x) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateI0' '[' x ']' '(' 'f_psk' ':=' y ')'" := (Build_t_HandshakeStateI0 (f_st := f_st x) (f_psk := y) (f_s := f_s x) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateI0' '[' x ']' '(' 'f_s' ':=' y ')'" := (Build_t_HandshakeStateI0 (f_st := f_st x) (f_psk := f_psk x) (f_s := y) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateI0' '[' x ']' '(' 'f_e' ':=' y ')'" := (Build_t_HandshakeStateI0 (f_st := f_st x) (f_psk := f_psk x) (f_s := f_s x) (f_e := y) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateI0' '[' x ']' '(' 'f_rs' ':=' y ')'" := (Build_t_HandshakeStateI0 (f_st := f_st x) (f_psk := f_psk x) (f_s := f_s x) (f_e := f_e x) (f_rs := y)).

Definition t_HandshakeStateI1 : choice_type :=
  (t_SymmetricState × t_KeyPair × t_KeyPair).
Equations f_st (s : both t_HandshakeStateI1) : both t_SymmetricState :=
  f_st s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_SymmetricState)) : both t_SymmetricState.
Fail Next Obligation.
Equations f_s (s : both t_HandshakeStateI1) : both t_KeyPair :=
  f_s s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_e (s : both t_HandshakeStateI1) : both t_KeyPair :=
  f_e s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations Build_t_HandshakeStateI1 {f_st : both t_SymmetricState} {f_s : both t_KeyPair} {f_e : both t_KeyPair} : both (t_HandshakeStateI1) :=
  Build_t_HandshakeStateI1  :=
    bind_both f_e (fun f_e =>
      bind_both f_s (fun f_s =>
        bind_both f_st (fun f_st =>
          ret_both ((f_st,f_s,f_e) : (t_HandshakeStateI1))))) : both (t_HandshakeStateI1).
Fail Next Obligation.
Notation "'Build_t_HandshakeStateI1' '[' x ']' '(' 'f_st' ':=' y ')'" := (Build_t_HandshakeStateI1 (f_st := y) (f_s := f_s x) (f_e := f_e x)).
Notation "'Build_t_HandshakeStateI1' '[' x ']' '(' 'f_s' ':=' y ')'" := (Build_t_HandshakeStateI1 (f_st := f_st x) (f_s := y) (f_e := f_e x)).
Notation "'Build_t_HandshakeStateI1' '[' x ']' '(' 'f_e' ':=' y ')'" := (Build_t_HandshakeStateI1 (f_st := f_st x) (f_s := f_s x) (f_e := y)).

Definition t_HandshakeStateR0 : choice_type :=
  (t_SymmetricState × t_Vec int8 t_Global × t_KeyPair × t_KeyPair × t_Vec int8 t_Global).
Equations f_st (s : both t_HandshakeStateR0) : both t_SymmetricState :=
  f_st s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_SymmetricState)) : both t_SymmetricState.
Fail Next Obligation.
Equations f_psk (s : both t_HandshakeStateR0) : both (t_Vec int8 t_Global) :=
  f_psk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations f_s (s : both t_HandshakeStateR0) : both t_KeyPair :=
  f_s s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_e (s : both t_HandshakeStateR0) : both t_KeyPair :=
  f_e s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_rs (s : both t_HandshakeStateR0) : both (t_Vec int8 t_Global) :=
  f_rs s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_HandshakeStateR0 {f_st : both t_SymmetricState} {f_psk : both (t_Vec int8 t_Global)} {f_s : both t_KeyPair} {f_e : both t_KeyPair} {f_rs : both (t_Vec int8 t_Global)} : both (t_HandshakeStateR0) :=
  Build_t_HandshakeStateR0  :=
    bind_both f_rs (fun f_rs =>
      bind_both f_e (fun f_e =>
        bind_both f_s (fun f_s =>
          bind_both f_psk (fun f_psk =>
            bind_both f_st (fun f_st =>
              ret_both ((f_st,f_psk,f_s,f_e,f_rs) : (t_HandshakeStateR0))))))) : both (t_HandshakeStateR0).
Fail Next Obligation.
Notation "'Build_t_HandshakeStateR0' '[' x ']' '(' 'f_st' ':=' y ')'" := (Build_t_HandshakeStateR0 (f_st := y) (f_psk := f_psk x) (f_s := f_s x) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateR0' '[' x ']' '(' 'f_psk' ':=' y ')'" := (Build_t_HandshakeStateR0 (f_st := f_st x) (f_psk := y) (f_s := f_s x) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateR0' '[' x ']' '(' 'f_s' ':=' y ')'" := (Build_t_HandshakeStateR0 (f_st := f_st x) (f_psk := f_psk x) (f_s := y) (f_e := f_e x) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateR0' '[' x ']' '(' 'f_e' ':=' y ')'" := (Build_t_HandshakeStateR0 (f_st := f_st x) (f_psk := f_psk x) (f_s := f_s x) (f_e := y) (f_rs := f_rs x)).
Notation "'Build_t_HandshakeStateR0' '[' x ']' '(' 'f_rs' ':=' y ')'" := (Build_t_HandshakeStateR0 (f_st := f_st x) (f_psk := f_psk x) (f_s := f_s x) (f_e := f_e x) (f_rs := y)).

Definition t_HandshakeStateR1 : choice_type :=
  (t_SymmetricState × t_KeyPair × t_Vec int8 t_Global × t_Vec int8 t_Global).
Equations f_st (s : both t_HandshakeStateR1) : both t_SymmetricState :=
  f_st s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_SymmetricState)) : both t_SymmetricState.
Fail Next Obligation.
Equations f_e (s : both t_HandshakeStateR1) : both t_KeyPair :=
  f_e s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_KeyPair)) : both t_KeyPair.
Fail Next Obligation.
Equations f_rs (s : both t_HandshakeStateR1) : both (t_Vec int8 t_Global) :=
  f_rs s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations f_re (s : both t_HandshakeStateR1) : both (t_Vec int8 t_Global) :=
  f_re s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_HandshakeStateR1 {f_st : both t_SymmetricState} {f_e : both t_KeyPair} {f_rs : both (t_Vec int8 t_Global)} {f_re : both (t_Vec int8 t_Global)} : both (t_HandshakeStateR1) :=
  Build_t_HandshakeStateR1  :=
    bind_both f_re (fun f_re =>
      bind_both f_rs (fun f_rs =>
        bind_both f_e (fun f_e =>
          bind_both f_st (fun f_st =>
            ret_both ((f_st,f_e,f_rs,f_re) : (t_HandshakeStateR1)))))) : both (t_HandshakeStateR1).
Fail Next Obligation.
Notation "'Build_t_HandshakeStateR1' '[' x ']' '(' 'f_st' ':=' y ')'" := (Build_t_HandshakeStateR1 (f_st := y) (f_e := f_e x) (f_rs := f_rs x) (f_re := f_re x)).
Notation "'Build_t_HandshakeStateR1' '[' x ']' '(' 'f_e' ':=' y ')'" := (Build_t_HandshakeStateR1 (f_st := f_st x) (f_e := y) (f_rs := f_rs x) (f_re := f_re x)).
Notation "'Build_t_HandshakeStateR1' '[' x ']' '(' 'f_rs' ':=' y ')'" := (Build_t_HandshakeStateR1 (f_st := f_st x) (f_e := f_e x) (f_rs := y) (f_re := f_re x)).
Notation "'Build_t_HandshakeStateR1' '[' x ']' '(' 'f_re' ':=' y ')'" := (Build_t_HandshakeStateR1 (f_st := f_st x) (f_e := f_e x) (f_rs := f_rs x) (f_re := y)).

Definition t_Transport : choice_type :=
  (t_CipherState × t_CipherState × t_Vec int8 t_Global).
Equations f_send (s : both t_Transport) : both t_CipherState :=
  f_send s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_CipherState)) : both t_CipherState.
Fail Next Obligation.
Equations f_recv (s : both t_Transport) : both t_CipherState :=
  f_recv s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_CipherState)) : both t_CipherState.
Fail Next Obligation.
Equations f_handshake_hash (s : both t_Transport) : both (t_Vec int8 t_Global) :=
  f_handshake_hash s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_Transport {f_send : both t_CipherState} {f_recv : both t_CipherState} {f_handshake_hash : both (t_Vec int8 t_Global)} : both (t_Transport) :=
  Build_t_Transport  :=
    bind_both f_handshake_hash (fun f_handshake_hash =>
      bind_both f_recv (fun f_recv =>
        bind_both f_send (fun f_send =>
          ret_both ((f_send,f_recv,f_handshake_hash) : (t_Transport))))) : both (t_Transport).
Fail Next Obligation.
Notation "'Build_t_Transport' '[' x ']' '(' 'f_send' ':=' y ')'" := (Build_t_Transport (f_send := y) (f_recv := f_recv x) (f_handshake_hash := f_handshake_hash x)).
Notation "'Build_t_Transport' '[' x ']' '(' 'f_recv' ':=' y ')'" := (Build_t_Transport (f_send := f_send x) (f_recv := y) (f_handshake_hash := f_handshake_hash x)).
Notation "'Build_t_Transport' '[' x ']' '(' 'f_handshake_hash' ':=' y ')'" := (Build_t_Transport (f_send := f_send x) (f_recv := f_recv x) (f_handshake_hash := y)).

Definition t_ProtocolName : choice_type :=
  (nseq int8 36).
Equations 0 (s : both t_ProtocolName) : both (nseq int8 36) :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : (nseq int8 36))) : both (nseq int8 36).
Fail Next Obligation.
Equations Build_t_ProtocolName {0 : both (nseq int8 36)} : both (t_ProtocolName) :=
  Build_t_ProtocolName  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_ProtocolName))) : both (t_ProtocolName).
Fail Next Obligation.
Notation "'Build_t_ProtocolName' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ProtocolName (0 := y)).

Equations v_Noise_KKpsk0_25519_ChaChaPoly_SHA256 : both t_ProtocolName :=
  v_Noise_KKpsk0_25519_ChaChaPoly_SHA256  :=
    ProtocolName (array_from_list [ret_both (78 : int8);
      ret_both (111 : int8);
      ret_both (105 : int8);
      ret_both (115 : int8);
      ret_both (101 : int8);
      ret_both (95 : int8);
      ret_both (75 : int8);
      ret_both (75 : int8);
      ret_both (112 : int8);
      ret_both (115 : int8);
      ret_both (107 : int8);
      ret_both (48 : int8);
      ret_both (95 : int8);
      ret_both (50 : int8);
      ret_both (53 : int8);
      ret_both (53 : int8);
      ret_both (49 : int8);
      ret_both (57 : int8);
      ret_both (95 : int8);
      ret_both (67 : int8);
      ret_both (104 : int8);
      ret_both (97 : int8);
      ret_both (67 : int8);
      ret_both (104 : int8);
      ret_both (97 : int8);
      ret_both (80 : int8);
      ret_both (111 : int8);
      ret_both (108 : int8);
      ret_both (121 : int8);
      ret_both (95 : int8);
      ret_both (83 : int8);
      ret_both (72 : int8);
      ret_both (65 : int8);
      ret_both (50 : int8);
      ret_both (53 : int8);
      ret_both (54 : int8)]) : both t_ProtocolName.
Fail Next Obligation.

Equations initialize_initiator (prologue : both (seq int8)) (psk : both (t_Vec int8 t_Global)) (s : both t_KeyPair) (e : both t_KeyPair) (rs : both (seq int8)) : both t_HandshakeStateI0 :=
  initialize_initiator prologue psk s e rs  :=
    letb st := initialize_symmetric (unsize (0 v_Noise_KKpsk0_25519_ChaChaPoly_SHA256)) in
    letb st := mix_hash st prologue in
    letb st := mix_hash st (f_deref (f_public_key s)) in
    letb st := mix_hash st rs in
    Build_t_HandshakeStateI0 (f_psk := psk) (f_st := st) (f_s := s) (f_e := e) (f_rs := impl__to_vec rs) : both t_HandshakeStateI0.
Fail Next Obligation.

Equations initialize_responder (prologue : both (seq int8)) (psk : both (t_Vec int8 t_Global)) (s : both t_KeyPair) (e : both t_KeyPair) (rs : both (seq int8)) : both t_HandshakeStateR0 :=
  initialize_responder prologue psk s e rs  :=
    letb st := initialize_symmetric (unsize (0 v_Noise_KKpsk0_25519_ChaChaPoly_SHA256)) in
    letb st := mix_hash st prologue in
    letb st := mix_hash st rs in
    letb st := mix_hash st (f_deref (f_public_key s)) in
    Build_t_HandshakeStateR0 (f_st := st) (f_psk := psk) (f_s := s) (f_e := e) (f_rs := impl__to_vec rs) : both t_HandshakeStateR0.
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)
