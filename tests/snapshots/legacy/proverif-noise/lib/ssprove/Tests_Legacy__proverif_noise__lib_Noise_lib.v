(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_CipherState : choice_type :=
  (t_Option (t_Vec int8 t_Global) × int64).
Equations f_k (s : both t_CipherState) : both (t_Option (t_Vec int8 t_Global)) :=
  f_k s  :=
    bind_both s (fun x =>
      ret_both (fst x : (t_Option (t_Vec int8 t_Global)))) : both (t_Option (t_Vec int8 t_Global)).
Fail Next Obligation.
Equations f_n (s : both t_CipherState) : both int64 :=
  f_n s  :=
    bind_both s (fun x =>
      ret_both (snd x : int64)) : both int64.
Fail Next Obligation.
Equations Build_t_CipherState {f_k : both (t_Option (t_Vec int8 t_Global))} {f_n : both int64} : both (t_CipherState) :=
  Build_t_CipherState  :=
    bind_both f_n (fun f_n =>
      bind_both f_k (fun f_k =>
        ret_both ((f_k,f_n) : (t_CipherState)))) : both (t_CipherState).
Fail Next Obligation.
Notation "'Build_t_CipherState' '[' x ']' '(' 'f_k' ':=' y ')'" := (Build_t_CipherState (f_k := y) (f_n := f_n x)).
Notation "'Build_t_CipherState' '[' x ']' '(' 'f_n' ':=' y ')'" := (Build_t_CipherState (f_k := f_k x) (f_n := y)).

Definition t_SymmetricState : choice_type :=
  (t_CipherState × t_Vec int8 t_Global × t_Vec int8 t_Global).
Equations f_cs (s : both t_SymmetricState) : both t_CipherState :=
  f_cs s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_CipherState)) : both t_CipherState.
Fail Next Obligation.
Equations f_ck (s : both t_SymmetricState) : both (t_Vec int8 t_Global) :=
  f_ck s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations f_h (s : both t_SymmetricState) : both (t_Vec int8 t_Global) :=
  f_h s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_SymmetricState {f_cs : both t_CipherState} {f_ck : both (t_Vec int8 t_Global)} {f_h : both (t_Vec int8 t_Global)} : both (t_SymmetricState) :=
  Build_t_SymmetricState  :=
    bind_both f_h (fun f_h =>
      bind_both f_ck (fun f_ck =>
        bind_both f_cs (fun f_cs =>
          ret_both ((f_cs,f_ck,f_h) : (t_SymmetricState))))) : both (t_SymmetricState).
Fail Next Obligation.
Notation "'Build_t_SymmetricState' '[' x ']' '(' 'f_cs' ':=' y ')'" := (Build_t_SymmetricState (f_cs := y) (f_ck := f_ck x) (f_h := f_h x)).
Notation "'Build_t_SymmetricState' '[' x ']' '(' 'f_ck' ':=' y ')'" := (Build_t_SymmetricState (f_cs := f_cs x) (f_ck := y) (f_h := f_h x)).
Notation "'Build_t_SymmetricState' '[' x ']' '(' 'f_h' ':=' y ')'" := (Build_t_SymmetricState (f_cs := f_cs x) (f_ck := f_ck x) (f_h := y)).

Equations initialize_key (key : both (t_Option (t_Vec int8 t_Global))) : both t_CipherState :=
  initialize_key key  :=
    Build_t_CipherState (f_k := key) (f_n := ret_both (0 : int64)) : both t_CipherState.
Fail Next Obligation.

Equations has_key (cs : both t_CipherState) : both 'bool :=
  has_key cs  :=
    impl__is_some (f_k cs) : both 'bool.
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

(*item error backend*)

Equations initialize_symmetric (protocol_name : both (seq int8)) : both t_SymmetricState :=
  initialize_symmetric protocol_name  :=
    letb pnlen := impl__len protocol_name in
    letb (hv : t_Vec int8 t_Global) := ifb pnlen <.? v_HASHLEN
    then impl__concat (unsize (array_from_list [protocol_name;
      f_deref (from_elem (ret_both (0 : int8)) ((ret_both (32 : uint_size)) .- pnlen))]))
    else hash protocol_name in
    letb ck := f_clone hv in
    Build_t_SymmetricState (f_cs := initialize_key Option_None) (f_ck := ck) (f_h := hv) : both t_SymmetricState.
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

Equations encrypt_and_hash (st : both t_SymmetricState) (plaintext : both (seq int8)) : both (t_Result (t_SymmetricState × t_Vec int8 t_Global) t_Error) :=
  encrypt_and_hash st plaintext  :=
    run (letm[choice_typeMonad.result_bind_code t_Error] '(new_cs,ciphertext) := encrypt_with_ad (f_cs st) (f_deref (f_h st)) plaintext in
    Result_Ok (letb new_h := f_clone (f_h st) in
    letb new_h := impl_2__extend_from_slice new_h (f_deref ciphertext) in
    letb new_h := hash (f_deref new_h) in
    Result_Ok (prod_b (Build_t_SymmetricState (f_cs := new_cs) (f_ck := f_ck st) (f_h := new_h),ciphertext)))) : both (t_Result (t_SymmetricState × t_Vec int8 t_Global) t_Error).
Fail Next Obligation.

Equations decrypt_and_hash (st : both t_SymmetricState) (ciphertext : both (seq int8)) : both (t_Result (t_SymmetricState × t_Vec int8 t_Global) t_Error) :=
  decrypt_and_hash st ciphertext  :=
    run (letm[choice_typeMonad.result_bind_code t_Error] '(new_cs,plaintext) := decrypt_with_ad (f_cs st) (f_deref (f_h st)) ciphertext in
    Result_Ok (letb new_h := f_clone (f_h st) in
    letb new_h := impl_2__extend_from_slice new_h ciphertext in
    letb new_h := hash (f_deref new_h) in
    Result_Ok (prod_b (Build_t_SymmetricState (f_cs := new_cs) (f_ck := f_ck st) (f_h := new_h),plaintext)))) : both (t_Result (t_SymmetricState × t_Vec int8 t_Global) t_Error).
Fail Next Obligation.

Equations split (st : both t_SymmetricState) : both (t_CipherState × t_CipherState × t_Vec int8 t_Global) :=
  split st  :=
    letb '(temp_k1,temp_k2) := hkdf2 (f_deref (f_ck st)) (f_deref impl__new) in
    letb '(temp_k1,temp_k2) := ifb v_HASHLEN =.? (ret_both (64 : uint_size))
    then letb temp_k1 := impl_1__truncate temp_k1 (ret_both (32 : uint_size)) in
    letb temp_k2 := impl_1__truncate temp_k2 (ret_both (32 : uint_size)) in
    prod_b (temp_k1,temp_k2)
    else prod_b (temp_k1,temp_k2) in
    prod_b (initialize_key (Option_Some temp_k1),initialize_key (Option_Some temp_k2),f_h st) : both (t_CipherState × t_CipherState × t_Vec int8 t_Global).
Fail Next Obligation.
