(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations f (x : both int8) : both (nseq int8 4) :=
  f x  :=
    failure (ret_both (ExplicitRejection { reason: "a node of kind [Raw_pointer] have been found in the AST" }


Note: the error was labeled with context `reject_RawOrMutPointer`.
 : chString)) (ret_both ({
 let y: raw_pointer!() = { cast(x) };
 {
 let _: tuple0 = {
 {
 let _: tuple0 = {
 {
 let _: tuple0 = {
 std::io::stdio::e_print({
 let args: [core::fmt::rt::t_Argument<
 lifetime!(something),
 >; 1... : chString)) : both (nseq int8 4).
Fail Next Obligation.

(*ExplicitRejection { reason: "a node of kind [Raw_pointer] have been found in the AST" }


Note: the error was labeled with context `reject_RawOrMutPointer`.

Last available AST for this item:

/// This struct contains a field which uses raw pointers, which are
/// not supported by hax. This item cannot be extracted at all: we
/// need to exclude it with `-i '-*::Foo'`.
/// @fail(extraction): ssprove(HAX0008), coq(HAX0008), fstar(HAX0008)
/// @fail(extraction): proverif(HAX0008)
#[allow(dead_code)]
#[allow(dead_code)]
#[feature(register_tool, if_let_guard)]
#[feature(
    coverage_attribute,
    stmt_expr_attributes,
    custom_inner_attributes,
    test,
    yield_expr,
    coroutines,
    coroutine_trait,
    no_core,
    core_intrinsics
)]
#[register_tool(_hax)]
struct t_Foo {
    f_unsupported_field: raw_pointer!(),
}
 todo(item)*)

Definition t_Bar : choice_type :=
  'unit.
Equations Build_t_Bar : both (t_Bar) :=
  Build_t_Bar  :=
    ret_both (tt (* Empty tuple *) : (t_Bar)) : both (t_Bar).
Fail Next Obligation.

#[global] Program Instance t_Bar_t_From : t_From t_Bar 'unit :=
  let f_from := fun  (_ : both 'unit) => Bar : both t_Bar in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Bar_t_From.

Equations f_from__impl_1__from (_ : both int8) : both t_Bar :=
  f_from__impl_1__from _  :=
    Bar : both t_Bar.
Fail Next Obligation.

#[global] Program Instance t_Bar_t_From : t_From t_Bar int8 :=
  let f_from := fun  (x : both int8) => f_from__impl_1__from x : both t_Bar in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Bar_t_From.

Definition t_Holder {v_T : v_T} : choice_type :=
  (t_Vec v_T t_Global).
Equations f_value {v_T : v_T} (s : both t_Holder) : both (t_Vec v_T t_Global) :=
  f_value s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec v_T t_Global))) : both (t_Vec v_T t_Global).
Fail Next Obligation.
Equations Build_t_Holder {v_T : v_T} {f_value : both (t_Vec v_T t_Global)} : both (t_Holder) :=
  Build_t_Holder  :=
    bind_both f_value (fun f_value =>
      ret_both ((f_value) : (t_Holder))) : both (t_Holder).
Fail Next Obligation.
Notation "'Build_t_Holder' '[' x ']' '(' 'f_value' ':=' y ')'" := (Build_t_Holder (f_value := y)).

#[global] Program Instance t_Holder v_T_t_From {v_T : v_T} : t_From (t_Holder v_T) 'unit :=
  let f_from := fun  (_ : both 'unit) => Build_t_Holder (f_value := impl__new) : both (t_Holder v_T) in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Holder v_T_t_From.

Definition t_Param {v_SIZE : both uint_size} : choice_type :=
  (nseq int8 (is_pure (v_SIZE))).
Equations f_value {v_SIZE : both uint_size} (s : both t_Param) : both (nseq int8 (is_pure (v_SIZE))) :=
  f_value s  :=
    bind_both s (fun x =>
      ret_both (x : (nseq int8 (is_pure (v_SIZE))))) : both (nseq int8 (is_pure (v_SIZE))).
Fail Next Obligation.
Equations Build_t_Param {v_SIZE : both uint_size} {f_value : both (nseq int8 (is_pure (v_SIZE)))} : both (t_Param) :=
  Build_t_Param  :=
    bind_both f_value (fun f_value =>
      ret_both ((f_value) : (t_Param))) : both (t_Param).
Fail Next Obligation.
Notation "'Build_t_Param' '[' x ']' '(' 'f_value' ':=' y ')'" := (Build_t_Param (f_value := y)).

#[global] Program Instance t_Param (both uint_size)_t_From {v_SIZE : both uint_size} : t_From (t_Param (both uint_size)) 'unit :=
  let f_from := fun  (_ : both 'unit) => Build_t_Param (f_value := repeat (ret_both (0 : int8)) v_SIZE) : both (t_Param (both uint_size)) in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Param (both uint_size)_t_From.

Equations ff_generic {v_X : both uint_size} {v_U : v_U} (e_x : both v_U) : both (t_Param (both uint_size)) :=
  ff_generic e_x  :=
    Build_t_Param (f_value := repeat (ret_both (0 : int8)) v_X) : both (t_Param (both uint_size)).
Fail Next Obligation.

Class t_T (Self : choice_type) (v_Self : v_Self) := {
  f_Assoc : choice_type ;
  f_d : (both 'unit) ;
}.

#[global] Program Instance int8_t_T : t_T int8 :=
  let f_Assoc := int8 : choice_type in
  let f_d := fun  (_ : both 'unit) => ret_both (tt : 'unit) : both 'unit in
  {| f_Assoc := (@f_Assoc);
  f_d := (@f_d)|}.
Fail Next Obligation.
Hint Unfold int8_t_T.

Class t_T2 (Self : choice_type) (v_Self : v_Self) := {
  f_d : (both 'unit) ;
}.

#[global] Program Instance int8_t_T2 : t_T2 int8 :=
  let f_d := fun  (_ : both 'unit) => ret_both (tt : 'unit) : both 'unit in
  {| f_d := (@f_d)|}.
Fail Next Obligation.
Hint Unfold int8_t_T2.

Equations padlen (b : both (seq int8)) (n : both uint_size) : both uint_size :=
  padlen b n  :=
    ifb andb (n >.? (ret_both (0 : uint_size))) ((b.a[(n .- (ret_both (1 : uint_size)))]) =.? (ret_both (0 : int8)))
    then (ret_both (1 : uint_size)) .+ (padlen b (n .- (ret_both (1 : uint_size))))
    else ret_both (0 : uint_size) : both uint_size.
Fail Next Obligation.
