(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Definition f (x : t_u8) `{f_lt (x) ((254 : t_u8)) = true} : t_Array (t_u8) ((4 : t_usize)) :=
  failure (("ExplicitRejection { reason: "a node of kind [Raw_pointer] have been found in the AST" }


Note: the error was labeled with context `reject_RawOrMutPointer`.
"%string : string)) (("{
 let y: raw_pointer!() = { cast(x) };
 {
 let _: tuple0 = {
 {
 let _: tuple0 = {
 {
 let _: tuple0 = {
 std::io::stdio::e_print({
 let args: [core::fmt::rt::t_Argument<
 lifetime!(something),
 >; 1..."%string : string)).
Lemma f_ensures (x : t_u8) :
  forall (H_requires : f_lt (x) ((254 : t_u8)) = true),
  let r := @f (x : t_u8) H_requires in
  f_gt (f_index (r) ((0 : t_usize))) (x) = true.
Proof. Admitted.

TODO: please implement the method `item'_HaxError`

Record Bar_record : Type :=
  {
  }.

#[export]
Notation "'Bar_Bar_record'" := Build_Bar_record.

Instance t_From_509179257 : t_From ((t_Bar)) ((unit)) :=
  {
    implaabbcc_t_From_f_from := fun  (() : unit)=>
      Bar;
  }.

Definition f_from__impl_1__from '(_ : t_u8) : t_Bar :=
  Bar.

Instance t_From_184197699 : t_From ((t_Bar)) ((t_u8)) :=
  {
    implaabbcc_t_From_f_from := fun  (x : t_u8)=>
      f_from__impl_1__from (x);
  }.

Record Holder_record (v_T : Type) : Type :=
  {
    Holder_f_value : t_Vec ((v_T)) ((t_Global));
  }.
Arguments Build_Holder_record {_}.
Arguments Holder_f_value {_}.
#[export] Instance settable_Holder_record `{v_T : Type} : Settable _ :=
  settable! (Build_Holder_record (v_T := v_T)) <Holder_f_value>.

Instance t_From_442094552 `{v_T : Type} : t_From ((t_Holder ((v_T)))) ((unit)) :=
  {
    implaabbcc_t_From_f_from := fun  (() : unit)=>
      Holder (impl__new (tt));
  }.

Record Param_record (v_SIZE : t_usize) : Type :=
  {
    Param_f_value : t_Array (t_u8) (v_SIZE);
  }.
Arguments Build_Param_record {_}.
Arguments Param_f_value {_}.
#[export] Instance settable_Param_record `{v_SIZE : t_usize} : Settable _ :=
  settable! (Build_Param_record (v_SIZE := v_SIZE)) <Param_f_value>.

Instance t_From_866459549 `{v_SIZE : t_usize} : t_From ((t_Param (v_SIZE))) ((unit)) :=
  {
    implaabbcc_t_From_f_from := fun  (() : unit)=>
      Param (repeat ((0 : t_u8)) (v_SIZE));
  }.

Definition ff_generic `{v_X : t_usize} `{v_U : Type} (e_x : v_U) : t_Param (v_X) :=
  Param (repeat ((0 : t_u8)) (v_X)).

Class t_T (v_Self : Type) : Type :=
  {
    f_Assoc : Type;
    f_d : unit -> unit;
  }.
Arguments t_T (_).

Instance t_T_465317481 : t_T ((t_u8)) :=
  {
    implaabbcc_t_T_f_Assoc := t_u8;
    implaabbcc_t_T_f_d := fun  (_ : unit)=>
      tt;
  }.

Class t_T2 (v_Self : Type) : Type :=
  {
    f_d : unit -> unit;
  }.
Arguments t_T2 (_).

Instance t_T2_37008592 : t_T2 ((t_u8)) :=
  {
    implaabbcc_t_T2_f_d := fun  (_ : unit)=>
      tt;
  }.

Fixpoint padlen (b : t_Slice t_u8) (n : t_usize) `{f_ge (impl__len (b)) (n) = true} : t_usize :=
  if
    andb (f_gt (n) ((0 : t_usize))) (f_eq (f_index (b) (f_sub (n) ((1 : t_usize)))) ((0 : t_u8)))
  then
    f_add ((1 : t_usize)) (padlen (b) (f_sub (n) ((1 : t_usize))))
  else
    (0 : t_usize).
Lemma padlen_ensures (b : t_Slice t_u8) (n : t_usize) :
  forall (H_requires : f_ge (impl__len (b)) (n) = true),
  let out := @padlen (b : t_Slice t_u8)(n : t_usize) H_requires in
  f_le (out) (n) = true.
Proof. Admitted.
