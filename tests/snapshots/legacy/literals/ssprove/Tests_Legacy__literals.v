(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations math_integers (x : both t_Int) : both int8 :=
  math_integers x  :=
    letb (_ : t_Int) := f_lift (ret_both (3 : uint_size)) in
    letb e_neg_dec := impl_Int__e_unsafe_from_str (ret_both (-340282366920938463463374607431768211455000 : chString)) in
    letb e_pos_dec := impl_Int__e_unsafe_from_str (ret_both (340282366920938463463374607431768211455000 : chString)) in
    letb e_neg_hex := impl_Int__e_unsafe_from_str (ret_both (-340282366920938463463374607431768211455000 : chString)) in
    letb e_pos_hex := impl_Int__e_unsafe_from_str (ret_both (340282366920938463463374607431768211455000 : chString)) in
    letb e_neg_octal := impl_Int__e_unsafe_from_str (ret_both (-340282366920938463463374607431768211455000 : chString)) in
    letb e_pos_octal := impl_Int__e_unsafe_from_str (ret_both (340282366920938463463374607431768211455000 : chString)) in
    letb e_neg_bin := impl_Int__e_unsafe_from_str (ret_both (-340282366920938463463374607431768211455000 : chString)) in
    letb e_pos_bin := impl_Int__e_unsafe_from_str (ret_both (340282366920938463463374607431768211455000 : chString)) in
    letb _ := (impl_Int__e_unsafe_from_str (ret_both (-340282366920938463463374607431768211455000 : chString))) >.? (impl_Int__e_unsafe_from_str (ret_both (340282366920938463463374607431768211455000 : chString))) in
    letb _ := x <.? x in
    letb _ := x >=.? x in
    letb _ := x <=.? x in
    letb _ := x <> x in
    letb _ := x =.? x in
    letb _ := x .+ x in
    letb _ := x .- x in
    letb _ := x .* x in
    letb _ := x ./ x in
    letb (_ : int16) := impl_Int__to_i16 x in
    letb (_ : int32) := impl_Int__to_i32 x in
    letb (_ : int64) := impl_Int__to_i64 x in
    letb (_ : int128) := impl_Int__to_i128 x in
    letb (_ : uint_size) := impl_Int__to_isize x in
    letb (_ : int16) := impl_Int__to_u16 x in
    letb (_ : int32) := impl_Int__to_u32 x in
    letb (_ : int64) := impl_Int__to_u64 x in
    letb (_ : int128) := impl_Int__to_u128 x in
    letb (_ : uint_size) := impl_Int__to_usize x in
    impl_Int__to_u8 (x .+ (x .* x)) : both int8.
Fail Next Obligation.

Equations panic_with_msg (_ : both 'unit) : both 'unit :=
  panic_with_msg _  :=
    never_to_any (panic_fmt (impl_1__new_const (array_from_list [ret_both (with msg : chString)]))) : both 'unit.
Fail Next Obligation.

Definition t_Foo : choice_type :=
  (int8).
Equations f_field (s : both t_Foo) : both int8 :=
  f_field s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Foo {f_field : both int8} : both (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_field (fun f_field =>
      ret_both ((f_field) : (t_Foo))) : both (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_field' ':=' y ')'" := (Build_t_Foo (f_field := y)).

#[global] Program Instance t_Foo_t_StructuralPartialEq : t_StructuralPartialEq t_Foo :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo_t_StructuralPartialEq.

#[global] Program Instance t_Foo_t_PartialEq : t_PartialEq t_Foo t_Foo :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo_t_PartialEq.

#[global] Program Instance t_Foo_t_Eq : t_Eq t_Foo :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo_t_Eq.

Equations v_CONSTANT : both t_Foo :=
  v_CONSTANT  :=
    Build_t_Foo (f_field := ret_both (3 : int8)) : both t_Foo.
Fail Next Obligation.

Equations numeric (_ : both 'unit) : both 'unit :=
  numeric _  :=
    letb (_ : uint_size) := ret_both (123 : uint_size) in
    letb (_ : uint_size) := ret_both (42 : uint_size) in
    letb (_ : uint_size) := ret_both (42 : uint_size) in
    letb (_ : int32) := ret_both (42 : int32) in
    letb (_ : int128) := ret_both (22222222222222222222 : int128) in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

(*item error backend*)

Equations casts (x8 : both int8) (x16 : both int16) (x32 : both int32) (x64 : both int64) (xs : both uint_size) : both 'unit :=
  casts x8 x16 x32 x64 xs  :=
    letb (_ : int64) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ x64) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int32) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ x32) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int16) := ((((cast_int (WS2 := _) x8) .+ x16) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int8) := (((x8 .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int64) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int32) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int16) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    letb (_ : int8) := ((((cast_int (WS2 := _) x8) .+ (cast_int (WS2 := _) x16)) .+ (cast_int (WS2 := _) x32)) .+ (cast_int (WS2 := _) x64)) .+ (cast_int (WS2 := _) xs) in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations empty_array (_ : both 'unit) : both 'unit :=
  empty_array _  :=
    letb (_ : seq int8) := unsize !TODO empty array! in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations fn_pointer_cast (_ : both 'unit) : both 'unit :=
  fn_pointer_cast _  :=
    letb (f : int32 -> int32) := fun x =>
      x in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

(*item error backend*)
