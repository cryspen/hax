(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(*item error backend*)

(*item error backend*)

Definition t_B : choice_type :=
  'unit.
Equations Build_t_B : both (t_B) :=
  Build_t_B  :=
    ret_both (tt (* Empty tuple *) : (t_B)) : both (t_B).
Fail Next Obligation.

Definition t_C : choice_type :=
  (uint_size).
Equations f_x (s : both t_C) : both uint_size :=
  f_x s  :=
    bind_both s (fun x =>
      ret_both (x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_C {f_x : both uint_size} : both (t_C) :=
  Build_t_C  :=
    bind_both f_x (fun f_x =>
      ret_both ((f_x) : (t_C))) : both (t_C).
Fail Next Obligation.
Notation "'Build_t_C' '[' x ']' '(' 'f_x' ':=' y ')'" := (Build_t_C (f_x := y)).

Definition t_X : choice_type :=
  'unit.
Equations Build_t_X : both (t_X) :=
  Build_t_X  :=
    ret_both (tt (* Empty tuple *) : (t_X)) : both (t_X).
Fail Next Obligation.

Equations mk_c (_ : both 'unit) : both t_C :=
  mk_c _  :=
    letb _ := Build_t_Foo_B (f_x := ret_both (3 : uint_size)) in
    letb _ := X in
    Build_t_C (f_x := ret_both (3 : uint_size)) : both t_C.
Fail Next Obligation.

Equations impl_Foo__f (self : both t_Foo) : both t_Foo :=
  impl_Foo__f self  :=
    Foo_A : both t_Foo.
Fail Next Obligation.

Equations impl_B__f (self : both t_B) : both t_B :=
  impl_B__f self  :=
    B : both t_B.
Fail Next Obligation.

Definition t_Foobar : choice_type :=
  (t_Foo).
Equations f_a (s : both t_Foobar) : both t_Foo :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (x : t_Foo)) : both t_Foo.
Fail Next Obligation.
Equations Build_t_Foobar {f_a : both t_Foo} : both (t_Foobar) :=
  Build_t_Foobar  :=
    bind_both f_a (fun f_a =>
      ret_both ((f_a) : (t_Foobar))) : both (t_Foobar).
Fail Next Obligation.
Notation "'Build_t_Foobar' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_Foobar (f_a := y)).

Equations f__g (_ : both 'unit) : both 'unit :=
  f__g _  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations f__g__impl_B__g (self : both t_B) : both uint_size :=
  f__g__impl_B__g self  :=
    ret_both (0 : uint_size) : both uint_size.
Fail Next Obligation.

Definition t_f__g__impl_B__g__Foo_B : choice_type :=
  (uint_size).
Equations f__g__impl_B__g__f_x (s : both t_f__g__impl_B__g__Foo_B) : both uint_size :=
  f__g__impl_B__g__f_x s  :=
    bind_both s (fun x =>
      ret_both (x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_f__g__impl_B__g__Foo_B {f__g__impl_B__g__f_x : both uint_size} : both (t_f__g__impl_B__g__Foo_B) :=
  Build_t_f__g__impl_B__g__Foo_B  :=
    bind_both f__g__impl_B__g__f_x (fun f__g__impl_B__g__f_x =>
      ret_both ((f__g__impl_B__g__f_x) : (t_f__g__impl_B__g__Foo_B))) : both (t_f__g__impl_B__g__Foo_B).
Fail Next Obligation.
Notation "'Build_t_f__g__impl_B__g__Foo_B' '[' x ']' '(' 'f__g__impl_B__g__f_x' ':=' y ')'" := (Build_t_f__g__impl_B__g__Foo_B (f__g__impl_B__g__f_x := y)).
Definition f__g__impl_B__g__t_Foo : choice_type :=
  ('unit ∐ t_f__g__impl_B__g__Foo_B).
Notation "'C_f__g__impl_B__g__Foo_A_case'" := (inl tt) (at level 100).
Equations C_f__g__impl_B__g__Foo_A : both f__g__impl_B__g__t_Foo :=
  C_f__g__impl_B__g__Foo_A  :=
    ret_both (inl (tt : 'unit) : f__g__impl_B__g__t_Foo) : both f__g__impl_B__g__t_Foo.
Fail Next Obligation.
Notation "'C_f__g__impl_B__g__Foo_B_case' x" := (inr x) (at level 100).
Equations C_f__g__impl_B__g__Foo_B (x : both t_f__g__impl_B__g__Foo_B) : both f__g__impl_B__g__t_Foo :=
  C_f__g__impl_B__g__Foo_B x  :=
    bind_both x (fun x =>
      ret_both (inr x : f__g__impl_B__g__t_Foo)) : both f__g__impl_B__g__t_Foo.
Fail Next Obligation.

Equations f__g__impl_Foo__g (self : both t_Foo) : both uint_size :=
  f__g__impl_Foo__g self  :=
    ret_both (1 : uint_size) : both uint_size.
Fail Next Obligation.

Equations f (x : both t_Foobar) : both uint_size :=
  f x  :=
    f__g__impl_Foo__g (f_a x) : both uint_size.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Equations f__g__impl_Foo__g__t_hello__h (_ : both 'unit) : both 'unit :=
  f__g__impl_Foo__g__t_hello__h _  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations reserved_names (val : both int8) (noeq : both int8) (of : both int8) : both int8 :=
  reserved_names val noeq of  :=
    (val .+ noeq) .+ of : both int8.
Fail Next Obligation.

Definition t_Arity1 {v_T : v_T} : choice_type :=
  (v_T).
Equations 0 {v_T : v_T} (s : both t_Arity1) : both v_T :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : v_T)) : both v_T.
Fail Next Obligation.
Equations Build_t_Arity1 {v_T : v_T} {0 : both v_T} : both (t_Arity1) :=
  Build_t_Arity1  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_Arity1))) : both (t_Arity1).
Fail Next Obligation.
Notation "'Build_t_Arity1' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_Arity1 (0 := y)).

Class t_T1 (Self : choice_type) (v_Self : v_Self) := {
}.

#[global] Program Instance t_Foo_t_T1 : t_T1 t_Foo :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo_t_T1.

#[global] Program Instance t_Foo × int8_t_T1 : t_T1 (t_Foo × int8) :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo × int8_t_T1.

Class t_T2_for_a (Self : choice_type) (v_Self : v_Self) := {
}.

#[global] Program Instance t_Arity1 (t_Foo × int8)_t_T2_for_a : t_T2_for_a (t_Arity1 (t_Foo × int8)) :=
  _.
Fail Next Obligation.
Hint Unfold t_Arity1 (t_Foo × int8)_t_T2_for_a.

Class t_T3_ee_for_a (Self : choice_type) (v_Self : v_Self) := {
}.

#[global] Program Instance t_Foo_t_T3_ee_for_a : t_T3_ee_for_a t_Foo :=
  _.
Fail Next Obligation.
Hint Unfold t_Foo_t_T3_ee_for_a.

Definition t_StructA : choice_type :=
  (uint_size).
Equations f_a (s : both t_StructA) : both uint_size :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_StructA {f_a : both uint_size} : both (t_StructA) :=
  Build_t_StructA  :=
    bind_both f_a (fun f_a =>
      ret_both ((f_a) : (t_StructA))) : both (t_StructA).
Fail Next Obligation.
Notation "'Build_t_StructA' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_StructA (f_a := y)).

Definition t_StructB : choice_type :=
  (uint_size × uint_size).
Equations f_a (s : both t_StructB) : both uint_size :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (fst x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_b (s : both t_StructB) : both uint_size :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_StructB {f_a : both uint_size} {f_b : both uint_size} : both (t_StructB) :=
  Build_t_StructB  :=
    bind_both f_b (fun f_b =>
      bind_both f_a (fun f_a =>
        ret_both ((f_a,f_b) : (t_StructB)))) : both (t_StructB).
Fail Next Obligation.
Notation "'Build_t_StructB' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_StructB (f_a := y) (f_b := f_b x)).
Notation "'Build_t_StructB' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_StructB (f_a := f_a x) (f_b := y)).

Definition t_StructC : choice_type :=
  (uint_size).
Equations f_a (s : both t_StructC) : both uint_size :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_StructC {f_a : both uint_size} : both (t_StructC) :=
  Build_t_StructC  :=
    bind_both f_a (fun f_a =>
      ret_both ((f_a) : (t_StructC))) : both (t_StructC).
Fail Next Obligation.
Notation "'Build_t_StructC' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_StructC (f_a := y)).

Definition t_StructD : choice_type :=
  (uint_size × uint_size).
Equations f_a (s : both t_StructD) : both uint_size :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (fst x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_b (s : both t_StructD) : both uint_size :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_StructD {f_a : both uint_size} {f_b : both uint_size} : both (t_StructD) :=
  Build_t_StructD  :=
    bind_both f_b (fun f_b =>
      bind_both f_a (fun f_a =>
        ret_both ((f_a,f_b) : (t_StructD)))) : both (t_StructD).
Fail Next Obligation.
Notation "'Build_t_StructD' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_StructD (f_a := y) (f_b := f_b x)).
Notation "'Build_t_StructD' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_StructD (f_a := f_a x) (f_b := y)).

Equations construct_structs (a : both uint_size) (b : both uint_size) : both 'unit :=
  construct_structs a b  :=
    letb _ := Build_t_StructA (f_a := a) in
    letb _ := Build_t_StructB (f_a := a) (f_b := b) in
    letb _ := Build_t_StructC (f_a := a) in
    letb _ := Build_t_StructD (f_a := a) (f_b := b) in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations v_INHERENT_CONSTANT : both uint_size :=
  v_INHERENT_CONSTANT  :=
    ret_both (3 : uint_size) : both uint_size.
Fail Next Obligation.

Class t_FooTrait (Self : choice_type) (v_Self : v_Self) := {
  f_ASSOCIATED_CONSTANT : (both uint_size) ;
}.

Equations constants {v_T : v_T} `{ t_FooTrait v_T} (_ : both 'unit) : both uint_size :=
  constants _  :=
    f_ASSOCIATED_CONSTANT .+ v_INHERENT_CONSTANT : both uint_size.
Fail Next Obligation.

Equations string_shadows (string : both chString) (n : both chString) : both 'unit :=
  string_shadows string n  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations items_under_closures (_ : both 'unit) : both 'unit :=
  items_under_closures _  :=
    letb (_ : 'unit) := fun _ =>
      ret_both (tt : 'unit) in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations items_under_closures__anon_const_0__nested_function (_ : both 'unit) : both 'unit :=
  items_under_closures__anon_const_0__nested_function _  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Definition items_under_closures__anon_const_0__t_NestedStruct : choice_type :=
  'unit.
Equations Build_items_under_closures__anon_const_0__t_NestedStruct : both (items_under_closures__anon_const_0__t_NestedStruct) :=
  Build_items_under_closures__anon_const_0__t_NestedStruct  :=
    ret_both (tt (* Empty tuple *) : (items_under_closures__anon_const_0__t_NestedStruct)) : both (items_under_closures__anon_const_0__t_NestedStruct).
Fail Next Obligation.

Equations items_under_closures__nested_function (_ : both 'unit) : both 'unit :=
  items_under_closures__nested_function _  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Definition items_under_closures__t_NestedStruct : choice_type :=
  'unit.
Equations Build_items_under_closures__t_NestedStruct : both (items_under_closures__t_NestedStruct) :=
  Build_items_under_closures__t_NestedStruct  :=
    ret_both (tt (* Empty tuple *) : (items_under_closures__t_NestedStruct)) : both (items_under_closures__t_NestedStruct).
Fail Next Obligation.
