(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_MyFrom (Self : choice_type) (v_Self : v_Self) {v_T : v_T} := {
  f_my_from : (both v_T -> both v_Self) ;
}.

#[global] Program Instance int16_t_MyFrom : t_MyFrom int16 int8 :=
  let f_my_from := fun  (x : both int8) => cast_int (WS2 := _) x : both int16 in
  {| f_my_from := (@f_my_from)|}.
Fail Next Obligation.
Hint Unfold int16_t_MyFrom.

Equations f (x : both int8) : both (t_Result int16 int16) :=
  f x  :=
    run (letm[choice_typeMonad.result_bind_code (t_Result int16 int16)] _ := matchb f_branch (Result_Err (ret_both (1 : int8))) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      ControlFlow_Break (f_from_residual residual)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Never)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (Result_Ok (f_my_from x))) : both (t_Result int16 int16).
Fail Next Obligation.
