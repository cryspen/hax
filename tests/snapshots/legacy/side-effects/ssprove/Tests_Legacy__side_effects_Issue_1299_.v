(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_Foo : choice_type :=
  (int8).
Equations f_y (s : both t_Foo) : both int8 :=
  f_y s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Foo {f_y : both int8} : both (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_y (fun f_y =>
      ret_both ((f_y) : (t_Foo))) : both (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_y' ':=' y ')'" := (Build_t_Foo (f_y := y)).

Definition t_S : choice_type :=
  (t_Foo).
Equations f_g (s : both t_S) : both t_Foo :=
  f_g s  :=
    bind_both s (fun x =>
      ret_both (x : t_Foo)) : both t_Foo.
Fail Next Obligation.
Equations Build_t_S {f_g : both t_Foo} : both (t_S) :=
  Build_t_S  :=
    bind_both f_g (fun f_g =>
      ret_both ((f_g) : (t_S))) : both (t_S).
Fail Next Obligation.
Notation "'Build_t_S' '[' x ']' '(' 'f_g' ':=' y ')'" := (Build_t_S (f_g := y)).

Definition t_OtherS : choice_type :=
  (t_Option t_Foo).
Equations f_g (s : both t_OtherS) : both (t_Option t_Foo) :=
  f_g s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Option t_Foo))) : both (t_Option t_Foo).
Fail Next Obligation.
Equations Build_t_OtherS {f_g : both (t_Option t_Foo)} : both (t_OtherS) :=
  Build_t_OtherS  :=
    bind_both f_g (fun f_g =>
      ret_both ((f_g) : (t_OtherS))) : both (t_OtherS).
Fail Next Obligation.
Notation "'Build_t_OtherS' '[' x ']' '(' 'f_g' ':=' y ')'" := (Build_t_OtherS (f_g := y)).

Equations impl_Foo__from (i : both t_Foo) : both t_Foo :=
  impl_Foo__from i  :=
    Build_t_Foo (f_y := f_clone (f_y i)) : both t_Foo.
Fail Next Obligation.

Definition t_Error : choice_type :=
  'unit.
Equations Build_t_Error : both (t_Error) :=
  Build_t_Error  :=
    ret_both (tt (* Empty tuple *) : (t_Error)) : both (t_Error).
Fail Next Obligation.

Equations impl_S__from (i : both t_OtherS) : both (t_Result t_S t_Error) :=
  impl_S__from i  :=
    run (letm[choice_typeMonad.result_bind_code t_Error] hoist49 := impl__ok_or (impl__as_ref (f_g i)) Error in
    Result_Ok (letb hoist50 := impl_Foo__from hoist49 in
    letb hoist51 := Build_t_S (f_g := hoist50) in
    Result_Ok hoist51)) : both (t_Result t_S t_Error).
Fail Next Obligation.
