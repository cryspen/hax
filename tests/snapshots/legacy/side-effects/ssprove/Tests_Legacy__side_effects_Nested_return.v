(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations other_fun (rng : both int8) : both (int8 × t_Result 'unit 'unit) :=
  other_fun rng  :=
    letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
    prod_b (rng,hax_temp_output) : both (int8 × t_Result 'unit 'unit).
Fail Next Obligation.

Equations fun (rng : both int8) : both (int8 × t_Result 'unit 'unit) :=
  fun rng  :=
    run (letb '(tmp0,out) := other_fun rng in
    letb rng := tmp0 in
    letb hoist41 := out in
    letb hoist42 := f_branch hoist41 in
    letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist43 := matchb hoist42 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible 'unit)) in
      letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist40 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist40)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    letb hoist44 := Result_Ok hoist43 in
    letb hoist45 := prod_b (rng,hoist44) in
    letm[choice_typeMonad.result_bind_code (int8 × t_Result 'unit 'unit)] hoist46 := ControlFlow_Break hoist45 in
    ControlFlow_Continue (letb hax_temp_output := never_to_any hoist46 in
    prod_b (rng,hax_temp_output))) : both (int8 × t_Result 'unit 'unit).
Fail Next Obligation.
