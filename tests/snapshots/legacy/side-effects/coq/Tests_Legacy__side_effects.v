(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Definition add3 (x : t_u32) (y : t_u32) (z : t_u32) : t_u32 :=
  impl_u32__wrapping_add (impl_u32__wrapping_add (x) (y)) (z).

Definition local_mutation (x : t_u32) : t_u32 :=
  let y := (0 : t_u32) in
  let x := impl_u32__wrapping_add (x) ((1 : t_u32)) in
  let hoist1 := f_gt (x) ((3 : t_u32)) in
  if
    hoist1
  then
    let x := impl_u32__wrapping_sub (x) ((3 : t_u32)) in
    let y := f_div (x) ((2 : t_u32)) in
    let y := impl_u32__wrapping_add (y) ((2 : t_u32)) in
    let hoist2 := (0 : t_u32) in
    let hoist3 := Range (hoist2) ((10 : t_u32)) in
    let hoist4 := f_into_iter (hoist3) in
    let y := f_fold (hoist4) (y) (fun y i =>
      impl_u32__wrapping_add (x) (i)) in
    impl_u32__wrapping_add (x) (y)
  else
    let ((x,y),hoist7) := match x with
    | 12 =>
      let y := impl_u32__wrapping_add (x) (y) in
      ((x,y),(3 : t_u32))
    | 13 =>
      let hoist6 := x in
      let x := impl_u32__wrapping_add (x) ((1 : t_u32)) in
      let hoist5 := impl_u32__wrapping_add ((123 : t_u32)) (x) in
      ((x,y),add3 (hoist6) (hoist5) (x))
    | _ =>
      ((x,y),(0 : t_u32))
    end in
    let x := hoist7 in
    impl_u32__wrapping_add (x) (y).

Definition early_returns (x : t_u32) : t_u32 :=
  run (let _ := if
    f_gt (x) ((3 : t_u32))
  then
    let hoist8 := ControlFlow_Break ((0 : t_u32)) in
    ControlFlow_Continue (never_to_any (hoist8))
  else
    ControlFlow_Continue (tt) in
  let hoist9 := f_gt (x) ((30 : t_u32)) in
  let (x,hoist11) := if
    hoist9
  then
    match (true : bool) with
    | true =>
      let hoist10 := ControlFlow_Break ((34 : t_u32)) in
      ControlFlow_Continue ((x,never_to_any (hoist10)))
    | _ =>
      ControlFlow_Continue ((x,(3 : t_u32)))
    end
  else
    ControlFlow_Continue (let x := f_add (x) ((9 : t_u32)) in
    (x,f_add (x) ((1 : t_u32)))) in
  let hoist12 := impl_u32__wrapping_add ((123 : t_u32)) (hoist11) in
  let hoist13 := impl_u32__wrapping_add (hoist12) (x) in
  let hoist14 := ControlFlow_Break (hoist13) in
  ControlFlow_Continue (never_to_any (hoist14))).

Definition simplifiable_return (c1 : bool) (c2 : bool) (c3 : bool) : t_i32 :=
  run (let x := (0 : t_i32) in
  let x := if
    c1
  then
    let x := if
      c2
    then
      let x := f_add (x) ((10 : t_i32)) in
      if
        c3
      then
        let hoist15 := ControlFlow_Break ((1 : t_i32)) in
        ControlFlow_Continue (x)
      else
        ControlFlow_Continue (x)
    else
      ControlFlow_Continue (x) in
    ControlFlow_Continue (let x := f_add (x) ((1 : t_i32)) in
    x)
  else
    ControlFlow_Continue (x) in
  ControlFlow_Continue (x)).

Definition simplifiable_question_mark (c : bool) (x : t_Option ((t_i32))) : t_Option ((t_i32)) :=
  run (let a := if
    c
  then
    let hoist16 := x in
    Option_Some (f_add (hoist16) ((10 : t_i32)))
  else
    Option_Some ((0 : t_i32)) in
  Option_Some (let b := (20 : t_i32) in
  Option_Some (f_add (a) (b)))).

Definition direct_result_question_mark (y : t_Result ((unit)) ((t_u32))) : t_Result ((t_i8)) ((t_u32)) :=
  run (let _ := y in
  Result_Ok (Result_Ok ((0 : t_i8)))).

Definition direct_result_question_mark_coercion (y : t_Result ((t_i8)) ((t_u16))) : t_Result ((t_i8)) ((t_u32)) :=
  run (let hoist17 := impl__map_err (y) (f_from) in
  Result_Ok (Result_Ok (hoist17))).

Definition options (x : t_Option ((t_u8))) (y : t_Option ((t_u8))) (z : t_Option ((t_u64))) : t_Option ((t_u8)) :=
  run (let hoist21 := x in
  let hoist22 := f_gt (hoist21) ((10 : t_u8)) in
  let hoist28 := if
    hoist22
  then
    let hoist23 := x in
    Option_Some (let hoist24 := impl_u8__wrapping_add (hoist23) ((3 : t_u8)) in
    Option_Some (hoist24))
  else
    let hoist26 := x in
    let hoist25 := y in
    Option_Some (let hoist27 := impl_u8__wrapping_add (hoist26) (hoist25) in
    Option_Some (hoist27)) in
  let hoist29 := hoist28 in
  let v := match hoist29 with
  | 3 =>
    Option_None
  | 4 =>
    let hoist18 := z in
    Option_Some (let hoist19 := f_gt (hoist18) ((4 : t_u64)) in
    let hoist20 := if
      hoist19
    then
      (0 : t_u8)
    else
      (3 : t_u8) in
    f_add ((4 : t_u8)) (hoist20))
  | _ =>
    Option_Some ((12 : t_u8))
  end in
  let hoist30 := x in
  let hoist32 := impl_u8__wrapping_add (v) (hoist30) in
  let hoist31 := y in
  Option_Some (let hoist33 := impl_u8__wrapping_add (hoist32) (hoist31) in
  Option_Some (hoist33))).

Definition question_mark (x : t_u32) : t_Result ((t_u32)) ((t_u32)) :=
  run (let x := if
    f_gt (x) ((40 : t_u32))
  then
    let y := (0 : t_u32) in
    let x := impl_u32__wrapping_add (x) ((3 : t_u32)) in
    let y := impl_u32__wrapping_add (x) (y) in
    let x := impl_u32__wrapping_add (x) (y) in
    let hoist34 := f_gt (x) ((90 : t_u32)) in
    if
      hoist34
    then
      let _ := impl__map_err (Result_Err ((12 : t_u8))) (f_from) in
      Result_Ok (x)
    else
      Result_Ok (x)
  else
    Result_Ok (x) in
  Result_Ok (Result_Ok (impl_u32__wrapping_add ((3 : t_u32)) (x)))).

Record A_record : Type :=
  {
  }.

#[export]
Notation "'A_A_record'" := Build_A_record.

Record B_record : Type :=
  {
  }.

#[export]
Notation "'B_B_record'" := Build_B_record.

Definition monad_lifting (x : t_u8) : t_Result ((t_A)) ((t_B)) :=
  run (if
    f_gt (x) ((123 : t_u8))
  then
    let hoist35 := ControlFlow_Continue (Result_Err (B)) in
    let hoist36 := Result_Ok (hoist35) in
    let hoist37 := ControlFlow_Break (hoist36) in
    ControlFlow_Continue (never_to_any (hoist37))
  else
    ControlFlow_Continue (Result_Ok (A))).

Record Bar_record : Type :=
  {
    Bar_f_a : bool;
    Bar_f_b : (t_Array ((bool*bool)) ((6 : t_usize))*bool);
  }.



#[export] Instance settable_Bar_record : Settable _ :=
  settable! (Build_Bar_record) <Bar_f_a; Bar_f_b>.

Record Foo_record : Type :=
  {
    Foo_f_x : bool;
    Foo_f_y : (bool*t_Vec ((t_Bar)) ((t_Global)));
    Foo_f_z : t_Array (t_Bar) ((6 : t_usize));
    Foo_f_bar : t_Bar;
  }.





#[export] Instance settable_Foo_record : Settable _ :=
  settable! (Build_Foo_record) <Foo_f_x; Foo_f_y; Foo_f_z; Foo_f_bar>.

Definition assign_non_trivial_lhs (foo : t_Foo) : t_Foo :=
  let foo := foo <|t_Foof_x := (true : bool) |> in
  let foo := foo <|t_Foof_bar := f_bar foo <|t_Barf_a := (true : bool) |> |> in
  let foo := foo <|t_Foof_bar := f_bar foo <|t_Barf_b := (Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: Construct unexpected constructors


Note: the error was labeled with context `Coq printer generic printer`.
(* ERROR_EXPR *)) |> |> in
  let foo := foo <|t_Foof_z := update_at_usize (f_z foo) ((3 : t_usize)) (f_index (f_z foo) ((3 : t_usize)) <|t_Barf_a := (true : bool) |>) |> in
  let foo := foo <|t_Foof_y := (Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: Construct unexpected constructors


Note: the error was labeled with context `Coq printer generic printer`.
(* ERROR_EXPR *)) |> in
  foo.
