(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations dup {v_T : v_T} `{ t_Clone v_T} (x : both v_T) : both (v_T × v_T) :=
  dup x  :=
    prod_b (f_clone x,f_clone x) : both (v_T × v_T).
Fail Next Obligation.

Equations foo {v_LEN : both uint_size} (arr : both (nseq uint_size (is_pure (v_LEN)))) : both uint_size :=
  foo arr  :=
    letb acc := v_LEN .+ (ret_both (9 : uint_size)) in
    letb acc := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := v_LEN))) (fun i =>
      ssp (fun acc =>
        acc .+ (arr.a[i]) : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations repeat {v_LEN : both uint_size} {v_T : v_T} `{ t_Copy v_T} (x : both v_T) : both (nseq v_T (is_pure (v_LEN))) :=
  repeat x  :=
    repeat x v_LEN : both (nseq v_T (is_pure (v_LEN))).
Fail Next Obligation.

Equations f {v_N : both uint_size} (x : both uint_size) : both uint_size :=
  f x  :=
    (v_N .+ v_N) .+ x : both uint_size.
Fail Next Obligation.

Equations call_f (_ : both 'unit) : both uint_size :=
  call_f _  :=
    (f (ret_both (3 : uint_size))) .+ (ret_both (3 : uint_size)) : both uint_size.
Fail Next Obligation.

Equations g {v_N : both uint_size} {v_T : v_T} `{ t_Into v_T (nseq uint_size (is_pure (v_N)))} (arr : both v_T) : both uint_size :=
  g arr  :=
    (impl__unwrap_or (f_max (f_into_iter (f_into arr))) v_N) .+ v_N : both uint_size.
Fail Next Obligation.

Equations call_g (_ : both 'unit) : both uint_size :=
  call_g _  :=
    (g (array_from_list [ret_both (42 : uint_size);
      ret_both (3 : uint_size);
      ret_both (49 : uint_size)])) .+ (ret_both (3 : uint_size)) : both uint_size.
Fail Next Obligation.

Class t_Foo (Self : choice_type) (v_Self : v_Self) := {
  f_const_add : (both v_Self -> both uint_size) ;
}.

#[global] Program Instance uint_size_t_Foo : t_Foo uint_size :=
  let f_const_add := fun  (self : both uint_size) => self .+ v_N : both uint_size in
  {| f_const_add := (@f_const_add)|}.
Fail Next Obligation.
Hint Unfold uint_size_t_Foo.

Definition t_Bar : choice_type :=
  'unit.
Equations Build_t_Bar : both (t_Bar) :=
  Build_t_Bar  :=
    ret_both (tt (* Empty tuple *) : (t_Bar)) : both (t_Bar).
Fail Next Obligation.

Equations impl_Bar__inherent_impl_generics {v_T : v_T} {v_N : both uint_size} (x : both (nseq v_T (is_pure (v_N)))) : both 'unit :=
  impl_Bar__inherent_impl_generics x  :=
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.
