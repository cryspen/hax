(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_Foo (Self : choice_type) (v_Self : v_Self) {v_T : v_T} := {
}.

Class t_Bar (Self : choice_type) (v_Self : v_Self) := {
}.

Definition t_S : choice_type :=
  'unit.
Equations Build_t_S : both (t_S) :=
  Build_t_S  :=
    ret_both (tt (* Empty tuple *) : (t_S)) : both (t_S).
Fail Next Obligation.

#[global] Program Instance int16_t_Bar : t_Bar int16 :=
  _.
Fail Next Obligation.
Hint Unfold int16_t_Bar.

#[global] Program Instance int32 × v_A_t_Foo {v_A : v_A} : t_Foo (int32 × v_A) int16 :=
  _.
Fail Next Obligation.
Hint Unfold int32 × v_A_t_Foo.

Class t_T1 (Self : choice_type) (v_Self : v_Self) := {
  f_T : choice_type ;
  f_f : (both v_Self -> both f_T -> both f_T) ;
}.

Class t_T3 (Self : choice_type) (v_Self : v_Self) := {
  f_T : choice_type ;
  f_T_t_Bar :> (t_Bar f_T) ;
  f_Tp : choice_type ;
  f_Tp_t_Foo :> (t_Foo f_Tp) ;
  f_f : (both v_Self -> both f_T -> both f_Tp -> both uint_size) ;
}.

#[global] Program Instance t_S_t_T1 : t_T1 t_S :=
  let f_T := int32 : choice_type in
  let f_f := fun  (self : both t_S) (x : both int32) => ret_both (2121 : int32) : both int32 in
  {| f_T := (@f_T);
  f_f := (@f_f)|}.
Fail Next Obligation.
Hint Unfold t_S_t_T1.

Class t_T2 (Self : choice_type) (v_Self : v_Self) := {
  f_T : choice_type ;
  f_T_t_T1 :> (t_T1 f_T) ;
  f_f : (both v_Self -> both f_T -> both uint_size) ;
}.

#[global] Program Instance t_S_t_T2 : t_T2 t_S :=
  let f_T := t_S : choice_type in
  let f_f := fun  (self : both t_S) (x : both t_S) => ret_both (21 : uint_size) : both uint_size in
  {| f_T := (@f_T);
  f_f := (@f_f)|}.
Fail Next Obligation.
Hint Unfold t_S_t_T2.
