(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_T0 : choice_type :=
  'unit.
Equations Build_t_T0 : both (t_T0) :=
  Build_t_T0  :=
    ret_both (tt (* Empty tuple *) : (t_T0)) : both (t_T0).
Fail Next Obligation.

Definition t_T1 {v_A : v_A} : choice_type :=
  (v_A).
Equations 0 {v_A : v_A} (s : both t_T1) : both v_A :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : v_A)) : both v_A.
Fail Next Obligation.
Equations Build_t_T1 {v_A : v_A} {0 : both v_A} : both (t_T1) :=
  Build_t_T1  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_T1))) : both (t_T1).
Fail Next Obligation.
Notation "'Build_t_T1' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_T1 (0 := y)).

Definition t_T2 {v_A : v_A} {v_B : v_B} : choice_type :=
  (v_A × v_B).
Equations 0 {v_A : v_A} {v_B : v_B} (s : both t_T2) : both v_A :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst x : v_A)) : both v_A.
Fail Next Obligation.
Equations 1 {v_A : v_A} {v_B : v_B} (s : both t_T2) : both v_B :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd x : v_B)) : both v_B.
Fail Next Obligation.
Equations Build_t_T2 {v_A : v_A} {v_B : v_B} {0 : both v_A} {1 : both v_B} : both (t_T2) :=
  Build_t_T2  :=
    bind_both 1 (fun 1 =>
      bind_both 0 (fun 0 =>
        ret_both ((0,1) : (t_T2)))) : both (t_T2).
Fail Next Obligation.
Notation "'Build_t_T2' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_T2 (0 := y) (1 := 1 x)).
Notation "'Build_t_T2' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_T2 (0 := 0 x) (1 := y)).

Definition t_T3 {v_A : v_A} {v_B : v_B} {v_C : v_C} : choice_type :=
  (v_A × v_B × v_C).
Equations 0 {v_A : v_A} {v_B : v_B} {v_C : v_C} (s : both t_T3) : both v_A :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : v_A)) : both v_A.
Fail Next Obligation.
Equations 1 {v_A : v_A} {v_B : v_B} {v_C : v_C} (s : both t_T3) : both v_B :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : v_B)) : both v_B.
Fail Next Obligation.
Equations 2 {v_A : v_A} {v_B : v_B} {v_C : v_C} (s : both t_T3) : both v_C :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd x : v_C)) : both v_C.
Fail Next Obligation.
Equations Build_t_T3 {v_A : v_A} {v_B : v_B} {v_C : v_C} {0 : both v_A} {1 : both v_B} {2 : both v_C} : both (t_T3) :=
  Build_t_T3  :=
    bind_both 2 (fun 2 =>
      bind_both 1 (fun 1 =>
        bind_both 0 (fun 0 =>
          ret_both ((0,1,2) : (t_T3))))) : both (t_T3).
Fail Next Obligation.
Notation "'Build_t_T3' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_T3 (0 := y) (1 := 1 x) (2 := 2 x)).
Notation "'Build_t_T3' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_T3 (0 := 0 x) (1 := y) (2 := 2 x)).
Notation "'Build_t_T3' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_T3 (0 := 0 x) (1 := 1 x) (2 := y)).

Definition t_T3p {v_A : v_A} {v_B : v_B} {v_C : v_C} : choice_type :=
  (v_A × t_T2 v_B v_C).
Equations 0 {v_A : v_A} {v_B : v_B} {v_C : v_C} (s : both t_T3p) : both v_A :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst x : v_A)) : both v_A.
Fail Next Obligation.
Equations 1 {v_A : v_A} {v_B : v_B} {v_C : v_C} (s : both t_T3p) : both (t_T2 v_B v_C) :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_T2 v_B v_C))) : both (t_T2 v_B v_C).
Fail Next Obligation.
Equations Build_t_T3p {v_A : v_A} {v_B : v_B} {v_C : v_C} {0 : both v_A} {1 : both (t_T2 v_B v_C)} : both (t_T3p) :=
  Build_t_T3p  :=
    bind_both 1 (fun 1 =>
      bind_both 0 (fun 0 =>
        ret_both ((0,1) : (t_T3p)))) : both (t_T3p).
Fail Next Obligation.
Notation "'Build_t_T3p' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_T3p (0 := y) (1 := 1 x)).
Notation "'Build_t_T3p' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_T3p (0 := 0 x) (1 := y)).

Equations tuple_structs (_ : both 'unit) : both 'unit :=
  tuple_structs _  :=
    letb t0 := T0 in
    letb t1 := T1 (ret_both (1 : int32)) in
    letb t2 := T2 (ret_both (1 : int32)) (ret_both (2 : int32)) in
    letb t3 := T3 T0 (T1 (ret_both (1 : int32))) (T2 (ret_both (1 : int32)) (ret_both (2 : int32))) in
    letb t3p := T3p T0 (T2 (T1 (ret_both (1 : int32))) (T2 (ret_both (1 : int32)) (ret_both (2 : int32)))) in
    letb T0  := t0 in
    letb T1 u1 := t1 in
    letb T2 (u2,u3) := t2 in
    letb T3 (T0 ,T1 _,T2 (_,_)) := t3 in
    letb T3p (T0 ,T2 (T1 _,T2 (_,_))) := t3p in
    letb _ := 0 t1 in
    letb _ := 0 t2 in
    letb _ := 1 t2 in
    letb _ := 0 t3 in
    letb _ := 1 t3 in
    letb _ := 2 t3 in
    letb _ := 1 (2 t3) in
    letb _ := 0 t3p in
    letb _ := 1 t3p in
    letb _ := 0 (1 (1 t3p)) in
    letb _ := 0 (1 t3p) in
    letb _ := 1 (1 t3p) in
    letb _ := matchb t0 with
    | T0  =>
      ret_both (tt : 'unit)
    end in
    letb _ := letb u1 := t1 in
    ret_both (tt : 'unit) in
    letb _ := matchb t2 with
    | T2 (u2,u3) =>
      ret_both (tt : 'unit)
    end in
    letb _ := matchb t3 with
    | T3 (T0 ,T1 u1,T2 (u2,u3)) =>
      ret_both (tt : 'unit)
    end in
    letb _ := matchb t3p with
    | T3p (T0 ,T2 (T1 u1,T2 (u2,u3))) =>
      ret_both (tt : 'unit)
    end in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Definition t_S1 : choice_type :=
  (uint_size × uint_size).
Equations f_f1 (s : both t_S1) : both uint_size :=
  f_f1 s  :=
    bind_both s (fun x =>
      ret_both (fst x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_f2 (s : both t_S1) : both uint_size :=
  f_f2 s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_S1 {f_f1 : both uint_size} {f_f2 : both uint_size} : both (t_S1) :=
  Build_t_S1  :=
    bind_both f_f2 (fun f_f2 =>
      bind_both f_f1 (fun f_f1 =>
        ret_both ((f_f1,f_f2) : (t_S1)))) : both (t_S1).
Fail Next Obligation.
Notation "'Build_t_S1' '[' x ']' '(' 'f_f1' ':=' y ')'" := (Build_t_S1 (f_f1 := y) (f_f2 := f_f2 x)).
Notation "'Build_t_S1' '[' x ']' '(' 'f_f2' ':=' y ')'" := (Build_t_S1 (f_f1 := f_f1 x) (f_f2 := y)).

Definition t_S2 : choice_type :=
  (t_S1 × uint_size).
Equations f_f1 (s : both t_S2) : both t_S1 :=
  f_f1 s  :=
    bind_both s (fun x =>
      ret_both (fst x : t_S1)) : both t_S1.
Fail Next Obligation.
Equations f_f2 (s : both t_S2) : both uint_size :=
  f_f2 s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_S2 {f_f1 : both t_S1} {f_f2 : both uint_size} : both (t_S2) :=
  Build_t_S2  :=
    bind_both f_f2 (fun f_f2 =>
      bind_both f_f1 (fun f_f1 =>
        ret_both ((f_f1,f_f2) : (t_S2)))) : both (t_S2).
Fail Next Obligation.
Notation "'Build_t_S2' '[' x ']' '(' 'f_f1' ':=' y ')'" := (Build_t_S2 (f_f1 := y) (f_f2 := f_f2 x)).
Notation "'Build_t_S2' '[' x ']' '(' 'f_f2' ':=' y ')'" := (Build_t_S2 (f_f1 := f_f1 x) (f_f2 := y)).

Definition t_S3 : choice_type :=
  (uint_size × uint_size × uint_size × uint_size × uint_size).
Equations f_end (s : both t_S3) : both uint_size :=
  f_end s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_def (s : both t_S3) : both uint_size :=
  f_def s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_theorem (s : both t_S3) : both uint_size :=
  f_theorem s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_structure (s : both t_S3) : both uint_size :=
  f_structure s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : uint_size)) : both uint_size.
Fail Next Obligation.
Equations f_inductive (s : both t_S3) : both uint_size :=
  f_inductive s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_S3 {f_end : both uint_size} {f_def : both uint_size} {f_theorem : both uint_size} {f_structure : both uint_size} {f_inductive : both uint_size} : both (t_S3) :=
  Build_t_S3  :=
    bind_both f_inductive (fun f_inductive =>
      bind_both f_structure (fun f_structure =>
        bind_both f_theorem (fun f_theorem =>
          bind_both f_def (fun f_def =>
            bind_both f_end (fun f_end =>
              ret_both ((f_end,f_def,f_theorem,f_structure,f_inductive) : (t_S3))))))) : both (t_S3).
Fail Next Obligation.
Notation "'Build_t_S3' '[' x ']' '(' 'f_end' ':=' y ')'" := (Build_t_S3 (f_end := y) (f_def := f_def x) (f_theorem := f_theorem x) (f_structure := f_structure x) (f_inductive := f_inductive x)).
Notation "'Build_t_S3' '[' x ']' '(' 'f_def' ':=' y ')'" := (Build_t_S3 (f_end := f_end x) (f_def := y) (f_theorem := f_theorem x) (f_structure := f_structure x) (f_inductive := f_inductive x)).
Notation "'Build_t_S3' '[' x ']' '(' 'f_theorem' ':=' y ')'" := (Build_t_S3 (f_end := f_end x) (f_def := f_def x) (f_theorem := y) (f_structure := f_structure x) (f_inductive := f_inductive x)).
Notation "'Build_t_S3' '[' x ']' '(' 'f_structure' ':=' y ')'" := (Build_t_S3 (f_end := f_end x) (f_def := f_def x) (f_theorem := f_theorem x) (f_structure := y) (f_inductive := f_inductive x)).
Notation "'Build_t_S3' '[' x ']' '(' 'f_inductive' ':=' y ')'" := (Build_t_S3 (f_end := f_end x) (f_def := f_def x) (f_theorem := f_theorem x) (f_structure := f_structure x) (f_inductive := y)).

(*item error backend*)
