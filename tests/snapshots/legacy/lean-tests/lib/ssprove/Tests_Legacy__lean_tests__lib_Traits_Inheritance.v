(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_T1 (Self : choice_type) (v_Self : v_Self) := {
  f_f1 : (both v_Self -> both uint_size) ;
}.

Class t_T2 (Self : choice_type) (v_Self : v_Self) := {
  f_f2 : (both v_Self -> both uint_size) ;
}.

Class t_T3 (Self : choice_type) (v_Self : v_Self) `{ t_T2 v_Self} `{ t_T1 v_Self} := {
  f_f3 : (both v_Self -> both uint_size) ;
}.

Class t_Tp1 (Self : choice_type) (v_Self : v_Self) := {
  f_f1 : (both v_Self -> both uint_size) ;
}.

Class t_Tp2 (Self : choice_type) (v_Self : v_Self) `{ t_Tp1 v_Self} `{ t_T3 v_Self} := {
  f_fp2 : (both v_Self -> both uint_size) ;
}.

Definition t_S : choice_type :=
  'unit.
Equations Build_t_S : both (t_S) :=
  Build_t_S  :=
    ret_both (tt (* Empty tuple *) : (t_S)) : both (t_S).
Fail Next Obligation.

#[global] Program Instance t_S_t_T1 : t_T1 t_S :=
  let f_f1 := fun  (self : both t_S) => ret_both (1 : uint_size) : both uint_size in
  {| f_f1 := (@f_f1)|}.
Fail Next Obligation.
Hint Unfold t_S_t_T1.

#[global] Program Instance t_S_t_T2 : t_T2 t_S :=
  let f_f2 := fun  (self : both t_S) => ret_both (2 : uint_size) : both uint_size in
  {| f_f2 := (@f_f2)|}.
Fail Next Obligation.
Hint Unfold t_S_t_T2.

#[global] Program Instance t_S_t_T3 : t_T3 t_S :=
  let f_f3 := fun  (self : both t_S) => ret_both (3 : uint_size) : both uint_size in
  {| f_f3 := (@f_f3)|}.
Fail Next Obligation.
Hint Unfold t_S_t_T3.

#[global] Program Instance t_S_t_Tp1 : t_Tp1 t_S :=
  let f_f1 := fun  (self : both t_S) => ret_both (10 : uint_size) : both uint_size in
  {| f_f1 := (@f_f1)|}.
Fail Next Obligation.
Hint Unfold t_S_t_Tp1.

#[global] Program Instance t_S_t_Tp2 : t_Tp2 t_S :=
  let f_fp2 := fun  (self : both t_S) => (((f_f1 self) .+ (f_f1 self)) .+ (f_f2 self)) .+ (f_f3 self) : both uint_size in
  {| f_fp2 := (@f_fp2)|}.
Fail Next Obligation.
Hint Unfold t_S_t_Tp2.

Equations test (_ : both 'unit) : both uint_size :=
  test _  :=
    letb s := S in
    (f_f3 s) .+ (ret_both (1 : uint_size)) : both uint_size.
Fail Next Obligation.
