(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_T1 (Self : choice_type) (v_Self : v_Self) := {
  f_f1 : (both v_Self -> both uint_size) ;
}.

Class t_T2 (Self : choice_type) (v_Self : v_Self) := {
  f_f2 : (both v_Self -> both uint_size) ;
}.

Class t_Test (Self : choice_type) (v_Self : v_Self) {v_T : v_T} `{ t_T2 v_Self} `{ t_T1 v_T} := {
  f_ff_test : (both v_Self -> both v_T -> both uint_size) ;
}.

Definition t_S1 : choice_type :=
  'unit.
Equations Build_t_S1 : both (t_S1) :=
  Build_t_S1  :=
    ret_both (tt (* Empty tuple *) : (t_S1)) : both (t_S1).
Fail Next Obligation.

#[global] Program Instance t_S1_t_T1 : t_T1 t_S1 :=
  let f_f1 := fun  (self : both t_S1) => ret_both (0 : uint_size) : both uint_size in
  {| f_f1 := (@f_f1)|}.
Fail Next Obligation.
Hint Unfold t_S1_t_T1.

Definition t_S2 : choice_type :=
  'unit.
Equations Build_t_S2 : both (t_S2) :=
  Build_t_S2  :=
    ret_both (tt (* Empty tuple *) : (t_S2)) : both (t_S2).
Fail Next Obligation.

#[global] Program Instance t_S2_t_T2 : t_T2 t_S2 :=
  let f_f2 := fun  (self : both t_S2) => ret_both (1 : uint_size) : both uint_size in
  {| f_f2 := (@f_f2)|}.
Fail Next Obligation.
Hint Unfold t_S2_t_T2.

#[global] Program Instance t_S2_t_Test : t_Test t_S2 t_S1 :=
  let f_ff_test := fun  (self : both t_S2) (x : both t_S1) => ((f_f1 x) .+ (f_f2 self)) .+ (ret_both (1 : uint_size)) : both uint_size in
  {| f_ff_test := (@f_ff_test)|}.
Fail Next Obligation.
Hint Unfold t_S2_t_Test.

Equations test (x1 : both t_S1) (x2 : both t_S2) : both uint_size :=
  test x1 x2  :=
    (f_ff_test x2 x1) .+ (f_f1 x1) : both uint_size.
Fail Next Obligation.
