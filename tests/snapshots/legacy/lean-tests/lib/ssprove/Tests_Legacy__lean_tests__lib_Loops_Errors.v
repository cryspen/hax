(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_Error : choice_type :=
  ('unit ∐ int32).
Notation "'Error_Foo_case'" := (inl tt) (at level 100).
Equations Error_Foo : both t_Error :=
  Error_Foo  :=
    ret_both (inl (tt : 'unit) : t_Error) : both t_Error.
Fail Next Obligation.
Notation "'Error_Bar_case' x" := (inr x) (at level 100).
Equations Error_Bar (x : both int32) : both t_Error :=
  Error_Bar x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_Error)) : both t_Error.
Fail Next Obligation.

Equations loop3 (_ : both 'unit) : both (t_Result int32 t_Error) :=
  loop3 _  :=
    letb x := ret_both (0 : int32) in
    letb x := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun i =>
      ssp (fun x =>
        letm[choice_typeMonad.result_bind_code (t_Result int32 t_Error)] _ := ifb i =.? (ret_both (5 : int32))
        then letm[choice_typeMonad.result_bind_code (t_Result int32 t_Error)] hoist2 := ControlFlow_Break (Result_Err Error_Foo) in
        ControlFlow_Continue (never_to_any hoist2)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        ControlFlow_Continue (x .+ (ret_both (5 : int32))) : (both (t_ControlFlow (t_Result int32 t_Error) int32)))) x in
    Result_Ok x : both (t_Result int32 t_Error).
Fail Next Obligation.

Equations loop4 (_ : both 'unit) : both (t_Result (int32 × int32) t_Error) :=
  loop4 _  :=
    letb e := ret_both (0 : int32) in
    letb f := fun _ =>
      ret_both (42 : int32) in
    letb e := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int32)) (f_end := f_call f (ret_both (tt : 'unit))))) (fun i =>
      ssp (fun e =>
        letm[choice_typeMonad.result_bind_code (t_Result (int32 × int32) t_Error)] _ := ifb i >.? (ret_both (10 : int32))
        then letm[choice_typeMonad.result_bind_code (t_Result (int32 × int32) t_Error)] hoist3 := ControlFlow_Break (Result_Err (Error_Bar e)) in
        ControlFlow_Continue (never_to_any hoist3)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        ControlFlow_Continue (e .+ i) : (both (t_ControlFlow (t_Result (int32 × int32) t_Error) int32)))) e in
    Result_Ok (prod_b (e,e)) : both (t_Result (int32 × int32) t_Error).
Fail Next Obligation.
