(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Record E_V5_record : Type :=
  {
    E_V5_f_f1 : t_usize;
    E_V5_f_f2 : t_usize;
  }.



#[export] Instance settable_E_V5_record : Settable _ :=
  settable! (Build_E_V5_record) <E_V5_f_f1; E_V5_f_f2>.
Record E_V6_record : Type :=
  {
    E_V6_f_f1 : t_usize;
    E_V6_f_f2 : t_usize;
  }.



#[export] Instance settable_E_V6_record : Settable _ :=
  settable! (Build_E_V6_record) <E_V6_f_f1; E_V6_f_f2>.
Inductive t_E : Type :=
| E_V1
| E_V2
| E_V3 : t_usize -> _
| E_V4 : t_usize -> t_usize -> t_usize -> _
| E_V5 : E_V5_record  -> _
| E_V6 : E_V6_record  -> _.







Record MyList_Cons_record (v_T : Type) : Type :=
  {
    MyList_Cons_f_hd : v_T;
    MyList_Cons_f_tl : t_Box ((t_MyList ((v_T)))) ((t_Global));
  }.
Arguments Build_MyList_Cons_record {_}.
Arguments MyList_Cons_f_hd {_}.
Arguments MyList_Cons_f_tl {_}.
#[export] Instance settable_MyList_Cons_record `{v_T : Type} : Settable _ :=
  settable! (Build_MyList_Cons_record (v_T := v_T)) <MyList_Cons_f_hd; MyList_Cons_f_tl>.
Inductive t_MyList (v_T : Type) : Type :=
| MyList_Nil
| MyList_Cons : MyList_Cons_record  v_T -> _.
Arguments MyList_Nil {_}.
Arguments MyList_Cons {_}.

Definition enums '(_ : unit) : unit :=
  let e_v1 := E_V1 in
  let e_v2 := E_V2 in
  let e_v3 := E_V3 ((23 : t_usize)) in
  let e_v4 := E_V4 ((23 : t_usize)) ((12 : t_usize)) ((1 : t_usize)) in
  let e_v5 := E_V5 {| E_V5_f_f1 := ((23 : t_usize)); E_V5_f_f2 := ((43 : t_usize)) |} in
  let e_v6 := E_V6 {| E_V6_f_f1 := ((12 : t_usize)); E_V6_f_f2 := ((13 : t_usize)) |} in
  let nil : t_MyList ((t_usize)) := MyList_Nil in
  let cons_1_ := MyList_Cons {| MyList_Cons_f_hd := ((1 : t_usize)); MyList_Cons_f_tl := (nil) |} in
  let cons_2_1_ := MyList_Cons {| MyList_Cons_f_hd := ((2 : t_usize)); MyList_Cons_f_tl := (cons_1_) |} in
  match e_v1 with
  | E_V1 =>
    tt
  | E_V2 =>
    tt
  | E_V3 (_) =>
    tt
  | E_V4 (x1) (x2) (x3) =>
    let y1 := f_add (x1) (x2) in
    let y2 := f_sub (y1) (x2) in
    let y3 := f_add (y2) (x3) in
    tt
  | E_V5 (f1) (f2) =>
    tt
  | E_V6 (f1) (other_name_for_f2) =>
    tt
  end.
