(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Record T0_record : Type :=
  {
  }.

#[export]
Notation "'T0_T0_record'" := Build_T0_record.

Record T1_record (v_A : Type) : Type :=
  {
    T1_0 : v_A;
  }.
Arguments Build_T1_record {_}.
Arguments T1_0 {_}.
#[export] Instance settable_T1_record `{v_A : Type} : Settable _ :=
  settable! (Build_T1_record (v_A := v_A)) <T1_0>.
Notation "'T1_T1_record'" := Build_T1_record.

Record T2_record (v_A : Type) (v_B : Type) : Type :=
  {
    T2_0 : v_A;
    T2_1 : v_B;
  }.
Arguments Build_T2_record {_} {_}.
Arguments T2_0 {_} {_}.
Arguments T2_1 {_} {_}.
#[export] Instance settable_T2_record `{v_A : Type} `{v_B : Type} : Settable _ :=
  settable! (Build_T2_record (v_A := v_A) (v_B := v_B)) <T2_0; T2_1>.
Notation "'T2_T2_record'" := Build_T2_record.

Record T3_record (v_A : Type) (v_B : Type) (v_C : Type) : Type :=
  {
    T3_0 : v_A;
    T3_1 : v_B;
    T3_2 : v_C;
  }.
Arguments Build_T3_record {_} {_} {_}.
Arguments T3_0 {_} {_} {_}.
Arguments T3_1 {_} {_} {_}.
Arguments T3_2 {_} {_} {_}.
#[export] Instance settable_T3_record `{v_A : Type} `{v_B : Type} `{v_C : Type} : Settable _ :=
  settable! (Build_T3_record (v_A := v_A) (v_B := v_B) (v_C := v_C)) <T3_0; T3_1; T3_2>.
Notation "'T3_T3_record'" := Build_T3_record.

Record T3p_record (v_A : Type) (v_B : Type) (v_C : Type) : Type :=
  {
    T3p_0 : v_A;
    T3p_1 : t_T2 ((v_B)) ((v_C));
  }.
Arguments Build_T3p_record {_} {_} {_}.
Arguments T3p_0 {_} {_} {_}.
Arguments T3p_1 {_} {_} {_}.
#[export] Instance settable_T3p_record `{v_A : Type} `{v_B : Type} `{v_C : Type} : Settable _ :=
  settable! (Build_T3p_record (v_A := v_A) (v_B := v_B) (v_C := v_C)) <T3p_0; T3p_1>.
Notation "'T3p_T3p_record'" := Build_T3p_record.

Definition tuple_structs '(_ : unit) : unit :=
  let t0 := T0 in
  let t1 := T1 ((1 : t_i32)) in
  let t2 := T2 ((1 : t_i32)) ((2 : t_i32)) in
  let t3 := T3 (T0) (T1 ((1 : t_i32))) (T2 ((1 : t_i32)) ((2 : t_i32))) in
  let t3p := T3p (T0) (T2 (T1 ((1 : t_i32))) (T2 ((1 : t_i32)) ((2 : t_i32)))) in
  let {||} := t0 in
  let {|T10 := (u1)|} := t1 in
  let {|T20 := (u2); T21 := (u3)|} := t2 in
  let {|T30 := ({||}); T31 := ({|T10 := (_)|}); T32 := ({|T20 := (_); T21 := (_)|})|} := t3 in
  let {|T3p0 := ({||}); T3p1 := ({|T20 := ({|T10 := (_)|}); T21 := ({|T20 := (_); T21 := (_)|})|})|} := t3p in
  let _ := 0 t1 in
  let _ := 0 t2 in
  let _ := 1 t2 in
  let _ := 0 t3 in
  let _ := 1 t3 in
  let _ := 2 t3 in
  let _ := 1 2 t3 in
  let _ := 0 t3p in
  let _ := 1 t3p in
  let _ := 0 1 1 t3p in
  let _ := 0 1 t3p in
  let _ := 1 1 t3p in
  let _ := match t0 with
  | {||} =>
    tt
  end in
  let _ := match t1 with
  | {|T10 := (u1)|} =>
    tt
  end in
  let _ := match t2 with
  | {|T20 := (u2); T21 := (u3)|} =>
    tt
  end in
  let _ := match t3 with
  | {|T30 := ({||}); T31 := ({|T10 := (u1)|}); T32 := ({|T20 := (u2); T21 := (u3)|})|} =>
    tt
  end in
  let _ := match t3p with
  | {|T3p0 := ({||}); T3p1 := ({|T20 := ({|T10 := (u1)|}); T21 := ({|T20 := (u2); T21 := (u3)|})|})|} =>
    tt
  end in
  tt.

Record S1_record : Type :=
  {
    S1_f_f1 : t_usize;
    S1_f_f2 : t_usize;
  }.



#[export] Instance settable_S1_record : Settable _ :=
  settable! (Build_S1_record) <S1_f_f1; S1_f_f2>.

Record S2_record : Type :=
  {
    S2_f_f1 : t_S1;
    S2_f_f2 : t_usize;
  }.



#[export] Instance settable_S2_record : Settable _ :=
  settable! (Build_S2_record) <S2_f_f1; S2_f_f2>.

Record S3_record : Type :=
  {
    S3_f_end : t_usize;
    S3_f_def : t_usize;
    S3_f_theorem : t_usize;
    S3_f_structure : t_usize;
    S3_f_inductive : t_usize;
  }.






#[export] Instance settable_S3_record : Settable _ :=
  settable! (Build_S3_record) <S3_f_end; S3_f_def; S3_f_theorem; S3_f_structure; S3_f_inductive>.

Definition normal_structs '(_ : unit) : unit :=
  let s1 := S1 ((0 : t_usize)) ((1 : t_usize)) in
  let s2 := S2 (S1 ((2 : t_usize)) ((3 : t_usize))) ((4 : t_usize)) in
  let s3 := S3 ((0 : t_usize)) ((0 : t_usize)) ((0 : t_usize)) ((0 : t_usize)) ((0 : t_usize)) in
  let S1 (f1, f2) := s1 in
  let S1 (f1, other_name_for_f2) := s1 in
  let S2 (S1 (f1, f2), other_name_for_f2) := s2 in
  let S3 (end, def, theorem, structure, inductive) := s3 in
  let _ := (f_f1 s1,f_f2 s1) in
  let _ := (f_f1 s1,f_f2 s1,f_f1 f_f1 s2,f_f2 f_f1 s2,f_f2 s2,f_end s3,f_def s3,f_theorem s3) in
  let _ := match s1 with
  | S1 (f1, f2) =>
    tt
  end in
  let _ := match s2 with
  | S2 (S1 (f1, other_name_for_f2), f2) =>
    tt
  end in
  match s3 with
  | S3 (end, def, theorem, structure, inductive) =>
    tt
  end.
