(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_U : choice_type :=
  ('unit ∐ 'unit ∐ t_Vec t_T t_Global).
Notation "'U_A_case'" := (inl (inl tt)) (at level 100).
Equations U_A : both t_U :=
  U_A  :=
    ret_both (inl (inl (tt : 'unit)) : t_U) : both t_U.
Fail Next Obligation.
Notation "'U_B_case'" := (inl (inr tt)) (at level 100).
Equations U_B : both t_U :=
  U_B  :=
    ret_both (inl (inr (tt : 'unit)) : t_U) : both t_U.
Fail Next Obligation.
Notation "'U_C_case' x" := (inr x) (at level 100).
Equations U_C (x : both (t_Vec t_T t_Global)) : both t_U :=
  U_C x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_U)) : both t_U.
Fail Next Obligation.

Definition t_T__from__enums_b : choice_type :=
  ('unit ∐ 'unit ∐ t_Vec t_T t_Global).
Notation "'T_A_case'" := (inl (inl tt)) (at level 100).
Equations T_A : both t_T__from__enums_b :=
  T_A  :=
    ret_both (inl (inl (tt : 'unit)) : t_T__from__enums_b) : both t_T__from__enums_b.
Fail Next Obligation.
Notation "'T_B_case'" := (inl (inr tt)) (at level 100).
Equations T_B : both t_T__from__enums_b :=
  T_B  :=
    ret_both (inl (inr (tt : 'unit)) : t_T__from__enums_b) : both t_T__from__enums_b.
Fail Next Obligation.
Notation "'T_C_case' x" := (inr x) (at level 100).
Equations T_C (x : both (t_Vec t_T t_Global)) : both t_T__from__enums_b :=
  T_C x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_T__from__enums_b)) : both t_T__from__enums_b.
Fail Next Obligation.

Definition t_T : choice_type :=
  ('unit ∐ 'unit ∐ t_Vec t_U t_Global ∐ t_Vec t_T__from__enums_b t_Global).
Notation "'T_A__from__enums_a_case'" := (inl (inl (inl tt))) (at level 100).
Equations T_A__from__enums_a : both t_T :=
  T_A__from__enums_a  :=
    ret_both (inl (inl (inl (tt : 'unit))) : t_T) : both t_T.
Fail Next Obligation.
Notation "'T_B__from__enums_a_case'" := (inl (inl (inr tt))) (at level 100).
Equations T_B__from__enums_a : both t_T :=
  T_B__from__enums_a  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_T) : both t_T.
Fail Next Obligation.
Notation "'T_C__from__enums_a_case' x" := (inl (inr x)) (at level 100).
Equations T_C__from__enums_a (x : both (t_Vec t_U t_Global)) : both t_T :=
  T_C__from__enums_a x  :=
    bind_both x (fun x =>
      ret_both (inl (inr x) : t_T)) : both t_T.
Fail Next Obligation.
Notation "'T_D_case' x" := (inr x) (at level 100).
Equations T_D (x : both (t_Vec t_T__from__enums_b t_Global)) : both t_T :=
  T_D x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_T)) : both t_T.
Fail Next Obligation.

Equations f (_ : both 'unit) : both t_T__from__enums_b :=
  f _  :=
    T_A : both t_T__from__enums_b.
Fail Next Obligation.
