(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_E : choice_type :=
  ('unit ∐ 'unit).
Notation "'E_A_case'" := (inl tt) (at level 100).
Equations E_A : both t_E :=
  E_A  :=
    ret_both (inl (tt : 'unit) : t_E) : both t_E.
Fail Next Obligation.
Notation "'E_B_case'" := (inr tt) (at level 100).
Equations E_B : both t_E :=
  E_B  :=
    ret_both (inr (tt : 'unit) : t_E) : both t_E.
Fail Next Obligation.

Equations t_E_cast_to_repr (x : both t_E) : both uint_size :=
  t_E_cast_to_repr x  :=
    matchb x with
    | E_A_case  =>
      ret_both (0 : uint_size)
    | E_B_case  =>
      ret_both (1 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Equations bar (x : both t_E) : both 'unit :=
  bar x  :=
    matchb x with
    | E_A  | E_B  =>
      ret_both (tt : 'unit)
    end : both 'unit.
Fail Next Obligation.

Equations nested (x : both (t_Option int32)) : both int32 :=
  nested x  :=
    matchb x with
    | Option_Some_case 1 | 2 =>
      letb '(1,2) := ret_both (((1,2)) : (int32)) in
      ret_both (1 : int32)
    | Option_Some_case x =>
      letb x := ret_both ((x) : (int32)) in
      x
    | Option_None_case  =>
      ret_both (0 : int32)
    end : both int32.
Fail Next Obligation.

Equations deep (x : both (int32 × t_Option int32)) : both int32 :=
  deep x  :=
    matchb x with
    | '(1 | 2,Option_Some 3 | 4) =>
      ret_both (0 : int32)
    | '(x,_) =>
      x
    end : both int32.
Fail Next Obligation.

Equations equivalent (x : both (int32 × t_Option int32)) : both int32 :=
  equivalent x  :=
    matchb x with
    | '(1,Option_Some 3) | '(1,Option_Some 4) | '(2,Option_Some 3) | '(2,Option_Some 4) =>
      ret_both (0 : int32)
    | '(x,_) =>
      x
    end : both int32.
Fail Next Obligation.

Equations deep_capture (x : both (t_Result (int32 × int32) (int32 × int32))) : both int32 :=
  deep_capture x  :=
    matchb x with
    | Result_Ok (1 | 2,x) | Result_Err (3 | 4,x) =>
      x
    | Result_Ok (x,_) | Result_Err (x,_) =>
      x
    end : both int32.
Fail Next Obligation.
