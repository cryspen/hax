(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_Printable (Self : choice_type) (v_Self : v_Self) {v_S : v_S} := {
  f_stringify : (both v_Self -> both v_S) ;
}.

#[global] Program Instance int32_t_Printable : t_Printable int32 t_String :=
  let f_stringify := fun  (self : both int32) => f_to_string self : both t_String in
  {| f_stringify := (@f_stringify)|}.
Fail Next Obligation.
Hint Unfold int32_t_Printable.

(*ExplicitRejection { reason: "a node of kind [Dyn] have been found in the AST" }


Note: the error was labeled with context `reject_Dyn`.

Last available AST for this item:

/// @fail(extraction): coq(HAX0008), ssprove(HAX0008)
/// @fail(extraction): proverif(HAX0008)
#[allow(dead_code)]
#[allow(dead_code)]
#[feature(register_tool, if_let_guard)]
#[feature(
    coverage_attribute,
    stmt_expr_attributes,
    custom_inner_attributes,
    test,
    yield_expr,
    coroutines,
    coroutine_trait,
    no_core,
    core_intrinsics
)]
#[register_tool(_hax)]
fn print(
    a: alloc::boxed::t_Box<
        dyn (tests::legacy__dyn::t_Printable<alloc::string::t_String>),
        alloc::alloc::t_Global,
    >,
) -> tuple0 {
    {
        let args: [core::fmt::rt::t_Argument; 1] = {
            [
                core::fmt::rt::impl__new_display::<
                    alloc::string::t_String,
                >(tests::legacy__dyn::f_stringify(a)),
            ]
        };
        {
            let _: tuple0 = {
                std::io::stdio::e_print(
                    core::fmt::rt::impl_1__new_v1::<
                        generic_value!(todo),
                        generic_value!(todo),
                    >(["", "\n"], args),
                )
            };
            {
                let _: tuple0 = { Tuple0 };
                Tuple0
            }
        }
    }
}
 todo(item)*)
