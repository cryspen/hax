(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Record S_record : Type :=
  {
    S_f_b : t_Array (t_u8) ((5 : t_usize));
  }.


#[export] Instance settable_S_record : Settable _ :=
  settable! (Build_S_record) <S_f_b>.

Definition foo (lhs : t_S) (rhs : t_S) : t_S :=
  let lhs := fold_range ((0 : t_usize)) ((1 : t_usize)) (fun lhs _ =>
    (true : bool)) (lhs) (fun lhs i =>
    lhs <|t_Sf_b := update_at_usize (f_b lhs) (i) (f_add (f_index (f_b lhs) (i)) (f_index (f_b rhs) (i))) |>) in
  lhs.

Definition impl_S__update (self : t_S) (x : t_u8) : t_S :=
  let self := self <|t_Sf_b := update_at_usize (f_b self) ((0 : t_usize)) (x) |> in
  self.

Definition index_mutation (x : t_Range ((t_usize))) (a : t_Slice t_u8) : unit :=
  let v := impl__into_vec (unsize (box_new ([(1 : t_u8)]))) in
  let v := update_at_range (v) (x) (impl__copy_from_slice (f_index (v) (x)) (a)) in
  let v := update_at_usize (v) ((1 : t_usize)) ((3 : t_u8)) in
  tt.

Definition index_mutation_unsize (x : t_Array (t_u8) ((12 : t_usize))) : t_u8 :=
  let x := update_at_range (x) (Range ((4 : t_usize)) ((5 : t_usize))) (impl__copy_from_slice (f_index (x) (Range ((4 : t_usize)) ((5 : t_usize)))) (unsize ([(1 : t_u8); (2 : t_u8)]))) in
  (42 : t_u8).

Definition build_vec '(_ : unit) : t_Vec ((t_u8)) ((t_Global)) :=
  impl__into_vec (unsize (box_new ([(1 : t_u8); (2 : t_u8); (3 : t_u8)]))).

Definition test_append '(_ : unit) : t_Vec ((t_u8)) ((t_Global)) :=
  let vec1 := impl__new (tt) in
  let vec2 := impl__into_vec (unsize (box_new ([(1 : t_u8); (2 : t_u8); (3 : t_u8)]))) in
  let (tmp0,tmp1) := impl_1__append (vec1) (vec2) in
  let vec1 := tmp0 in
  let vec2 := tmp1 in
  let _ := tt in
  let vec1 := impl_1__append (vec1) (build_vec (tt)) in
  vec1.

Definition f '(_ : unit) : t_Vec ((t_u8)) ((t_Global)) :=
  let vec := impl__new (tt) in
  let vec := impl_1__push (vec) ((1 : t_u8)) in
  let vec := impl_1__push (vec) ((2 : t_u8)) in
  let vec := impl__swap (vec) ((0 : t_usize)) ((1 : t_usize)) in
  let vec := impl__swap (vec) ((0 : t_usize)) ((1 : t_usize)) in
  vec.



Record Foo_record : Type :=
  {
    Foo_f_field : t_Vec ((t_u8)) ((t_Global));
  }.


#[export] Instance settable_Foo_record : Settable _ :=
  settable! (Build_Foo_record) <Foo_f_field>.

Record Pair_record (v_T : Type) : Type :=
  {
    Pair_f_a : v_T;
    Pair_f_b : t_Foo;
  }.
Arguments Build_Pair_record {_}.
Arguments Pair_f_a {_}.
Arguments Pair_f_b {_}.
#[export] Instance settable_Pair_record `{v_T : Type} : Settable _ :=
  settable! (Build_Pair_record (v_T := v_T)) <Pair_f_a; Pair_f_b>.

Definition g (x : t_Pair ((t_Vec ((t_u8)) ((t_Global))))) : t_Vec ((t_u8)) ((t_Global)) :=
  let x := x in
  let x := fold_range ((1 : t_u8)) ((10 : t_u8)) (fun x _ =>
    (true : bool)) (x) (fun x i =>
    x <|t_Pairf_a := impl_1__push (f_a x) (i) |>) in
  let x := x <|t_Pairf_a := impl__swap (f_a x) ((0 : t_usize)) ((1 : t_usize)) |> in
  let x := x <|t_Pairf_b := f_b x <|t_Foof_field := impl__swap (f_field f_b x) ((0 : t_usize)) ((1 : t_usize)) |> |> in
  f_a x.

Definition h (x : t_u8) : t_u8 :=
  let x := f_add (x) ((10 : t_u8)) in
  x.

Record Bar_record : Type :=
  {
    Bar_f_a : t_u8;
    Bar_f_b : t_u8;
  }.



#[export] Instance settable_Bar_record : Settable _ :=
  settable! (Build_Bar_record) <Bar_f_a; Bar_f_b>.

Definition i (bar : t_Bar) : (t_Bar*t_u8) :=
  let bar := bar <|t_Barf_b := f_add (f_b bar) (f_a bar) |> in
  let bar := bar <|t_Barf_a := h (f_a bar) |> in
  let hax_temp_output := f_add (f_a bar) (f_b bar) in
  (bar,hax_temp_output).

Definition j (x : t_Bar) : (t_Bar*t_u8) :=
  let out := (123 : t_u8) in
  let (tmp0,out1) := i (x) in
  let x := tmp0 in
  let hoist1 := out1 in
  let hax_temp_output := f_add (hoist1) (out) in
  (x,hax_temp_output).

Definition k (vec : t_Vec ((t_u8)) ((t_Global))) (arg_1_wild3 : t_u16) (arg_1_wild : t_u8) (arg_3_wild2 : unit) : (t_Vec ((t_u8)) ((t_Global))*t_u16*unit*t_u64) :=
  let arg_1_wild2 := f_index (vec) ((1 : t_usize)) in
  let arg_3_wild := f_index (vec) ((2 : t_usize)) in
  let arg_1_wild1 := f_index (vec) ((3 : t_usize)) in
  let arg_3_wild1 := f_index (vec) ((4 : t_usize)) in
  let vec := update_at_usize (vec) ((0 : t_usize)) (f_add (f_add (f_add (f_add (arg_1_wild) (arg_3_wild)) (arg_1_wild1)) (arg_3_wild1)) (arg_1_wild)) in
  let hax_temp_output := (12345 : t_u64) in
  (vec,arg_1_wild3,arg_3_wild2,hax_temp_output).

Class t_FooTrait (v_Self : Type) : Type :=
  {
    f_z : v_Self -> v_Self;
  }.
Arguments t_FooTrait (_).

Instance t_FooTrait_83490567 : t_FooTrait ((t_Foo)) :=
  {
    implaabbcc_t_FooTrait_f_z := fun  (self : t_Foo)=>
      self;
  }.

Definition array (x : t_Array (t_u8) ((10 : t_usize))) : t_Array (t_u8) ((10 : t_usize)) :=
  let x := update_at_usize (x) ((1 : t_usize)) (f_index (x) ((2 : t_usize))) in
  x.
