(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_S : choice_type :=
  (nseq int8 5).
Equations f_b (s : both t_S) : both (nseq int8 5) :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (x : (nseq int8 5))) : both (nseq int8 5).
Fail Next Obligation.
Equations Build_t_S {f_b : both (nseq int8 5)} : both (t_S) :=
  Build_t_S  :=
    bind_both f_b (fun f_b =>
      ret_both ((f_b) : (t_S))) : both (t_S).
Fail Next Obligation.
Notation "'Build_t_S' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_S (f_b := y)).

Equations foo (lhs : both t_S) (rhs : both t_S) : both t_S :=
  foo lhs rhs  :=
    letb lhs := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (1 : uint_size)))) (fun i =>
      ssp (fun lhs =>
        Build_t_S[lhs] (f_b := update_at_usize (f_b lhs) i (((f_b lhs).a[i]) .+ ((f_b rhs).a[i]))) : (both t_S))) lhs in
    lhs : both t_S.
Fail Next Obligation.

Equations impl_S__update (self : both t_S) (x : both int8) : both t_S :=
  impl_S__update self x  :=
    letb self := Build_t_S[self] (f_b := update_at_usize (f_b self) (ret_both (0 : uint_size)) x) in
    self : both t_S.
Fail Next Obligation.

Equations index_mutation (x : both (t_Range uint_size)) (a : both (seq int8)) : both 'unit :=
  index_mutation x a  :=
    letb v := impl__into_vec (unsize (box_new (array_from_list [ret_both (1 : int8)]))) in
    letb v := update_at_range v x (impl__copy_from_slice (v.a[x]) a) in
    letb v := update_at_usize v (ret_both (1 : uint_size)) (ret_both (3 : int8)) in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations index_mutation_unsize (x : both (nseq int8 12)) : both int8 :=
  index_mutation_unsize x  :=
    letb x := update_at_range x (Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := ret_both (5 : uint_size))) (impl__copy_from_slice (x.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := ret_both (5 : uint_size)))]) (unsize (array_from_list [ret_both (1 : int8);
      ret_both (2 : int8)]))) in
    ret_both (42 : int8) : both int8.
Fail Next Obligation.

Equations build_vec (_ : both 'unit) : both (t_Vec int8 t_Global) :=
  build_vec _  :=
    impl__into_vec (unsize (box_new (array_from_list [ret_both (1 : int8);
      ret_both (2 : int8);
      ret_both (3 : int8)]))) : both (t_Vec int8 t_Global).
Fail Next Obligation.

Equations test_append (_ : both 'unit) : both (t_Vec int8 t_Global) :=
  test_append _  :=
    letb vec1 := impl__new in
    letb vec2 := impl__into_vec (unsize (box_new (array_from_list [ret_both (1 : int8);
      ret_both (2 : int8);
      ret_both (3 : int8)]))) in
    letb '(tmp0,tmp1) := impl_1__append vec1 vec2 in
    letb vec1 := tmp0 in
    letb vec2 := tmp1 in
    letb _ := ret_both (tt : 'unit) in
    letb vec1 := impl_1__append vec1 build_vec in
    vec1 : both (t_Vec int8 t_Global).
Fail Next Obligation.

Equations f (_ : both 'unit) : both (t_Vec int8 t_Global) :=
  f _  :=
    letb vec := impl__new in
    letb vec := impl_1__push vec (ret_both (1 : int8)) in
    letb vec := impl_1__push vec (ret_both (2 : int8)) in
    letb vec := impl__swap vec (ret_both (0 : uint_size)) (ret_both (1 : uint_size)) in
    letb vec := impl__swap vec (ret_both (0 : uint_size)) (ret_both (1 : uint_size)) in
    vec : both (t_Vec int8 t_Global).
Fail Next Obligation.

Definition t_Foo : choice_type :=
  (t_Vec int8 t_Global).
Equations f_field (s : both t_Foo) : both (t_Vec int8 t_Global) :=
  f_field s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_Foo {f_field : both (t_Vec int8 t_Global)} : both (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_field (fun f_field =>
      ret_both ((f_field) : (t_Foo))) : both (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_field' ':=' y ')'" := (Build_t_Foo (f_field := y)).

Definition t_Pair {v_T : v_T} : choice_type :=
  (v_T × t_Foo).
Equations f_a {v_T : v_T} (s : both t_Pair) : both v_T :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (fst x : v_T)) : both v_T.
Fail Next Obligation.
Equations f_b {v_T : v_T} (s : both t_Pair) : both t_Foo :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Foo)) : both t_Foo.
Fail Next Obligation.
Equations Build_t_Pair {v_T : v_T} {f_a : both v_T} {f_b : both t_Foo} : both (t_Pair) :=
  Build_t_Pair  :=
    bind_both f_b (fun f_b =>
      bind_both f_a (fun f_a =>
        ret_both ((f_a,f_b) : (t_Pair)))) : both (t_Pair).
Fail Next Obligation.
Notation "'Build_t_Pair' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_Pair (f_a := y) (f_b := f_b x)).
Notation "'Build_t_Pair' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_Pair (f_a := f_a x) (f_b := y)).

Equations g (x : both (t_Pair (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global) :=
  g x  :=
    letb x := x in
    letb x := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int8)) (f_end := ret_both (10 : int8)))) (fun i =>
      ssp (fun x =>
        Build_t_Pair[x] (f_a := impl_1__push (f_a x) i) : (both (t_Pair (t_Vec int8 t_Global))))) x in
    letb x := Build_t_Pair[x] (f_a := impl__swap (f_a x) (ret_both (0 : uint_size)) (ret_both (1 : uint_size))) in
    letb x := Build_t_Pair[x] (f_b := Build_t_Foo[f_b x] (f_field := impl__swap (f_field (f_b x)) (ret_both (0 : uint_size)) (ret_both (1 : uint_size)))) in
    f_a x : both (t_Vec int8 t_Global).
Fail Next Obligation.

Equations h (x : both int8) : both int8 :=
  h x  :=
    letb x := x .+ (ret_both (10 : int8)) in
    x : both int8.
Fail Next Obligation.

Definition t_Bar : choice_type :=
  (int8 × int8).
Equations f_a (s : both t_Bar) : both int8 :=
  f_a s  :=
    bind_both s (fun x =>
      ret_both (fst x : int8)) : both int8.
Fail Next Obligation.
Equations f_b (s : both t_Bar) : both int8 :=
  f_b s  :=
    bind_both s (fun x =>
      ret_both (snd x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Bar {f_a : both int8} {f_b : both int8} : both (t_Bar) :=
  Build_t_Bar  :=
    bind_both f_b (fun f_b =>
      bind_both f_a (fun f_a =>
        ret_both ((f_a,f_b) : (t_Bar)))) : both (t_Bar).
Fail Next Obligation.
Notation "'Build_t_Bar' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_Bar (f_a := y) (f_b := f_b x)).
Notation "'Build_t_Bar' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_Bar (f_a := f_a x) (f_b := y)).

Equations i (bar : both t_Bar) : both (t_Bar × int8) :=
  i bar  :=
    letb bar := Build_t_Bar[bar] (f_b := (f_b bar) .+ (f_a bar)) in
    letb bar := Build_t_Bar[bar] (f_a := h (f_a bar)) in
    letb hax_temp_output := (f_a bar) .+ (f_b bar) in
    prod_b (bar,hax_temp_output) : both (t_Bar × int8).
Fail Next Obligation.

Equations j (x : both t_Bar) : both (t_Bar × int8) :=
  j x  :=
    letb out := ret_both (123 : int8) in
    letb '(tmp0,out1) := i x in
    letb x := tmp0 in
    letb hoist1 := out1 in
    letb hax_temp_output := hoist1 .+ out in
    prod_b (x,hax_temp_output) : both (t_Bar × int8).
Fail Next Obligation.

Equations k (vec : both (t_Vec int8 t_Global)) (arg_1_wild3 : both int16) (arg_1_wild : both int8) (arg_3_wild2 : both 'unit) : both (t_Vec int8 t_Global × int16 × 'unit × int64) :=
  k vec arg_1_wild3 arg_1_wild arg_3_wild2  :=
    letb arg_1_wild2 := vec.a[(ret_both (1 : uint_size))] in
    letb arg_3_wild := vec.a[(ret_both (2 : uint_size))] in
    letb arg_1_wild1 := vec.a[(ret_both (3 : uint_size))] in
    letb arg_3_wild1 := vec.a[(ret_both (4 : uint_size))] in
    letb vec := update_at_usize vec (ret_both (0 : uint_size)) ((((arg_1_wild .+ arg_3_wild) .+ arg_1_wild1) .+ arg_3_wild1) .+ arg_1_wild) in
    letb hax_temp_output := ret_both (12345 : int64) in
    prod_b (vec,arg_1_wild3,arg_3_wild2,hax_temp_output) : both (t_Vec int8 t_Global × int16 × 'unit × int64).
Fail Next Obligation.

Class t_FooTrait (Self : choice_type) (v_Self : v_Self) := {
  f_z : (both v_Self -> both v_Self) ;
}.

#[global] Program Instance t_Foo_t_FooTrait : t_FooTrait t_Foo :=
  let f_z := fun  (self : both t_Foo) => self : both t_Foo in
  {| f_z := (@f_z)|}.
Fail Next Obligation.
Hint Unfold t_Foo_t_FooTrait.

Equations array (x : both (nseq int8 10)) : both (nseq int8 10) :=
  array x  :=
    letb x := update_at_usize x (ret_both (1 : uint_size)) (x.a[(ret_both (2 : uint_size))]) in
    x : both (nseq int8 10).
Fail Next Obligation.
