(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_Type {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} : choice_type :=
  (nseq v_TypeArg (is_pure (v_ConstArg))).
Equations f_field {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} (s : both t_Type) : both (nseq v_TypeArg (is_pure (v_ConstArg))) :=
  f_field s  :=
    bind_both s (fun x =>
      ret_both (x : (nseq v_TypeArg (is_pure (v_ConstArg))))) : both (nseq v_TypeArg (is_pure (v_ConstArg))).
Fail Next Obligation.
Equations Build_t_Type {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} {f_field : both (nseq v_TypeArg (is_pure (v_ConstArg)))} : both (t_Type) :=
  Build_t_Type  :=
    bind_both f_field (fun f_field =>
      ret_both ((f_field) : (t_Type))) : both (t_Type).
Fail Next Obligation.
Notation "'Build_t_Type' '[' x ']' '(' 'f_field' ':=' y ')'" := (Build_t_Type (f_field := y)).

Class t_Trait (Self : choice_type) (v_Self : v_Self) {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} := {
  f_method : (both v_Self -> both v_TypeArg -> both (t_Type v_TypeArg (both uint_size)) -> both 'unit) ;
  f_associated_function : (both v_Self -> both v_TypeArg -> both (t_Type v_TypeArg (both uint_size)) -> both 'unit) ;
}.

#[global] Program Instance 'unit_t_Trait {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} : t_Trait 'unit v_TypeArg (both uint_size) :=
  let f_method := fun  (self : both 'unit) (value_TypeArg : both v_TypeArg) (value_Type : both (t_Type v_TypeArg (both uint_size))) => ret_both (tt : 'unit) : both 'unit in
  let f_associated_function := fun  (e_self : both 'unit) (value_TypeArg : both v_TypeArg) (value_Type : both (t_Type v_TypeArg (both uint_size))) => ret_both (tt : 'unit) : both 'unit in
  {| f_method := (@f_method);
  f_associated_function := (@f_associated_function)|}.
Fail Next Obligation.
Hint Unfold 'unit_t_Trait.

Equations method_caller {v_MethodTypeArg : v_MethodTypeArg} {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} {v_MethodConstArg : both uint_size} {v_ImplTrait : v_ImplTrait} `{ t_Trait v_ImplTrait v_TypeArg (both uint_size)} (x : both v_ImplTrait) (value_TypeArg : both v_TypeArg) (value_Type : both (t_Type v_TypeArg (both uint_size))) : both 'unit :=
  method_caller x value_TypeArg value_Type  :=
    letb _ := f_method x value_TypeArg value_Type in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Equations associated_function_caller {v_MethodTypeArg : v_MethodTypeArg} {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} {v_MethodConstArg : both uint_size} {v_ImplTrait : v_ImplTrait} `{ t_Trait v_ImplTrait v_TypeArg (both uint_size)} (x : both v_ImplTrait) (value_TypeArg : both v_TypeArg) (value_Type : both (t_Type v_TypeArg (both uint_size))) : both 'unit :=
  associated_function_caller x value_TypeArg value_Type  :=
    letb _ := f_associated_function x value_TypeArg value_Type in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Class t_SubTrait (Self : choice_type) (v_Self : v_Self) {v_TypeArg : v_TypeArg} {v_ConstArg : both uint_size} `{ t_Trait v_Self v_TypeArg (both uint_size)} := {
  f_AssocType : choice_type ;
  f_AssocType_t_Trait :> (t_Trait f_AssocType) ;
}.
