(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Class t_SuperTrait (Self : choice_type) (v_Self : v_Self) `{ t_Clone v_Self} := {
  f_function_of_super_trait : (both v_Self -> both int32) ;
}.

#[global] Program Instance int32_t_SuperTrait : t_SuperTrait int32 :=
  let f_function_of_super_trait := fun  (self : both int32) => cast_int (WS2 := _) (impl_i32__abs self) : both int32 in
  {| f_function_of_super_trait := (@f_function_of_super_trait)|}.
Fail Next Obligation.
Hint Unfold int32_t_SuperTrait.

Definition t_Struct : choice_type :=
  'unit.
Equations Build_t_Struct : both (t_Struct) :=
  Build_t_Struct  :=
    ret_both (tt (* Empty tuple *) : (t_Struct)) : both (t_Struct).
Fail Next Obligation.

Class t_Bar (Self : choice_type) (v_Self : v_Self) := {
  f_bar : (both v_Self -> both 'unit) ;
}.

Equations impl_2__method {v_T : v_T} `{ t_Bar v_T} (x : both v_T) : both 'unit :=
  impl_2__method x  :=
    f_bar x : both 'unit.
Fail Next Obligation.

Equations cclosure_iimpl_expr {v_I : v_I} `{ t_Iterator v_I} (it : both v_I) : both (t_Vec 'unit t_Global) :=
  cclosure_iimpl_expr it  :=
    f_collect (f_map it (fun x =>
      x)) : both (t_Vec 'unit t_Global).
Fail Next Obligation.

Equations cclosure_iimpl_expr_fngen {v_I : v_I} {v_F : v_F} `{ t_Iterator v_I} `{ t_FnMut v_F 'unit} (it : both v_I) (f : both v_F) : both (t_Vec 'unit t_Global) :=
  cclosure_iimpl_expr_fngen it f  :=
    f_collect (f_map it f) : both (t_Vec 'unit t_Global).
Fail Next Obligation.

Definition t_Error : choice_type :=
  ('unit).
Notation "'Error_Fail_case'" := tt (at level 100).
Equations Error_Fail : both t_Error :=
  Error_Fail  :=
    ret_both (tt : 'unit : t_Error) : both t_Error.
Fail Next Obligation.

Equations t_Error_cast_to_repr (x : both t_Error) : both uint_size :=
  t_Error_cast_to_repr x  :=
    matchb x with
    | Error_Fail_case  =>
      ret_both (0 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Equations impl_Error__for_application_callback (_ : both 'unit) : both t_Error :=
  impl_Error__for_application_callback _  :=
    fun _ =>
      Error_Fail : both t_Error.
Fail Next Obligation.

Equations iter_option {v_T : v_T} (x : both (t_Option v_T)) : both (t_IntoIter v_T) :=
  iter_option x  :=
    f_into_iter (impl__as_ref x) : both (t_IntoIter v_T).
Fail Next Obligation.

Equations uuse_iimpl_trait (_ : both 'unit) : both 'unit :=
  uuse_iimpl_trait _  :=
    letb iter := iter_option (Option_Some (ret_both (false : 'bool))) in
    letb '(tmp0,out) := f_next iter in
    letb iter := tmp0 in
    letb _ := out in
    ret_both (tt : 'unit) : both 'unit.
Fail Next Obligation.

Class t_Foo (Self : choice_type) (v_Self : v_Self) := {
  f_AssocType : choice_type ;
  f_AssocType_t_SuperTrait :> (t_SuperTrait f_AssocType) ;
  f_N : (both uint_size) ;
  f_assoc_f : (both 'unit) ;
  f_method_f : (both v_Self -> both 'unit) ;
  f_assoc_type : (both f_AssocType -> both 'unit) ;
}.

Class t_Lang (Self : choice_type) (v_Self : v_Self) := {
  f_Var : choice_type ;
  f_s : (both v_Self -> both int32 -> both (v_Self Ã— f_Var)) ;
}.

Equations f {v_T : v_T} `{ t_Foo v_T} (x : both v_T) : both 'unit :=
  f x  :=
    letb _ := f_assoc_f in
    f_method_f x : both 'unit.
Fail Next Obligation.

Equations g {v_T : v_T} `{ t_Foo v_T} (x : both f_AssocType) : both int32 :=
  g x  :=
    f_function_of_super_trait x : both int32.
Fail Next Obligation.

#[global] Program Instance 'unit_t_Foo : t_Foo 'unit :=
  let f_AssocType := int32 : choice_type in
  let f_N := ret_both (32 : uint_size) : both uint_size in
  let f_assoc_f := fun  (_ : both 'unit) => ret_both (tt : 'unit) : both 'unit in
  let f_method_f := fun  (self : both 'unit) => f_assoc_f : both 'unit in
  let f_assoc_type := fun  (_ : both int32) => ret_both (tt : 'unit) : both 'unit in
  {| f_AssocType := (@f_AssocType);
  f_N := (@f_N);
  f_assoc_f := (@f_assoc_f);
  f_method_f := (@f_method_f);
  f_assoc_type := (@f_assoc_type)|}.
Fail Next Obligation.
Hint Unfold 'unit_t_Foo.
