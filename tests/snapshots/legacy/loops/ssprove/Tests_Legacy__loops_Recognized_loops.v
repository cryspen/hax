(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations range (_ : both 'unit) : both (int64 × 'unit) :=
  range _  :=
    letb count := ret_both (0 : int64) in
    prod_b (foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int8)) (f_end := ret_both (10 : int8)))) (fun i =>
        ssp (fun count =>
          letb _ := e_internal_loop_invariant (fun i =>
            i <=.? (ret_both (10 : int8))) in
          letb count := count .+ (ret_both (1 : int64)) in
          count : (both int64))) count,ret_both (tt : 'unit)) : both (int64 × 'unit).
Fail Next Obligation.

Equations range_step_by (_ : both 'unit) : both (int64 × 'unit) :=
  range_step_by _  :=
    letb count := ret_both (0 : int64) in
    prod_b (foldi_both_list (f_into_iter (f_step_by (Build_t_Range (f_start := ret_both (0 : int8)) (f_end := ret_both (10 : int8))) (ret_both (2 : uint_size)))) (fun i =>
        ssp (fun count =>
          letb _ := e_internal_loop_invariant (fun i =>
            i <=.? (ret_both (10 : int8))) in
          letb count := count .+ (ret_both (1 : int64)) in
          count : (both int64))) count,ret_both (tt : 'unit)) : both (int64 × 'unit).
Fail Next Obligation.

Equations enumerated_slice {v_T : v_T} (slice : both (seq v_T)) : both (int64 × 'unit) :=
  enumerated_slice slice  :=
    letb count := ret_both (0 : int64) in
    prod_b (foldi_both_list (f_into_iter (f_enumerate (f_into_iter slice))) (fun i =>
        ssp (fun count =>
          letb _ := e_internal_loop_invariant (fun i =>
            i <=.? (ret_both (10 : uint_size))) in
          letb count := count .+ (ret_both (2 : int64)) in
          count : (both int64))) count,ret_both (tt : 'unit)) : both (int64 × 'unit).
Fail Next Obligation.

Equations enumerated_chunked_slice {v_T : v_T} (slice : both (seq v_T)) : both (int64 × 'unit) :=
  enumerated_chunked_slice slice  :=
    letb count := ret_both (0 : int64) in
    prod_b (foldi_both_list (f_into_iter (f_enumerate (impl__chunks_exact slice (ret_both (3 : uint_size))))) (fun i =>
        ssp (fun count =>
          letb _ := e_internal_loop_invariant (fun i =>
            impl_Prop__from_bool (ret_both (true : 'bool))) in
          letb count := count .+ (ret_both (3 : int64)) in
          count : (both int64))) count,ret_both (tt : 'unit)) : both (int64 × 'unit).
Fail Next Obligation.
