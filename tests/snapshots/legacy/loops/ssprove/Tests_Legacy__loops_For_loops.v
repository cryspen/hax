(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations range1 (_ : both 'unit) : both uint_size :=
  range1 _  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (15 : uint_size)))) (fun i =>
      ssp (fun acc =>
        acc .+ i : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations range2 (n : both uint_size) : both uint_size :=
  range2 n  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n .+ (ret_both (10 : uint_size))))) (fun i =>
      ssp (fun acc =>
        (acc .+ i) .+ (ret_both (1 : uint_size)) : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations composed_range (n : both uint_size) : both uint_size :=
  composed_range n  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (f_chain (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n)) (Build_t_Range (f_start := n .+ (ret_both (10 : uint_size))) (f_end := n .+ (ret_both (50 : uint_size)))))) (fun i =>
      ssp (fun acc =>
        (acc .+ i) .+ (ret_both (1 : uint_size)) : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations rev_range (n : both uint_size) : both uint_size :=
  rev_range n  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (f_rev (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := n)))) (fun i =>
      ssp (fun acc =>
        (acc .+ i) .+ (ret_both (1 : uint_size)) : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations chunks {v_CHUNK_LEN : both uint_size} (arr : both (t_Vec uint_size t_Global)) : both uint_size :=
  chunks arr  :=
    letb acc := ret_both (0 : uint_size) in
    letb chunks := impl__chunks_exact (f_deref arr) v_CHUNK_LEN in
    letb acc := foldi_both_list (f_into_iter (f_clone chunks)) (fun chunk =>
      ssp (fun acc =>
        letb mean := ret_both (0 : uint_size) in
        letb mean := foldi_both_list (f_into_iter chunk) (fun item =>
          ssp (fun mean =>
            mean .+ item : (both uint_size))) mean in
        letb acc := acc .+ (mean ./ v_CHUNK_LEN) in
        acc : (both uint_size))) acc in
    letb acc := foldi_both_list (f_into_iter (impl_88__remainder chunks)) (fun item =>
      ssp (fun acc =>
        acc .- item : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations iterator (arr : both (t_Vec uint_size t_Global)) : both uint_size :=
  iterator arr  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (impl__iter (f_deref arr))) (fun item =>
      ssp (fun acc =>
        acc .+ item : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

(*item error backend*)

Equations pattern (arr : both (t_Vec (uint_size × uint_size) t_Global)) : both uint_size :=
  pattern arr  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter arr) (fun '(x,y) =>
      ssp (fun acc =>
        acc .+ (x .* y) : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations enumerate_chunks (arr : both (t_Vec uint_size t_Global)) : both uint_size :=
  enumerate_chunks arr  :=
    letb acc := ret_both (0 : uint_size) in
    letb acc := foldi_both_list (f_into_iter (f_enumerate (impl__chunks (f_deref arr) (ret_both (4 : uint_size))))) (fun '(i,chunk) =>
      ssp (fun acc =>
        foldi_both_list (f_into_iter (f_enumerate (impl__iter chunk))) (fun '(j,x) =>
          ssp (fun acc =>
            (i .+ j) .+ x : (both uint_size))) acc : (both uint_size))) acc in
    acc : both uint_size.
Fail Next Obligation.

Equations bool_returning (x : both int8) : both 'bool :=
  bool_returning x  :=
    x <.? (ret_both (10 : int8)) : both 'bool.
Fail Next Obligation.

Equations f (_ : both 'unit) : both (int8 × 'unit) :=
  f _  :=
    letb acc := ret_both (0 : int8) in
    prod_b (foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int8)) (f_end := ret_both (10 : int8)))) (fun i =>
        ssp (fun acc =>
          letb acc := acc .+ i in
          letb _ := bool_returning i in
          acc : (both int8))) acc,ret_both (tt : 'unit)) : both (int8 × 'unit).
Fail Next Obligation.
