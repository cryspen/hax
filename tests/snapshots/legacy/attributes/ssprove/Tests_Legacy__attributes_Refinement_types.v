(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Definition t_BoundedU8 {v_MIN : both int8} {v_MAX : both int8} : choice_type :=
  (int8).
Equations 0 {v_MIN : both int8} {v_MAX : both int8} (s : both t_BoundedU8) : both int8 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_BoundedU8 {v_MIN : both int8} {v_MAX : both int8} {0 : both int8} : both (t_BoundedU8) :=
  Build_t_BoundedU8  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_BoundedU8))) : both (t_BoundedU8).
Fail Next Obligation.
Notation "'Build_t_BoundedU8' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_BoundedU8 (0 := y)).

Equations bounded_u8 (x : both (t_BoundedU8 (both int8) (both int8))) (y : both (t_BoundedU8 (both int8) (both int8))) : both (t_BoundedU8 (both int8) (both int8)) :=
  bounded_u8 x y  :=
    f_new ((f_get x) .+ (f_get y)) : both (t_BoundedU8 (both int8) (both int8)).
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Definition t_Even : choice_type :=
  (int8).
Equations 0 (s : both t_Even) : both int8 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Even {0 : both int8} : both (t_Even) :=
  Build_t_Even  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_Even))) : both (t_Even).
Fail Next Obligation.
Notation "'Build_t_Even' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_Even (0 := y)).

Equations double (x : both int8) : both t_Even :=
  double x  :=
    f_new (x .+ x) : both t_Even.
Fail Next Obligation.

Equations double_refine (x : both int8) : both t_Even :=
  double_refine x  :=
    f_into_checked (x .+ x) : both t_Even.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Definition t_NoE : choice_type :=
  (t_String).
Equations 0 (s : both t_NoE) : both t_String :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : t_String)) : both t_String.
Fail Next Obligation.
Equations Build_t_NoE {0 : both t_String} : both (t_NoE) :=
  Build_t_NoE  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_NoE))) : both (t_NoE).
Fail Next Obligation.
Notation "'Build_t_NoE' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_NoE (0 := y)).

(*Not implemented yet? todo(item)*)

Definition t_ModInverse {v_MOD : both int32} : choice_type :=
  (int32).
Equations 0 {v_MOD : both int32} (s : both t_ModInverse) : both int32 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int32)) : both int32.
Fail Next Obligation.
Equations Build_t_ModInverse {v_MOD : both int32} {0 : both int32} : both (t_ModInverse) :=
  Build_t_ModInverse  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_ModInverse))) : both (t_ModInverse).
Fail Next Obligation.
Notation "'Build_t_ModInverse' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ModInverse (0 := y)).

(*Not implemented yet? todo(item)*)

Definition t_FieldElement : choice_type :=
  (int16).
Equations 0 (s : both t_FieldElement) : both int16 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int16)) : both int16.
Fail Next Obligation.
Equations Build_t_FieldElement {0 : both int16} : both (t_FieldElement) :=
  Build_t_FieldElement  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_FieldElement))) : both (t_FieldElement).
Fail Next Obligation.
Notation "'Build_t_FieldElement' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_FieldElement (0 := y)).

(*Not implemented yet? todo(item)*)

Definition t_CompressionFactor : choice_type :=
  (int8).
Equations 0 (s : both t_CompressionFactor) : both int8 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_CompressionFactor {0 : both int8} : both (t_CompressionFactor) :=
  Build_t_CompressionFactor  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_CompressionFactor))) : both (t_CompressionFactor).
Fail Next Obligation.
Notation "'Build_t_CompressionFactor' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_CompressionFactor (0 := y)).

(*Not implemented yet? todo(item)*)

Definition t_BoundedAbsI16 {v_B : both uint_size} : choice_type :=
  (int16).
Equations 0 {v_B : both uint_size} (s : both t_BoundedAbsI16) : both int16 :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : int16)) : both int16.
Fail Next Obligation.
Equations Build_t_BoundedAbsI16 {v_B : both uint_size} {0 : both int16} : both (t_BoundedAbsI16) :=
  Build_t_BoundedAbsI16  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_BoundedAbsI16))) : both (t_BoundedAbsI16).
Fail Next Obligation.
Notation "'Build_t_BoundedAbsI16' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_BoundedAbsI16 (0 := y)).

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_Clone {v_B : both uint_size} : t_Clone (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_Clone.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_Copy {v_B : both uint_size} : t_Copy (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_Copy.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_StructuralPartialEq {v_B : both uint_size} : t_StructuralPartialEq (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_StructuralPartialEq.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_PartialEq {v_B : both uint_size} : t_PartialEq (t_BoundedAbsI16 (both uint_size)) (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_PartialEq.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_Eq {v_B : both uint_size} : t_Eq (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_Eq.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_PartialOrd {v_B : both uint_size} : t_PartialOrd (t_BoundedAbsI16 (both uint_size)) (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_PartialOrd.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_Ord {v_B : both uint_size} : t_Ord (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_Ord.

#[global] Program Instance t_BoundedAbsI16 (both uint_size)_t_Hash {v_B : both uint_size} : t_Hash (t_BoundedAbsI16 (both uint_size)) :=
  _.
Fail Next Obligation.
Hint Unfold t_BoundedAbsI16 (both uint_size)_t_Hash.

Equations double_abs_i16 {v_N : both uint_size} {v_M : both uint_size} (x : both (t_BoundedAbsI16 (both uint_size))) : both (t_BoundedAbsI16 (both uint_size)) :=
  double_abs_i16 x  :=
    f_into_checked (x .* (ret_both (2 : int16))) : both (t_BoundedAbsI16 (both uint_size)).
Fail Next Obligation.
