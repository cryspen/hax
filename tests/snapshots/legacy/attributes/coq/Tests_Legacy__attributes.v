(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)



Definition u32_max : t_u32 :=
  (90000 : t_u32).

Definition add3 (x : t_u32) (y : t_u32) (z : t_u32) `{andb (andb (andb (f_gt (x) ((10 : t_u32))) (f_gt (y) ((10 : t_u32)))) (f_gt (z) ((10 : t_u32)))) (f_lt (f_add (f_add (x) (y)) (z)) (u32_max)) = true} : t_u32 :=
  f_add (f_add (x) (y)) (z).
Lemma add3_ensures (x : t_u32) (y : t_u32) (z : t_u32) :
  forall (H_requires : andb (andb (andb (f_gt (x) ((10 : t_u32))) (f_gt (y) ((10 : t_u32)))) (f_gt (z) ((10 : t_u32)))) (f_lt (f_add (f_add (x) (y)) (z)) (u32_max)) = true),
  let result := @add3 (x : t_u32)(y : t_u32)(z : t_u32) H_requires in
  implies ((true : bool)) (f_gt (result) ((32 : t_u32))) = true.
Proof. Admitted.

Definition swap_and_mut_req_ens (x : t_u32) (y : t_u32) `{andb (f_lt (x) ((40 : t_u32))) (f_lt (y) ((300 : t_u32))) = true} : (t_u32*t_u32*t_u32) :=
  let x0 := x in
  let x := y in
  let y := x0 in
  let hax_temp_output := f_add (x) (y) in
  (x,y,hax_temp_output).
Lemma swap_and_mut_req_ens_ensures (x : t_u32) (y : t_u32) :
  forall (H_requires : andb (f_lt (x) ((40 : t_u32))) (f_lt (y) ((300 : t_u32))) = true),
  let (x_future,y_future,result) := @swap_and_mut_req_ens (x : t_u32)(y : t_u32) H_requires in
  andb (andb (f_eq (x_future) (y)) (f_eq (y_future) (x))) (f_eq (result) (f_add (x) (y))) = true.
Proof. Admitted.

Definition issue_844_ (e_x : t_u8) : t_u8 :=
  e_x.
Lemma issue_844__ensures (e_x : t_u8) :
  let e_x_future := @issue_844_ (e_x : t_u8) in
  (true : bool) = true.
Proof. Admitted.

Lemma add3_lemma (x : t_u32) :
   ->
  orb (orb (f_le (x) ((10 : t_u32))) (f_ge (x) (f_div (u32_max) ((3 : t_u32))))) (f_eq (add3 (x) (x) (x)) (f_mul (x) ((3 : t_u32)))) = true.
Proof. Admitted.

Definition dummy_function (x : t_u32) : t_u32 :=
  x.

Lemma apply_dummy_function_lemma (x : t_u32) :
   ->
  f_eq (x) (dummy_function (x)) = true.
Proof. Admitted.

Record Foo_record : Type :=
  {
    Foo_f_x : t_u32;
    Foo_f_y : t_u32;
    Foo_f_z : t_u32;
  }.




#[export] Instance settable_Foo_record : Settable _ :=
  settable! (Build_Foo_record) <Foo_f_x; Foo_f_y; Foo_f_z>.

Definition props '(_ : unit) : unit :=
  let _ := assume (f_from (impl_Prop__from_bool ((true : bool)))) in
  let _ := assert_prop (f_from (impl_Prop__from_bool ((true : bool)))) in
  let _ := tt in
  tt.

(Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: Could not find item with UID (Attr_payloads.UId.T.UId "60808009685b4aadac5fb6c66bd1f258")


Note: the error was labeled with context `Coq backend`.
(* ERROR_ITEM *))
Definition inlined_code__v_V : t_u8 :=
  (12 : t_u8).

(Fatal error: something we considered as impossible occurred! Please report this by submitting an issue on GitHub!
Details: Could not find item with UID (Attr_payloads.UId.T.UId "48a642dcd2764b249710a0c9863c1b8d")


Note: the error was labeled with context `Coq backend`.
(* ERROR_ITEM *))
Fixpoint fib (x : t_usize) : t_usize :=
  if
    f_le (x) ((2 : t_usize))
  then
    x
  else
    impl_usize__wrapping_add (fib (f_sub (x) ((1 : t_usize)))) (fib (f_sub (x) ((2 : t_usize)))).
