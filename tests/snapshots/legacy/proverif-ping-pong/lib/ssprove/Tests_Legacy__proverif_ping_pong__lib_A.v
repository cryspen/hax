(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_A0 : choice_type :=
  (int8).
Equations f_data (s : both t_A0) : both int8 :=
  f_data s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_A0 {f_data : both int8} : both (t_A0) :=
  Build_t_A0  :=
    bind_both f_data (fun f_data =>
      ret_both ((f_data) : (t_A0))) : both (t_A0).
Fail Next Obligation.
Notation "'Build_t_A0' '[' x ']' '(' 'f_data' ':=' y ')'" := (Build_t_A0 (f_data := y)).

Definition t_A1 : choice_type :=
  'unit.
Equations Build_t_A1 : both (t_A1) :=
  Build_t_A1  :=
    ret_both (tt (* Empty tuple *) : (t_A1)) : both (t_A1).
Fail Next Obligation.

Definition t_A2 : choice_type :=
  (int8).
Equations f_received (s : both t_A2) : both int8 :=
  f_received s  :=
    bind_both s (fun x =>
      ret_both (x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_A2 {f_received : both int8} : both (t_A2) :=
  Build_t_A2  :=
    bind_both f_received (fun f_received =>
      ret_both ((f_received) : (t_A2))) : both (t_A2).
Fail Next Obligation.
Notation "'Build_t_A2' '[' x ']' '(' 'f_received' ':=' y ')'" := (Build_t_A2 (f_received := y)).

Equations init_a (prologue : both (t_Vec int8 t_Global)) : both (t_Result t_A0 t_ProtocolError) :=
  init_a prologue  :=
    ifb (impl_1__len prologue) <.? (ret_both (1 : uint_size))
    then Result_Err ProtocolError_InvalidPrologue
    else Result_Ok (Build_t_A0 (f_data := prologue.a[(ret_both (0 : uint_size))])) : both (t_Result t_A0 t_ProtocolError).
Fail Next Obligation.

Equations write_ping (state : both t_A0) : both (t_Result (t_A1 × t_Message) t_ProtocolError) :=
  write_ping state  :=
    Result_Ok (prod_b (A1,Message_Ping (f_data state))) : both (t_Result (t_A1 × t_Message) t_ProtocolError).
Fail Next Obligation.

Equations read_pong (e_state : both t_A1) (msg : both t_Message) : both (t_Result t_A2 t_ProtocolError) :=
  read_pong e_state msg  :=
    matchb msg with
    | Message_Ping_case _ =>
      letb _ := ret_both (tt (* Empty tuple *) : (int8)) in
      Result_Err ProtocolError_InvalidMessage
    | Message_Pong_case received =>
      letb received := ret_both ((received) : (int8)) in
      Result_Ok (Build_t_A2 (f_received := received))
    end : both (t_Result t_A2 t_ProtocolError).
Fail Next Obligation.
