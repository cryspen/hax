(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Equations double_sum (_ : both 'unit) : both int32 :=
  double_sum _  :=
    letb sum := ret_both (0 : int32) in
    letb sum := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun i =>
      ssp (fun sum =>
        letb _ := ifb i <.? (ret_both (0 : int32))
        then letb hoist7 := failure (ret_both (something is not implemented yet.
TODO: Monad for loop-related control flow

This is discussed in issue https://github.com/hacspec/hax/issues/15.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `CfIntoMonads`.
 : chString)) (ret_both ((break (Tuple0)) : chString)) in
        never_to_any hoist7
        else ret_both (tt : 'unit) in
        letb sum := sum .+ i in
        sum : (both int32))) sum in
    letb sum := sum .* (ret_both (2 : int32)) in
    sum : both int32.
Fail Next Obligation.

Equations double_sum2 (_ : both 'unit) : both int32 :=
  double_sum2 _  :=
    letb sum := ret_both (0 : int32) in
    letb sum2 := ret_both (0 : int32) in
    letb '(sum,sum2) := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun i =>
      ssp (fun '(sum,sum2) =>
        letb _ := ifb i <.? (ret_both (0 : int32))
        then letb hoist8 := failure (ret_both (something is not implemented yet.
TODO: Monad for loop-related control flow

This is discussed in issue https://github.com/hacspec/hax/issues/15.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `CfIntoMonads`.
 : chString)) (ret_both ((break (Tuple0)) : chString)) in
        never_to_any hoist8
        else ret_both (tt : 'unit) in
        letb sum := sum .+ i in
        prod_b (sum,sum2 .+ i) : (both (int32 × int32)))) (prod_b (sum,sum2)) in
    sum .+ sum2 : both int32.
Fail Next Obligation.

Equations double_sum_return (v : both (seq int32)) : both int32 :=
  double_sum_return v  :=
    letb sum := ret_both (0 : int32) in
    letb sum := foldi_both_list (f_into_iter v) (fun i =>
      ssp (fun sum =>
        letm[choice_typeMonad.result_bind_code int32] _ := ifb i <.? (ret_both (0 : int32))
        then letm[choice_typeMonad.result_bind_code int32] hoist9 := ControlFlow_Break (ret_both (0 : int32)) in
        ControlFlow_Continue (never_to_any hoist9)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        ControlFlow_Continue (letb sum := sum .+ i in
        sum) : (both (t_ControlFlow int32 int32)))) sum in
    letb sum := sum .* (ret_both (2 : int32)) in
    sum : both int32.
Fail Next Obligation.

Equations double_sum2_return (v : both (seq int32)) : both int32 :=
  double_sum2_return v  :=
    letb sum := ret_both (0 : int32) in
    letb sum2 := ret_both (0 : int32) in
    letb '(sum,sum2) := foldi_both_list (f_into_iter v) (fun i =>
      ssp (fun '(sum,sum2) =>
        letm[choice_typeMonad.result_bind_code int32] _ := ifb i <.? (ret_both (0 : int32))
        then letm[choice_typeMonad.result_bind_code int32] hoist10 := ControlFlow_Break (ret_both (0 : int32)) in
        ControlFlow_Continue (never_to_any hoist10)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        ControlFlow_Continue (letb sum := sum .+ i in
        prod_b (sum,sum2 .+ i)) : (both (t_ControlFlow int32 (int32 × int32))))) (prod_b (sum,sum2)) in
    sum .+ sum2 : both int32.
Fail Next Obligation.

Equations bigger_power_2_ (x : both int32) : both int32 :=
  bigger_power_2_ x  :=
    letb pow := ret_both (1 : int32) in
    letb pow := other loop todo(term) in
    pow : both int32.
Fail Next Obligation.

Definition t_M : choice_type :=
  (t_Vec int8 t_Global).
Equations f_m (s : both t_M) : both (t_Vec int8 t_Global) :=
  f_m s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_M {f_m : both (t_Vec int8 t_Global)} : both (t_M) :=
  Build_t_M  :=
    bind_both f_m (fun f_m =>
      ret_both ((f_m) : (t_M))) : both (t_M).
Fail Next Obligation.
Notation "'Build_t_M' '[' x ']' '(' 'f_m' ':=' y ')'" := (Build_t_M (f_m := y)).

Equations impl_M__decoded_message (self : both t_M) : both (t_Option (t_Vec int8 t_Global)) :=
  impl_M__decoded_message self  :=
    run (letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl_1__len (f_m self)))) (fun i =>
      ssp (fun _ =>
        ifb i >.? (ret_both (5 : uint_size))
        then letm[choice_typeMonad.result_bind_code (t_Option (t_Vec int8 t_Global))] hoist14 := ControlFlow_Break Option_None in
        ControlFlow_Continue (never_to_any hoist14)
        else ControlFlow_Continue (ret_both (tt : 'unit)) : (both (t_ControlFlow (t_Option (t_Vec int8 t_Global)) 'unit)))) (ret_both (tt : 'unit)) in
    letm[choice_typeMonad.result_bind_code (t_Option (t_Vec int8 t_Global))] hoist15 := ControlFlow_Break (Option_Some (f_clone (f_m self))) in
    ControlFlow_Continue (never_to_any hoist15)) : both (t_Option (t_Vec int8 t_Global)).
Fail Next Obligation.

Equations nested (_ : both 'unit) : both int32 :=
  nested _  :=
    letb sum := ret_both (0 : int32) in
    letb sum := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun i =>
      ssp (fun sum =>
        letb sum := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun j =>
          ssp (fun sum =>
            letb _ := ifb j <.? (ret_both (0 : int32))
            then letb hoist16 := failure (ret_both (something is not implemented yet.
TODO: Monad for loop-related control flow

This is discussed in issue https://github.com/hacspec/hax/issues/15.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `CfIntoMonads`.
 : chString)) (ret_both ((break (Tuple0)) : chString)) in
            never_to_any hoist16
            else ret_both (tt : 'unit) in
            letb sum := sum .+ j in
            sum : (both int32))) sum in
        letb sum := sum .+ i in
        sum : (both int32))) sum in
    letb sum := sum .* (ret_both (2 : int32)) in
    sum : both int32.
Fail Next Obligation.

Equations nested_return (_ : both 'unit) : both int32 :=
  nested_return _  :=
    letb sum := ret_both (0 : int32) in
    letb sum := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun i =>
      ssp (fun sum =>
        letb sum := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (1 : int32)) (f_end := ret_both (10 : int32)))) (fun j =>
          ssp (fun sum =>
            letm[choice_typeMonad.result_bind_code int32] _ := ifb j <.? (ret_both (0 : int32))
            then letm[choice_typeMonad.result_bind_code int32] hoist17 := ControlFlow_Break (ret_both (0 : int32)) in
            ControlFlow_Continue (never_to_any hoist17)
            else ControlFlow_Continue (ret_both (tt : 'unit)) in
            ControlFlow_Continue (letb sum := sum .+ j in
            sum) : (both (t_ControlFlow int32 int32)))) sum in
        letb sum := sum .+ i in
        sum : (both int32))) sum in
    letb sum := sum .* (ret_both (2 : int32)) in
    sum : both int32.
Fail Next Obligation.

Equations continue_only (x : both (seq int32)) : both (int32 × 'unit) :=
  continue_only x  :=
    letb product := ret_both (1 : int32) in
    prod_b (foldi_both_list (f_into_iter x) (fun i =>
        ssp (fun product =>
          letb _ := ifb i =.? (ret_both (0 : int32))
          then never_to_any (failure (ret_both (Explicit rejection by a phase in the Hax engine:
a node of kind [Continue] have been found in the AST

Note: the error was labeled with context `reject_Continue`.
 : chString)) (ret_both (continue; : chString)))
          else ret_both (tt : 'unit) in
          f_mul_assign product i : (both int32))) product,ret_both (tt : 'unit)) : both (int32 × 'unit).
Fail Next Obligation.

Equations continue_and_break (x : both (seq int32)) : both (int32 × 'unit) :=
  continue_and_break x  :=
    letb product := ret_both (1 : int32) in
    prod_b (foldi_both_list (f_into_iter x) (fun i =>
        ssp (fun product =>
          letb _ := ifb i =.? (ret_both (0 : int32))
          then never_to_any (failure (ret_both (Explicit rejection by a phase in the Hax engine:
a node of kind [Continue] have been found in the AST

Note: the error was labeled with context `reject_Continue`.
 : chString)) (ret_both (continue; : chString)))
          else ret_both (tt : 'unit) in
          letb _ := ifb i <.? (ret_both (0 : int32))
          then letb hoist18 := failure (ret_both (something is not implemented yet.
TODO: Monad for loop-related control flow

This is discussed in issue https://github.com/hacspec/hax/issues/15.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `CfIntoMonads`.
 : chString)) (ret_both ((break (Tuple0)) : chString)) in
          never_to_any hoist18
          else ret_both (tt : 'unit) in
          f_mul_assign product i : (both int32))) product,ret_both (tt : 'unit)) : both (int32 × 'unit).
Fail Next Obligation.
