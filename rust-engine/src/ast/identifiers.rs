//! Identifier types used throughout the AST.
//!
//! This module defines:
//! - `GlobalId`: fully-qualified paths like `std::mem::drop`
//! - `LocalId`: local variable identifiers

use crate::symbol::Symbol;
use hax_rust_engine_macros::*;
use std::fmt;

/// The global identifiers of hax.
pub mod global_id {
    use hax_frontend_exporter::{DefKind, DisambiguatedDefPathItem};
    use hax_rust_engine_macros::*;

    /// A Rust `DefId`: a lighter version of [`hax_frontend_exporter::DefId`].
    #[derive_group_for_ast]
    pub struct DefId {
        /// The crate of the definition
        pub krate: String,
        /// The full path for this definition, under the crate `krate`
        pub path: Vec<DisambiguatedDefPathItem>,
        /// The parent `DefId`, if any.
        /// `parent` if node if and only if `path` is empty
        pub parent: Option<Box<DefId>>,
        /// What kind is this definition? (e.g. an `enum`, a `const`, an assoc. `fn`...)
        pub kind: DefKind,
    }

    /// An [`ExpliciDefId`] is a Rust [`DefId`] tagged withg some disambiguation metadata.
    ///
    /// [`DefId`] can be ambiguous, consider the following Rust code:
    ///
    /// ```rust
    /// struct S;
    /// fn f() -> S { S }
    /// ```
    ///
    /// Here, the return type of `f` (that is, `S`) and the constructor `S` in the body of `f` refer to the exact same identifier `mycrate::S`.
    /// Yet, they denote two very different objects: a type versus a constructor.
    ///
    /// [`ExplicitDefId`] clears up this ambiguity, making constructors and types two separate things.
    ///
    /// Also, an [`ExplicitDefId`] always points to an item: an [`ExplicitDefId`] is never pointing to a crate alone.
    #[derive_group_for_ast]
    struct ExplicitDefId {
        /// Is this `DefId` a constructor?
        is_constructor: bool,
        /// The `DefId` itself
        def_id: DefId,
    }

    /// Represents a fresh module: a module generated by hax and guaranteed to be fresh.
    #[derive_group_for_ast]
    struct FreshModule {
        /// Internal (unique) identifier
        id: usize,
        /// Non-empty list of identifiers that will be used to decide the name of the fresh module.
        hints: Vec<ExplicitDefId>,
        /// A decoration label that will be also used to decide the name of the fresh module.
        label: String,
    }

    /// [`ReservedSuffix`] helps at deriving fresh identifiers out of existing (Rust) ones.
    #[derive_group_for_ast]
    enum ReservedSuffix {
        /// Precondition of a function-like item.
        Pre,
        /// Postcondition of a function-like item.
        Post,
        /// Cast function for an `enum` discriminant.
        Cast,
    }

    /// A identifier that we call concrete: it exists concretely somewhere in Rust.
    #[derive_group_for_ast]
    pub struct ConcreteId {
        /// The explicit `def_id`.
        def_id: ExplicitDefId,
        /// A fresh module if this definition was moved to a fresh module.
        moved: Option<FreshModule>,
        /// An optional suffix.
        suffix: Option<ReservedSuffix>,
    }

    /// A concrete identifier or a tuple.
    #[derive_group_for_ast]
    pub enum ConcreteOrTupleId {
        /// An identifier that denotes something related to tuples.
        Tuple(TupleIdentifier),
        /// A concrete identifier that exists in Rust.
        Concrete(ConcreteId),
    }

    /// A identifier that denotes something related to tuples.
    #[derive_group_for_ast]
    pub enum TupleIdentifier {
        /// A tuple type
        Type {
            /// The length of the tuple
            length: usize,
        },
        /// A tuple constructor
        Constructor {
            /// The length of the tuple
            length: usize,
        },
        /// A field of a tuple constructor
        Field {
            /// The length of the tuple
            length: usize,
            /// What field?
            /// Invariant: `nth < length`
            nth: usize,
        },
    }

    /// A global identifier in hax.
    #[derive_group_for_ast]
    pub enum GlobalId {
        /// A concrete identifier that exists in Rust.
        Concrete(ConcreteOrTupleId),
        /// A projector.
        Projector(ConcreteOrTupleId),
    }

    impl ConcreteId {
        /// Extracts the crate name of a concrete identifier
        fn krate(&self) -> String {
            self.def_id.def_id.krate.clone()
        }
        /// Prints a debug string
        fn to_debug_string(&self) -> String {
            self.def_id
                .def_id
                .clone()
                .path
                .into_iter()
                .map(|def| match def.clone().data {
                    hax_frontend_exporter::DefPathItem::ValueNs(s)
                    | hax_frontend_exporter::DefPathItem::MacroNs(s)
                    | hax_frontend_exporter::DefPathItem::TypeNs(s) => s.clone(),
                    hax_frontend_exporter::DefPathItem::Impl => "impl".to_string(),
                    other => unimplemented!("{other:?}"),
                })
                .collect::<Vec<String>>()
                .join("_")
        }
    }

    impl ConcreteOrTupleId {
        /// Extracts a concrete ident out of `&self` if possible
        fn expect_concrete_ident(&self) -> Option<&ConcreteId> {
            match self {
                ConcreteOrTupleId::Tuple(_) => None,
                ConcreteOrTupleId::Concrete(concrete_id) => Some(concrete_id),
            }
        }

        /// Renders a Rust-looking path, for debugging purposes.
        pub fn to_debug_string(&self) -> String {
            match self {
                ConcreteOrTupleId::Tuple(tuple_id) => match tuple_id {
                    TupleIdentifier::Type { length } => format!("tuple{length}"),
                    TupleIdentifier::Constructor { length } => format!("Tuple{length}"),
                    TupleIdentifier::Field { length, nth } => format!("Tuple{length}::{nth}"),
                },
                ConcreteOrTupleId::Concrete(concrete_id) => concrete_id.to_debug_string(),
            }
        }
    }

    impl GlobalId {
        /// Extracts a concrete ident out of `&self` if possible.
        fn expect_concrete_ident(&self) -> Option<&ConcreteId> {
            let (GlobalId::Concrete(inner) | GlobalId::Projector(inner)) = self;
            inner.expect_concrete_ident()
        }

        /// Extracts the name of the crate for an identifier.
        pub fn krate(&self) -> Option<String> {
            Some(self.expect_concrete_ident()?.krate())
        }

        /// Renders a Rust-looking path, for debugging purposes.
        pub fn to_debug_string(&self) -> String {
            match self {
                GlobalId::Concrete(inner) => inner.to_debug_string(),
                GlobalId::Projector(inner) => format!("Projector<{}>", inner.to_debug_string()),
            }
        }

        /// Extract the raw `DefId` from a `GlobalId`.
        /// This should never be used for name printing.
        pub fn def_id(&self) -> Option<DefId> {
            let concrete_id = self.expect_concrete_ident()?;
            Some(concrete_id.def_id.def_id.clone())
        }

        /// Tests if the raw output is reduced to "_". Should be used only for
        /// testing. See https://github.com/cryspen/hax/issues/1599
        pub fn is_empty(&self) -> bool {
            self.to_debug_string() == "_".to_string()
        }
    }

    impl PartialEq<DefId> for GlobalId {
        fn eq(&self, other: &DefId) -> bool {
            if let Self::Concrete(ConcreteOrTupleId::Concrete(concrete)) = self {
                &concrete.def_id.def_id == other
            } else {
                false
            }
        }
    }
    impl PartialEq<GlobalId> for DefId {
        fn eq(&self, other: &GlobalId) -> bool {
            other == self
        }
    }
}
/// Local identifier
#[derive_group_for_ast]
pub struct LocalId(pub Symbol);

impl fmt::Display for LocalId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}
impl From<&hax_frontend_exporter::LocalIdent> for LocalId {
    fn from(value: &hax_frontend_exporter::LocalIdent) -> Self {
        Self(Symbol::new(&value.name))
    }
}
impl From<&str> for LocalId {
    fn from(name: &str) -> Self {
        Self(Symbol::new(name))
    }
}

pub use global_id::GlobalId;
