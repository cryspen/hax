---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: cyclic-modules
    manifest: cyclic-modules/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0

[stdout]
diagnostics = []

[stdout.files]
"cyclic_modules.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false


namespace cyclic_modules.typ_b

inductive T1 : Type
| T1 : T1

end cyclic_modules.typ_b


namespace cyclic_modules.typ_a

inductive T : Type
| T : cyclic_modules.typ_b.T1 -> T

end cyclic_modules.typ_a


namespace cyclic_modules.typ_b

def T1 (x : T1) : RustM isize := do
  match x with | (T1.T1 ) => (pure (0 : isize))

inductive T2 : Type
| T2 : cyclic_modules.typ_a.T -> T2

end cyclic_modules.typ_b


namespace cyclic_modules

def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules


namespace cyclic_modules.b

def g (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.f rust_primitives.hax.Tuple0.mk)

end cyclic_modules.b


namespace cyclic_modules.c

def i (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.c


namespace cyclic_modules

def h (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let _ ← (cyclic_modules.b.g rust_primitives.hax.Tuple0.mk);
  (cyclic_modules.c.i rust_primitives.hax.Tuple0.mk)

def h2 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.c.i rust_primitives.hax.Tuple0.mk)

end cyclic_modules


namespace cyclic_modules.d

def d1 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.d


namespace cyclic_modules.e

def e1 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.d.d1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.e


namespace cyclic_modules.de

def de1 (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.e.e1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.de


namespace cyclic_modules.d

def d2 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.de.de1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.d


namespace cyclic_modules.rec

inductive T : Type
| t1 : T
| t2 : T

def T (x : T) : RustM isize := do
  match x with | (T.t1 ) => (pure (0 : isize)) | (T.t2 ) => (pure (1 : isize))

end cyclic_modules.rec


namespace cyclic_modules.m2

def d (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

def c (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m2


namespace cyclic_modules.m1

def a (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.m2.c rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m1


namespace cyclic_modules.m2

def b (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let _ ← (cyclic_modules.m1.a rust_primitives.hax.Tuple0.mk);
  (d rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m2


namespace cyclic_modules.disjoint_cycle_a

def g (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_a


namespace cyclic_modules.disjoint_cycle_b

def h (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_b


namespace cyclic_modules.disjoint_cycle_a

def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.disjoint_cycle_b.h rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_a


namespace cyclic_modules.disjoint_cycle_b

def i (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.disjoint_cycle_a.g rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_b


namespace cyclic_modules.variant_constructor_a

inductive Context : Type
| A : i32 -> Context
| B : i32 -> Context

def Impl.test (x : (core_models.option.Option i32)) :
    RustM (core_models.option.Option Context) := do
  (core_models.option.Impl.map i32 Context (i32 -> RustM Context) x Context.A)

end cyclic_modules.variant_constructor_a


namespace cyclic_modules.variant_constructor_b

def h (_ : rust_primitives.hax.Tuple0) :
    RustM cyclic_modules.variant_constructor_a.Context := do
  (pure (cyclic_modules.variant_constructor_a.Context.A (1 : i32)))

end cyclic_modules.variant_constructor_b


namespace cyclic_modules.variant_constructor_a

def f (_ : rust_primitives.hax.Tuple0) : RustM Context := do
  (cyclic_modules.variant_constructor_b.h rust_primitives.hax.Tuple0.mk)

end cyclic_modules.variant_constructor_a


namespace cyclic_modules.issue_1823.first_example.a

structure A where
  -- no fields

end cyclic_modules.issue_1823.first_example.a


namespace cyclic_modules.issue_1823.first_example.b

structure B where
  -- no fields

end cyclic_modules.issue_1823.first_example.b


namespace cyclic_modules.issue_1823.first_example.a

def Impl.mkb (self : A) :
    RustM cyclic_modules.issue_1823.first_example.b.B := do
  (pure cyclic_modules.issue_1823.first_example.b.B.mk)

end cyclic_modules.issue_1823.first_example.a


namespace cyclic_modules.issue_1823.first_example.b

def Impl.mka (self : B) :
    RustM cyclic_modules.issue_1823.first_example.a.A := do
  (pure cyclic_modules.issue_1823.first_example.a.A.mk)

end cyclic_modules.issue_1823.first_example.b


namespace cyclic_modules.issue_1823.second_example.a

def a (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.a


namespace cyclic_modules.issue_1823.second_example.b

def call_a (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.issue_1823.second_example.a.a rust_primitives.hax.Tuple0.mk)

def b (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.b


namespace cyclic_modules.issue_1823.second_example.a

def call_b (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.issue_1823.second_example.b.b rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.a


namespace cyclic_modules.typ_b

inductive T2Rec : Type
| T2 : cyclic_modules.typ_a.TRec -> T2Rec

inductive T1Rec : Type
| T1 : T2Rec -> T1Rec

end cyclic_modules.typ_b


namespace cyclic_modules.typ_a

inductive TRec : Type
| T : cyclic_modules.typ_b.T1Rec -> TRec
| Empty : TRec

end cyclic_modules.typ_a


namespace cyclic_modules.rec

def hf (x : T) : RustM T := do
  match x with | (T.t1 ) => (hf T.t2) | (T.t2 ) => (pure x)

end cyclic_modules.rec


namespace cyclic_modules.rec2_same_name

def f (x : i32) : RustM i32 := do
  if (← (rust_primitives.hax.machine_int.gt x (0 : i32))) then
    (cyclic_modules.rec1_same_name.f (← (x -? (1 : i32))))
  else
    (pure (0 : i32))

end cyclic_modules.rec2_same_name


namespace cyclic_modules.rec1_same_name

def f (x : i32) : RustM i32 := do (cyclic_modules.rec2_same_name.f x)

end cyclic_modules.rec1_same_name


namespace cyclic_modules.late_skip_b

def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.late_skip_a.f rust_primitives.hax.Tuple0.mk)

@[spec]
def f.spec (_ : rust_primitives.hax.Tuple0) :
    Spec (requires := do (pure true)) (ensures := fun _ => pure True) (f ⟨⟩) :=
{
  pureRequires := by constructor; mvcgen <;> try grind
  pureEnsures := by constructor; intros; mvcgen <;> try grind
  contract := by mvcgen[f] <;> try grind
}

end cyclic_modules.late_skip_b


namespace cyclic_modules.late_skip_a

def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.late_skip_b.f rust_primitives.hax.Tuple0.mk)

end cyclic_modules.late_skip_a


namespace cyclic_modules.enums_b

inductive U : Type
| A : U
| B : U
| C : (alloc.vec.Vec cyclic_modules.enums_a.T alloc.alloc.Global) -> U

inductive T : Type
| A : T
| B : T
| C : (alloc.vec.Vec cyclic_modules.enums_a.T alloc.alloc.Global) -> T

end cyclic_modules.enums_b


namespace cyclic_modules.enums_a

inductive T : Type
| A : T
| B : T
| C : (alloc.vec.Vec cyclic_modules.enums_b.U alloc.alloc.Global) -> T
| D : (alloc.vec.Vec cyclic_modules.enums_b.T alloc.alloc.Global) -> T

end cyclic_modules.enums_a


namespace cyclic_modules.enums_b

def f (_ : rust_primitives.hax.Tuple0) : RustM T := do (pure T.A)

end cyclic_modules.enums_b


namespace cyclic_modules.rec

def g2 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g1 x) | (T.t2 ) => (hf x)

def g1 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g2 x) | (T.t2 ) => (pure T.t1)

end cyclic_modules.rec

'''
