---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: cyclic-modules
    manifest: cyclic-modules/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 1
[[stdout.diagnostics]]
message = """
Fatal error: something we considered as impossible occurred! \u001B[1mPlease report this by submitting an issue on GitHub!\u001B[0m
Details: An item linked via hax attributes could not be found. The UUID is ItemUid { uid: \"63cb80916a25412ea77972fb7c1386ce\" }. The graph is LinkedItemGraph {
    items: [],
    context: Unknown,
}.

\u001B[90mNote: the error was labeled with context `Unknown`.
\u001B[0m"""
spans = ['Span { lo: Loc { line: 177, col: 4 }, hi: Loc { line: 179, col: 5 }, filename: Real(LocalPath("cyclic-modules/src/lib.rs")), rust_span_data: None }']

[stdout.files]
"Cyclic_modules.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
open Std.Do
set_option mvcgen.warning false
set_option linter.unusedVariables false

namespace Cyclic_modules.M1

def a (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.M2.c Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.M1


namespace Cyclic_modules.Issue_1823.Second_example.B

def call_a
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  (Cyclic_modules.Issue_1823.Second_example.A.a Rust_primitives.Hax.Tuple0.mk)

def b (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Issue_1823.Second_example.B


namespace Cyclic_modules.Disjoint_cycle_a

def g (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Disjoint_cycle_b.h Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_a


namespace Cyclic_modules.De

def de1
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  (Cyclic_modules.E.e1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.De


namespace Cyclic_modules.Variant_constructor_b

def h
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Cyclic_modules.Variant_constructor_a.Context
  := do
  (pure (Cyclic_modules.Variant_constructor_a.Context.A (1 : i32)))

end Cyclic_modules.Variant_constructor_b


namespace Cyclic_modules.Rec1_same_name

def f (x : i32) : RustM i32 := do (Cyclic_modules.Rec2_same_name.f x)

end Cyclic_modules.Rec1_same_name


namespace Cyclic_modules.E

def e1 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.D.d1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.E


namespace Cyclic_modules.Late_skip_b

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Late_skip_a.f Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Late_skip_b


namespace Cyclic_modules.Typ_b

inductive T1 : Type
| T1 : T1

def T1 (x : T1) : RustM isize := do
  match x with | (T1.T1 ) => (pure (0 : isize))

inductive T2 : Type
| T2 : Cyclic_modules.Typ_a.T -> T2

inductive T2Rec : Type
| T2 : Cyclic_modules.Typ_a.TRec -> T2Rec

inductive T1Rec : Type
| T1 : T2Rec -> T1Rec

end Cyclic_modules.Typ_b


namespace Cyclic_modules.B

def g (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.f Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.B


namespace Cyclic_modules.Typ_a

inductive T : Type
| T : Cyclic_modules.Typ_b.T1 -> T

inductive TRec : Type
| T : Cyclic_modules.Typ_b.T1Rec -> TRec
| Empty : TRec

end Cyclic_modules.Typ_a


namespace Cyclic_modules.Late_skip_a

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Late_skip_b.f Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Late_skip_a


namespace Cyclic_modules.Issue_1823.Second_example.A

def a (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def call_b
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  (Cyclic_modules.Issue_1823.Second_example.B.b Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Issue_1823.Second_example.A


namespace Cyclic_modules.Enums_b

inductive U : Type
| A : U
| B : U
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_a.T Alloc.Alloc.Global) -> U

inductive T : Type
| A : T
| B : T
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_a.T Alloc.Alloc.Global) -> T

def f (_ : Rust_primitives.Hax.Tuple0) : RustM T := do (pure T.A)

end Cyclic_modules.Enums_b


namespace Cyclic_modules.Issue_1823.First_example.B

structure B where
  -- no fields

def Impl.mka
  (self : B)
  : RustM Cyclic_modules.Issue_1823.First_example.A.A
  := do
  (pure Cyclic_modules.Issue_1823.First_example.A.A.mk)

end Cyclic_modules.Issue_1823.First_example.B


namespace Cyclic_modules.Rec2_same_name

def f (x : i32) : RustM i32 := do
  if (← (Rust_primitives.Hax.Machine_int.gt x (0 : i32))) then
    (Cyclic_modules.Rec1_same_name.f (← (x -? (1 : i32))))
  else
    (pure (0 : i32))

end Cyclic_modules.Rec2_same_name


namespace Cyclic_modules.D

def d1 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def d2 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.De.de1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.D


namespace Cyclic_modules.C

def i (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.C


namespace Cyclic_modules.Issue_1823.First_example.A

structure A where
  -- no fields

def Impl.mkb
  (self : A)
  : RustM Cyclic_modules.Issue_1823.First_example.B.B
  := do
  (pure Cyclic_modules.Issue_1823.First_example.B.B.mk)

end Cyclic_modules.Issue_1823.First_example.A


namespace Cyclic_modules.Rec

inductive T : Type
| t1 : T
| t2 : T

def T (x : T) : RustM isize := do
  match x with | (T.t1 ) => (pure (0 : isize)) | (T.t2 ) => (pure (1 : isize))

def hf (x : T) : RustM T := do
  match x with | (T.t1 ) => (hf T.t2) | (T.t2 ) => (pure x)

def g2 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g1 x) | (T.t2 ) => (hf x)

def g1 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g2 x) | (T.t2 ) => (pure T.t1)

end Cyclic_modules.Rec


namespace Cyclic_modules.Enums_a

inductive T : Type
| A : T
| B : T
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_b.U Alloc.Alloc.Global) -> T
| D : (Alloc.Vec.Vec Cyclic_modules.Enums_b.T Alloc.Alloc.Global) -> T

end Cyclic_modules.Enums_a


namespace Cyclic_modules.M2

def d (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def c (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def b (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  let _ ← (Cyclic_modules.M1.a Rust_primitives.Hax.Tuple0.mk);
  (d Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.M2


namespace Cyclic_modules.Disjoint_cycle_b

def h (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def i (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Disjoint_cycle_a.g Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_b


namespace Cyclic_modules.Variant_constructor_a

inductive Context : Type
| A : i32 -> Context
| B : i32 -> Context

def Impl.test
  (x : (Core_models.Option.Option i32))
  : RustM (Core_models.Option.Option Context)
  := do
  (Core_models.Option.Impl.map i32 Context (i32 -> RustM Context) x Context.A)

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Context := do
  (Cyclic_modules.Variant_constructor_b.h Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Variant_constructor_a


namespace Cyclic_modules

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def h (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  let _ ← (B.g Rust_primitives.Hax.Tuple0.mk);
  (C.i Rust_primitives.Hax.Tuple0.mk)

def h2 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (C.i Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules

'''
