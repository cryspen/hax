---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: cyclic-modules
    manifest: cyclic-modules/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0

[stdout]
diagnostics = []

[stdout.files]
"cyclic_modules.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false


namespace cyclic_modules.typ_b

inductive T1 : Type
| T1 : T1

end cyclic_modules.typ_b


namespace cyclic_modules.typ_a

inductive T : Type
| T : cyclic_modules.typ_b.T1 -> T

end cyclic_modules.typ_a


namespace cyclic_modules.typ_b

@[spec]
def T1_cast_to_repr (x : T1) : RustM isize := do
  match x with | (T1.T1 ) => (pure (0 : isize))

inductive T2 : Type
| T2 : cyclic_modules.typ_a.T -> T2

end cyclic_modules.typ_b


namespace cyclic_modules

@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules


namespace cyclic_modules.b

@[spec]
def g (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.f rust_primitives.hax.Tuple0.mk)

end cyclic_modules.b


namespace cyclic_modules.c

@[spec]
def i (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.c


namespace cyclic_modules

@[spec]
def h (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let _ ← (cyclic_modules.b.g rust_primitives.hax.Tuple0.mk);
  (cyclic_modules.c.i rust_primitives.hax.Tuple0.mk)

@[spec]
def h2 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.c.i rust_primitives.hax.Tuple0.mk)

end cyclic_modules


namespace cyclic_modules.d

@[spec]
def d1 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.d


namespace cyclic_modules.e

@[spec]
def e1 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.d.d1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.e


namespace cyclic_modules.de

@[spec]
def de1 (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.e.e1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.de


namespace cyclic_modules.d

@[spec]
def d2 (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.de.de1 rust_primitives.hax.Tuple0.mk)

end cyclic_modules.d


namespace cyclic_modules.rec

inductive T : Type
| t1 : T
| t2 : T

@[spec]
def T_cast_to_repr (x : T) : RustM isize := do
  match x with | (T.t1 ) => (pure (0 : isize)) | (T.t2 ) => (pure (1 : isize))

end cyclic_modules.rec


namespace cyclic_modules.m2

@[spec]
def d (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def c (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m2


namespace cyclic_modules.m1

@[spec]
def a (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.m2.c rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m1


namespace cyclic_modules.m2

@[spec]
def b (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let _ ← (cyclic_modules.m1.a rust_primitives.hax.Tuple0.mk);
  (d rust_primitives.hax.Tuple0.mk)

end cyclic_modules.m2


namespace cyclic_modules.disjoint_cycle_a

@[spec]
def g (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_a


namespace cyclic_modules.disjoint_cycle_b

@[spec]
def h (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_b


namespace cyclic_modules.disjoint_cycle_a

@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.disjoint_cycle_b.h rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_a


namespace cyclic_modules.disjoint_cycle_b

@[spec]
def i (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.disjoint_cycle_a.g rust_primitives.hax.Tuple0.mk)

end cyclic_modules.disjoint_cycle_b


namespace cyclic_modules.variant_constructor_a

inductive Context : Type
| A : i32 -> Context
| B : i32 -> Context

@[spec]
def Impl.test (x : (core_models.option.Option i32)) :
    RustM (core_models.option.Option Context) := do
  (core_models.option.Impl.map i32 Context (i32 -> RustM Context) x Context.A)

end cyclic_modules.variant_constructor_a


namespace cyclic_modules.variant_constructor_b

@[spec]
def h (_ : rust_primitives.hax.Tuple0) :
    RustM cyclic_modules.variant_constructor_a.Context := do
  (pure (cyclic_modules.variant_constructor_a.Context.A (1 : i32)))

end cyclic_modules.variant_constructor_b


namespace cyclic_modules.variant_constructor_a

@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM Context := do
  (cyclic_modules.variant_constructor_b.h rust_primitives.hax.Tuple0.mk)

end cyclic_modules.variant_constructor_a


namespace cyclic_modules.issue_1823.first_example.a

structure A where
  -- no fields

end cyclic_modules.issue_1823.first_example.a


namespace cyclic_modules.issue_1823.first_example.b

structure B where
  -- no fields

end cyclic_modules.issue_1823.first_example.b


namespace cyclic_modules.issue_1823.first_example.a

@[spec]
def Impl.mkb (self : A) :
    RustM cyclic_modules.issue_1823.first_example.b.B := do
  (pure cyclic_modules.issue_1823.first_example.b.B.mk)

end cyclic_modules.issue_1823.first_example.a


namespace cyclic_modules.issue_1823.first_example.b

@[spec]
def Impl.mka (self : B) :
    RustM cyclic_modules.issue_1823.first_example.a.A := do
  (pure cyclic_modules.issue_1823.first_example.a.A.mk)

end cyclic_modules.issue_1823.first_example.b


namespace cyclic_modules.issue_1823.second_example.a

@[spec]
def a (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.a


namespace cyclic_modules.issue_1823.second_example.b

@[spec]
def call_a (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.issue_1823.second_example.a.a rust_primitives.hax.Tuple0.mk)

@[spec]
def b (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.b


namespace cyclic_modules.issue_1823.second_example.a

@[spec]
def call_b (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.issue_1823.second_example.b.b rust_primitives.hax.Tuple0.mk)

end cyclic_modules.issue_1823.second_example.a


namespace cyclic_modules.typ_b

inductive T2Rec : Type
| T2 : cyclic_modules.typ_a.TRec -> T2Rec

inductive T1Rec : Type
| T1 : T2Rec -> T1Rec

end cyclic_modules.typ_b


namespace cyclic_modules.typ_a

inductive TRec : Type
| T : cyclic_modules.typ_b.T1Rec -> TRec
| Empty : TRec

end cyclic_modules.typ_a


namespace cyclic_modules.rec

@[spec]
def hf (x : T) : RustM T := do
  match x with | (T.t1 ) => (hf T.t2) | (T.t2 ) => (pure x)
partial_fixpoint

end cyclic_modules.rec


namespace cyclic_modules.rec2_same_name

@[spec]
def f (x : i32) : RustM i32 := do
  if (← (rust_primitives.hax.machine_int.gt x (0 : i32))) then
    (cyclic_modules.rec1_same_name.f (← (x -? (1 : i32))))
  else
    (pure (0 : i32))

end cyclic_modules.rec2_same_name


namespace cyclic_modules.rec1_same_name

@[spec]
def f (x : i32) : RustM i32 := do (cyclic_modules.rec2_same_name.f x)

end cyclic_modules.rec1_same_name


namespace cyclic_modules.late_skip_b

def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.late_skip_a.f rust_primitives.hax.Tuple0.mk)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def f.spec (_ : rust_primitives.hax.Tuple0) :
    Spec (requires := do (pure true)) (ensures := fun _ => pure True) (f ⟨⟩) :=
{
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [f] <;> bv_decide
}

end cyclic_modules.late_skip_b


namespace cyclic_modules.late_skip_a

@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (cyclic_modules.late_skip_b.f rust_primitives.hax.Tuple0.mk)

end cyclic_modules.late_skip_a


namespace cyclic_modules.enums_b

inductive U : Type
| A : U
| B : U
| C : (alloc.vec.Vec cyclic_modules.enums_a.T alloc.alloc.Global) -> U

inductive T : Type
| A : T
| B : T
| C : (alloc.vec.Vec cyclic_modules.enums_a.T alloc.alloc.Global) -> T

end cyclic_modules.enums_b


namespace cyclic_modules.enums_a

inductive T : Type
| A : T
| B : T
| C : (alloc.vec.Vec cyclic_modules.enums_b.U alloc.alloc.Global) -> T
| D : (alloc.vec.Vec cyclic_modules.enums_b.T alloc.alloc.Global) -> T

end cyclic_modules.enums_a


namespace cyclic_modules.enums_b

@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM T := do (pure T.A)

end cyclic_modules.enums_b


namespace cyclic_modules.rec

@[spec]
def g2 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g1 x) | (T.t2 ) => (hf x)

@[spec]
def g1 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g2 x) | (T.t2 ) => (pure T.t1)

end cyclic_modules.rec

'''
