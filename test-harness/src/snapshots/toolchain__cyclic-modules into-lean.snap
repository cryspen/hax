---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: cyclic-modules
    manifest: cyclic-modules/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0

[stdout]
diagnostics = []

[stdout.files]
"Cyclic_modules.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false


namespace Cyclic_modules.Typ_b

inductive T1 : Type
| T1 : T1

end Cyclic_modules.Typ_b


namespace Cyclic_modules.Typ_a

inductive T : Type
| T : Cyclic_modules.Typ_b.T1 -> T

end Cyclic_modules.Typ_a


namespace Cyclic_modules.Typ_b

def T1 (x : T1) : RustM isize := do
  match x with | (T1.T1 ) => (pure (0 : isize))

inductive T2 : Type
| T2 : Cyclic_modules.Typ_a.T -> T2

end Cyclic_modules.Typ_b


namespace Cyclic_modules

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules


namespace Cyclic_modules.B

def g (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.f Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.B


namespace Cyclic_modules.C

def i (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.C


namespace Cyclic_modules

def h (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  let _ ← (Cyclic_modules.B.g Rust_primitives.Hax.Tuple0.mk);
  (Cyclic_modules.C.i Rust_primitives.Hax.Tuple0.mk)

def h2 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.C.i Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules


namespace Cyclic_modules.D

def d1 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.D


namespace Cyclic_modules.E

def e1 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.D.d1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.E


namespace Cyclic_modules.De

def de1 (_ : Rust_primitives.Hax.Tuple0) :
    RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.E.e1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.De


namespace Cyclic_modules.D

def d2 (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.De.de1 Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.D


namespace Cyclic_modules.Rec

inductive T : Type
| t1 : T
| t2 : T

def T (x : T) : RustM isize := do
  match x with | (T.t1 ) => (pure (0 : isize)) | (T.t2 ) => (pure (1 : isize))

end Cyclic_modules.Rec


namespace Cyclic_modules.M2

def d (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

def c (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.M2


namespace Cyclic_modules.M1

def a (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.M2.c Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.M1


namespace Cyclic_modules.M2

def b (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  let _ ← (Cyclic_modules.M1.a Rust_primitives.Hax.Tuple0.mk);
  (d Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.M2


namespace Cyclic_modules.Disjoint_cycle_a

def g (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_a


namespace Cyclic_modules.Disjoint_cycle_b

def h (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_b


namespace Cyclic_modules.Disjoint_cycle_a

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Disjoint_cycle_b.h Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_a


namespace Cyclic_modules.Disjoint_cycle_b

def i (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Disjoint_cycle_a.g Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Disjoint_cycle_b


namespace Cyclic_modules.Variant_constructor_a

inductive Context : Type
| A : i32 -> Context
| B : i32 -> Context

def Impl.test (x : (Core_models.Option.Option i32)) :
    RustM (Core_models.Option.Option Context) := do
  (Core_models.Option.Impl.map i32 Context (i32 -> RustM Context) x Context.A)

end Cyclic_modules.Variant_constructor_a


namespace Cyclic_modules.Variant_constructor_b

def h (_ : Rust_primitives.Hax.Tuple0) :
    RustM Cyclic_modules.Variant_constructor_a.Context := do
  (pure (Cyclic_modules.Variant_constructor_a.Context.A (1 : i32)))

end Cyclic_modules.Variant_constructor_b


namespace Cyclic_modules.Variant_constructor_a

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Context := do
  (Cyclic_modules.Variant_constructor_b.h Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Variant_constructor_a


namespace Cyclic_modules.Issue_1823.First_example.A

structure A where
  -- no fields

end Cyclic_modules.Issue_1823.First_example.A


namespace Cyclic_modules.Issue_1823.First_example.B

structure B where
  -- no fields

end Cyclic_modules.Issue_1823.First_example.B


namespace Cyclic_modules.Issue_1823.First_example.A

def Impl.mkb (self : A) :
    RustM Cyclic_modules.Issue_1823.First_example.B.B := do
  (pure Cyclic_modules.Issue_1823.First_example.B.B.mk)

end Cyclic_modules.Issue_1823.First_example.A


namespace Cyclic_modules.Issue_1823.First_example.B

def Impl.mka (self : B) :
    RustM Cyclic_modules.Issue_1823.First_example.A.A := do
  (pure Cyclic_modules.Issue_1823.First_example.A.A.mk)

end Cyclic_modules.Issue_1823.First_example.B


namespace Cyclic_modules.Issue_1823.Second_example.A

def a (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Issue_1823.Second_example.A


namespace Cyclic_modules.Issue_1823.Second_example.B

def call_a (_ : Rust_primitives.Hax.Tuple0) :
    RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Issue_1823.Second_example.A.a Rust_primitives.Hax.Tuple0.mk)

def b (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Issue_1823.Second_example.B


namespace Cyclic_modules.Issue_1823.Second_example.A

def call_b (_ : Rust_primitives.Hax.Tuple0) :
    RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Issue_1823.Second_example.B.b Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Issue_1823.Second_example.A


namespace Cyclic_modules.Typ_b

inductive T2Rec : Type
| T2 : Cyclic_modules.Typ_a.TRec -> T2Rec

inductive T1Rec : Type
| T1 : T2Rec -> T1Rec

end Cyclic_modules.Typ_b


namespace Cyclic_modules.Typ_a

inductive TRec : Type
| T : Cyclic_modules.Typ_b.T1Rec -> TRec
| Empty : TRec

end Cyclic_modules.Typ_a


namespace Cyclic_modules.Rec

def hf (x : T) : RustM T := do
  match x with | (T.t1 ) => (hf T.t2) | (T.t2 ) => (pure x)

end Cyclic_modules.Rec


namespace Cyclic_modules.Rec2_same_name

def f (x : i32) : RustM i32 := do
  if (← (Rust_primitives.Hax.Machine_int.gt x (0 : i32))) then
    (Cyclic_modules.Rec1_same_name.f (← (x -? (1 : i32))))
  else
    (pure (0 : i32))

end Cyclic_modules.Rec2_same_name


namespace Cyclic_modules.Rec1_same_name

def f (x : i32) : RustM i32 := do (Cyclic_modules.Rec2_same_name.f x)

end Cyclic_modules.Rec1_same_name


namespace Cyclic_modules.Late_skip_b

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Late_skip_a.f Rust_primitives.Hax.Tuple0.mk)

@[spec]
def f.spec (_ : Rust_primitives.Hax.Tuple0) :
    Spec
      (requires := do (pure true))
      (ensures := fun _ => pure True)
      (f (_ : Rust_primitives.Hax.Tuple0)) := {
  pureRequires := by constructor; mvcgen <;> try grind
  pureEnsures := by constructor; intros; mvcgen <;> try grind
  contract := by mvcgen[f] <;> try grind
}

end Cyclic_modules.Late_skip_b


namespace Cyclic_modules.Late_skip_a

def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (Cyclic_modules.Late_skip_b.f Rust_primitives.Hax.Tuple0.mk)

end Cyclic_modules.Late_skip_a


namespace Cyclic_modules.Enums_b

inductive U : Type
| A : U
| B : U
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_a.T Alloc.Alloc.Global) -> U

inductive T : Type
| A : T
| B : T
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_a.T Alloc.Alloc.Global) -> T

end Cyclic_modules.Enums_b


namespace Cyclic_modules.Enums_a

inductive T : Type
| A : T
| B : T
| C : (Alloc.Vec.Vec Cyclic_modules.Enums_b.U Alloc.Alloc.Global) -> T
| D : (Alloc.Vec.Vec Cyclic_modules.Enums_b.T Alloc.Alloc.Global) -> T

end Cyclic_modules.Enums_a


namespace Cyclic_modules.Enums_b

def f (_ : Rust_primitives.Hax.Tuple0) : RustM T := do (pure T.A)

end Cyclic_modules.Enums_b


namespace Cyclic_modules.Rec

def g2 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g1 x) | (T.t2 ) => (hf x)

def g1 (x : T) : RustM T := do
  match x with | (T.t1 ) => (g2 x) | (T.t2 ) => (pure T.t1)

end Cyclic_modules.Rec

'''
