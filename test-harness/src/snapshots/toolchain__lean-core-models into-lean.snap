---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-core-models
    manifest: lean-core-models/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"Lean_core_models.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

inductive Lean_core_models.Result.E1 : Type
| C1 : Lean_core_models.Result.E1 
| C2 : u32 -> Lean_core_models.Result.E1 


instance Lean_core_models.Result.Impl :
  Core.Clone.Clone Lean_core_models.Result.E1
  where


inductive Lean_core_models.Result.E2 : Type
| C1 : Lean_core_models.Result.E2 
| C2 : u32 -> Lean_core_models.Result.E2 


def Lean_core_models.Result.tests
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Core.Result.Result u32 Lean_core_models.Result.E1)
  := do
  let v1 : (Core.Result.Result u32 Lean_core_models.Result.E1) :=
    (Core.Result.Result.Ok (1 : u32));
  let v2 : (Core.Result.Result u32 Lean_core_models.Result.E1) :=
    (Core.Result.Result.Err Lean_core_models.Result.E1.C1);
  let f : (u32 -> Result u32) := (fun x => (do (x +? (1 : u32)) : Result u32));
  let v5 : (Core.Result.Result i32 Lean_core_models.Result.E1) ←
    (Core.Result.Impl.map i32 Lean_core_models.Result.E1 i32 (i32 -> Result i32)
      (Core.Result.Result.Ok (1 : i32))
      (fun v => (do (v +? (1 : i32)) : Result i32)));
  let v6 : u32 ←
    (Core.Result.Impl.map_or
      u32
      Lean_core_models.Result.E1
      u32
      (u32 -> Result u32) (Core.Result.Result.Ok (1 : u32)) (9 : u32) f);
  let v7 : u32 ←
    (Core.Result.Impl.map_or_else
      u32
      Lean_core_models.Result.E1
      u32
      (Lean_core_models.Result.E1 -> Result u32)
      (u32 -> Result u32)
      (Core.Result.Result.Ok (1 : u32))
      (fun _ => (do (pure (10 : u32)) : Result u32))
      f);
  let v8 : (Core.Result.Result i32 Lean_core_models.Result.E2) ←
    (Core.Result.Impl.map_err
      i32
      Lean_core_models.Result.E1
      Lean_core_models.Result.E2
      (Lean_core_models.Result.E1 -> Result Lean_core_models.Result.E2)
      (Core.Result.Result.Ok (0 : i32))
      (fun e => (do
        match e with
          | (Lean_core_models.Result.E1.C1 )
            => (pure Lean_core_models.Result.E2.C1)
          | (Lean_core_models.Result.E1.C2 x)
            => (pure (Lean_core_models.Result.E2.C2 (← (x +? (1 : u32))))) :
        Result Lean_core_models.Result.E2)));
  let v9 : Bool ← (Core.Result.Impl.is_ok u32 Lean_core_models.Result.E1 v1);
  let v10 : Bool ← (Core.Result.Impl.is_err u32 Lean_core_models.Result.E1 v1);
  let v11 : (Core.Result.Result u32 Lean_core_models.Result.E1) ←
    (Core.Result.Impl.and_then
      u32
      Lean_core_models.Result.E1
      u32
      (u32 -> Result (Core.Result.Result u32 Lean_core_models.Result.E1))
      (← (Core.Clone.Clone.clone v1))
      (fun x => (do
        (pure (Core.Result.Result.Ok (← (x +? (1 : u32))))) : Result
        (Core.Result.Result u32 Lean_core_models.Result.E1))));
  let v12 : u32 ←
    (Core.Result.Impl.unwrap u32 u32
      (← (Core.Clone.Clone.clone (Core.Result.Result.Ok (0 : u32)))));
  let v13 : u32 ←
    (Core.Result.Impl.expect u32 u32
      (← (Core.Clone.Clone.clone (Core.Result.Result.Ok (0 : u32))))
      "Should be Ok");
  match
    (← (Core.Result.Impl.map
      u32
      Lean_core_models.Result.E1
      u32
      (u32 -> Result u32) v1 f))
  with
    | (Core.Result.Result.Ok hoist2)
      =>
        match v2 with
          | (Core.Result.Result.Ok hoist1)
            =>
              let v3 : u32 ← (hoist2 +? hoist1);
              (pure (Core.Result.Result.Ok v3))
          | (Core.Result.Result.Err err) => (pure (Core.Result.Result.Err err))
    | (Core.Result.Result.Err err) => (pure (Core.Result.Result.Err err))

structure Lean_core_models.Default.Structs.S where
  f1 : usize

instance Lean_core_models.Default.Structs.Impl :
  Core.Default.Default Lean_core_models.Default.Structs.S
  where
  default (_ : Rust_primitives.Hax.Tuple0) := do
    (pure (Lean_core_models.Default.Structs.S.mk (f1 := (0 : usize))))

def Lean_core_models.Default.Structs.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Lean_core_models.Default.Structs.S
  := do
  (Core.Default.Default.default Rust_primitives.Hax.Tuple0.mk)

inductive Lean_core_models.Default.Enums.E (T : Type) : Type
| C1 : u32 -> Lean_core_models.Default.Enums.E (T : Type) 
| C2 : T -> Lean_core_models.Default.Enums.E (T : Type) 


instance Lean_core_models.Default.Enums.Impl
  (T : Type) [(Core.Default.Default T)] :
  Core.Default.Default (Lean_core_models.Default.Enums.E T)
  where
  default (_ : Rust_primitives.Hax.Tuple0) := do
    (pure (Lean_core_models.Default.Enums.E.C2
      (← (Core.Default.Default.default Rust_primitives.Hax.Tuple0.mk))))

def Lean_core_models.Function.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result u32
  := do
  let f_1 : (u32 -> Result u32) :=
    (fun _ => (do (pure (9 : u32)) : Result u32));
  let f_2 : (u32 -> u32 -> Result u32) :=
    (fun x y => (do (x +? y) : Result u32));
  let f_2_tuple : ((Rust_primitives.Hax.Tuple2 u32 u32) -> Result u32) :=
    (fun ⟨x, y⟩ => (do (x +? y) : Result u32));
  ((← ((← (Core.Ops.Function.Fn.call
        f_1
        (Rust_primitives.Hax.Tuple1.mk (0 : u32))))
      +? (← (Core.Ops.Function.Fn.call
        f_2
        (Rust_primitives.Hax.Tuple2.mk (1 : u32) (2 : u32))))))
    +? (← (Core.Ops.Function.Fn.call
      f_2_tuple
      (Rust_primitives.Hax.Tuple1.mk
        (Rust_primitives.Hax.Tuple2.mk (1 : u32) (2 : u32))))))'''
