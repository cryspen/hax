---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"Lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

class Lean_tests.Traits.Overlapping_methods.T1 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T2 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T3 (Self : Type) where
  f : Self -> Result usize

instance Lean_tests.Traits.Overlapping_methods.Impl :
  Lean_tests.Traits.Overlapping_methods.T1 u32
  where
  f (self : u32) := do (0 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_1 :
  Lean_tests.Traits.Overlapping_methods.T2 u32
  where
  f (self : u32) := do (1 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_2 :
  Lean_tests.Traits.Overlapping_methods.T3 u32
  where
  f (self : u32) := do (2 : usize)

def Lean_tests.Traits.Overlapping_methods.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result usize
  := do
  let x ← (pure (9 : u32));
  (← (← (← Lean_tests.Traits.Overlapping_methods.T1.f x)
      +? (← Lean_tests.Traits.Overlapping_methods.T2.f x))
    +? (← Lean_tests.Traits.Overlapping_methods.T3.f x))

class Lean_tests.Traits.Inheritance.T1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Inheritance.T2 (Self : Type) where
  f2 : Self -> Result usize

class Lean_tests.Traits.Inheritance.T3 (Self : Type) where
  [_constr_5860918688139008796 : (Lean_tests.Traits.Inheritance.T2 Self)]
  [_constr_2614080591691505761 : (Lean_tests.Traits.Inheritance.T1 Self)]
  f3 : Self -> Result usize

class Lean_tests.Traits.Inheritance.Tp1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Inheritance.Tp2 (Self : Type) where
  [_constr_9900012313089209274 : (Lean_tests.Traits.Inheritance.Tp1 Self)]
  [_constr_3518312647081482353 : (Lean_tests.Traits.Inheritance.T3 Self)]
  fp2 : Self -> Result usize

structure Lean_tests.Traits.Inheritance.S where


instance Lean_tests.Traits.Inheritance.Impl :
  Lean_tests.Traits.Inheritance.T1 Lean_tests.Traits.Inheritance.S
  where
  f1 (self : Lean_tests.Traits.Inheritance.S) := do (1 : usize)

instance Lean_tests.Traits.Inheritance.Impl_1 :
  Lean_tests.Traits.Inheritance.T2 Lean_tests.Traits.Inheritance.S
  where
  f2 (self : Lean_tests.Traits.Inheritance.S) := do (2 : usize)

instance Lean_tests.Traits.Inheritance.Impl_2 :
  Lean_tests.Traits.Inheritance.T3 Lean_tests.Traits.Inheritance.S
  where
  f3 (self : Lean_tests.Traits.Inheritance.S) := do (3 : usize)

instance Lean_tests.Traits.Inheritance.Impl_3 :
  Lean_tests.Traits.Inheritance.Tp1 Lean_tests.Traits.Inheritance.S
  where
  f1 (self : Lean_tests.Traits.Inheritance.S) := do (10 : usize)

instance Lean_tests.Traits.Inheritance.Impl_4 :
  Lean_tests.Traits.Inheritance.Tp2 Lean_tests.Traits.Inheritance.S
  where
  fp2 (self : Lean_tests.Traits.Inheritance.S) := do
    (← (← (← (← Lean_tests.Traits.Inheritance.Tp1.f1 self)
          +? (← Lean_tests.Traits.Inheritance.T1.f1 self))
        +? (← Lean_tests.Traits.Inheritance.T2.f2 self))
      +? (← Lean_tests.Traits.Inheritance.T3.f3 self))

def Lean_tests.Traits.Inheritance.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result usize
  := do
  let s : Lean_tests.Traits.Inheritance.S ← (pure
    Lean_tests.Traits.Inheritance.S.mk);
  (← (← Lean_tests.Traits.Inheritance.T3.f3 s) +? (1 : usize))

class Lean_tests.Traits.Bounds.T1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Bounds.T2 (Self : Type) where
  f2 : Self -> Result usize

class Lean_tests.Traits.Bounds.Test (Self : Type) (T : Type) where
  [_constr_11094313111027375411 : (Lean_tests.Traits.Bounds.T2 Self)]
  [_constr_11502165326992889641 : (Lean_tests.Traits.Bounds.T1 T)]
  f_test : Self -> T -> Result usize

structure Lean_tests.Traits.Bounds.S1 where


instance Lean_tests.Traits.Bounds.Impl :
  Lean_tests.Traits.Bounds.T1 Lean_tests.Traits.Bounds.S1
  where
  f1 (self : Lean_tests.Traits.Bounds.S1) := do (0 : usize)

structure Lean_tests.Traits.Bounds.S2 where


instance Lean_tests.Traits.Bounds.Impl_1 :
  Lean_tests.Traits.Bounds.T2 Lean_tests.Traits.Bounds.S2
  where
  f2 (self : Lean_tests.Traits.Bounds.S2) := do (1 : usize)

instance Lean_tests.Traits.Bounds.Impl_2 :
  Lean_tests.Traits.Bounds.Test
  Lean_tests.Traits.Bounds.S2
  Lean_tests.Traits.Bounds.S1
  where
  f_test (self : Lean_tests.Traits.Bounds.S2)
    (x : Lean_tests.Traits.Bounds.S1)
    := do
    (← (← (← Lean_tests.Traits.Bounds.T1.f1 x)
        +? (← Lean_tests.Traits.Bounds.T2.f2 self))
      +? (1 : usize))

def Lean_tests.Traits.Bounds.test
  (x1 : Lean_tests.Traits.Bounds.S1)
  (x2 : Lean_tests.Traits.Bounds.S2)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Bounds.Test.f_test x2 x1)
    +? (← Lean_tests.Traits.Bounds.T1.f1 x1))

class Lean_tests.Traits.Basic.T1 (Self : Type) where
  f1 : Self -> Result usize
  f2 : Self -> Self -> Result usize

structure Lean_tests.Traits.Basic.S where


instance Lean_tests.Traits.Basic.Impl :
  Lean_tests.Traits.Basic.T1 Lean_tests.Traits.Basic.S
  where
  f1 (self : Lean_tests.Traits.Basic.S) := do (42 : usize)
  f2 (self : Lean_tests.Traits.Basic.S)
    (other : Lean_tests.Traits.Basic.S)
    := do
    (43 : usize)

def Lean_tests.Traits.Basic.f
  (T : Type) [(Lean_tests.Traits.Basic.T1 T)] (x : T)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Basic.T1.f1 x)
    +? (← Lean_tests.Traits.Basic.T1.f2 x x))

class Lean_tests.Traits.Associated_types.Foo (Self : Type) (T : Type) where


class Lean_tests.Traits.Associated_types.Bar (Self : Type) where


structure Lean_tests.Traits.Associated_types.S where


instance Lean_tests.Traits.Associated_types.Impl_2 :
  Lean_tests.Traits.Associated_types.Bar i16
  where


instance Lean_tests.Traits.Associated_types.Impl_3 (A : Type) :
  Lean_tests.Traits.Associated_types.Foo (Rust_primitives.Hax.Tuple2 u32 A) i16
  where


class Lean_tests.Traits.Associated_types.T1 (Self : Type) where
  T : Type
  f : Self -> T -> Result T

class Lean_tests.Traits.Associated_types.T3 (Self : Type) where
  T : Type
  [_constr_9884638762124940061 : (Lean_tests.Traits.Associated_types.Bar T)]
  Tp : Type
  [_constr_16271648697586611929 : (Lean_tests.Traits.Associated_types.Foo Tp T)]
  f (A : Type) [(Lean_tests.Traits.Associated_types.Bar A)] :
    Self -> T -> Tp -> Result usize

instance Lean_tests.Traits.Associated_types.Impl :
  Lean_tests.Traits.Associated_types.T1 Lean_tests.Traits.Associated_types.S
  where
  T := i32
  f (self : Lean_tests.Traits.Associated_types.S) (x : i32) := do (2121 : i32)

class Lean_tests.Traits.Associated_types.T2 (Self : Type) where
  T : Type
  [_constr_11855681382024687155 : (Lean_tests.Traits.Associated_types.T1 T)]
  f : Self -> T -> Result usize

instance Lean_tests.Traits.Associated_types.Impl_1 :
  Lean_tests.Traits.Associated_types.T2 Lean_tests.Traits.Associated_types.S
  where
  T := Lean_tests.Traits.Associated_types.S
  f (self : Lean_tests.Traits.Associated_types.S)
    (x : Lean_tests.Traits.Associated_types.S)
    := do
    (21 : usize)

structure Lean_tests.Structs.Miscellaneous.S where
  f : i32

def Lean_tests.Structs.Miscellaneous.test_tuples
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Rust_primitives.Hax.Tuple2 i32 i32)
  := do
  let lit : i32 ← (pure (1 : i32));
  let constr : Lean_tests.Structs.Miscellaneous.S ← (pure
    (Lean_tests.Structs.Miscellaneous.S.mk (f := (42 : i32))));
  let proj : i32 ← (pure (Lean_tests.Structs.Miscellaneous.S.f constr));
  let ite : (Rust_primitives.Hax.Tuple2 i32 i32) ← (pure
    (← if true then do
      (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))
    else do
      let z : i32 ← (pure (← (1 : i32) +? (2 : i32)));
      (Rust_primitives.Hax.Tuple2.mk z z)));
  (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))

structure Lean_tests.Structs.T0 where


structure Lean_tests.Structs.T1 (A : Type) where
  _0 : A

structure Lean_tests.Structs.T2 (A : Type) (B : Type) where
  _0 : A
  _1 : B

structure Lean_tests.Structs.T3 (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : B
  _2 : C

structure Lean_tests.Structs.T3p (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : (Lean_tests.Structs.T2 B C)

def Lean_tests.Structs.tuple_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let t0 : Lean_tests.Structs.T0 ← (pure Lean_tests.Structs.T0.mk);
  let t1 : (Lean_tests.Structs.T1 i32) ← (pure
    (Lean_tests.Structs.T1.mk (1 : i32)));
  let t2 : (Lean_tests.Structs.T2 i32 i32) ← (pure
    (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)));
  let
    t3 : (Lean_tests.Structs.T3
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T1.mk (1 : i32))
      (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32))));
  let
    t3p : (Lean_tests.Structs.T3p
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3p.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T2.mk
        (Lean_tests.Structs.T1.mk (1 : i32))
        (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)))));
  let ⟨⟩ ← (pure t0);
  let ⟨u1⟩ ← (pure t1);
  let ⟨u2, u3⟩ ← (pure t2);
  let ⟨⟨⟩, ⟨_⟩, ⟨_, _⟩⟩ ← (pure t3);
  let ⟨⟨⟩, ⟨⟨_⟩, ⟨_, _⟩⟩⟩ ← (pure t3p);
  let _ ← (pure (Lean_tests.Structs.T1._0 t1));
  let _ ← (pure (Lean_tests.Structs.T2._0 t2));
  let _ ← (pure (Lean_tests.Structs.T2._1 t2));
  let _ ← (pure (Lean_tests.Structs.T3._0 t3));
  let _ ← (pure (Lean_tests.Structs.T3._1 t3));
  let _ ← (pure (Lean_tests.Structs.T3._2 t3));
  let _ ← (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3._2 t3)));
  let _ ← (pure (Lean_tests.Structs.T3p._0 t3p));
  let _ ← (pure (Lean_tests.Structs.T3p._1 t3p));
  let _ ← (pure
    (Lean_tests.Structs.T2._0
        (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p))));
  let _ ← (pure (Lean_tests.Structs.T2._0 (Lean_tests.Structs.T3p._1 t3p)));
  let _ ← (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p)));
  let _ ← (pure (match t0 with | ⟨⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure (match t1 with | ⟨u1⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure (match t2 with | ⟨u2, u3⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match t3 with | ⟨⟨⟩, ⟨u1⟩, ⟨u2, u3⟩⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match t3p with
      | ⟨⟨⟩, ⟨⟨u1⟩, ⟨u2, u3⟩⟩⟩ => do Rust_primitives.Hax.Tuple0.mk));
  Rust_primitives.Hax.Tuple0.mk

structure Lean_tests.Structs.S1 where
  f1 : usize
  f2 : usize

structure Lean_tests.Structs.S2 where
  f1 : Lean_tests.Structs.S1
  f2 : usize

structure Lean_tests.Structs.S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

def Lean_tests.Structs.normal_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let s1 : Lean_tests.Structs.S1 ← (pure
    (Lean_tests.Structs.S1.mk (f1 := (0 : usize)) (f2 := (1 : usize))));
  let s2 : Lean_tests.Structs.S2 ← (pure
    (Lean_tests.Structs.S2.mk
      (f1 := (Lean_tests.Structs.S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
      (f2 := (4 : usize))));
  let s3 : Lean_tests.Structs.S3 ← (pure
    (Lean_tests.Structs.S3.mk
      (_end := (0 : usize))
      (_def := (0 : usize))
      (_theorem := (0 : usize))
      (_structure := (0 : usize))
      (_inductive := (0 : usize))));
  let {f1 := f1, f2 := f2} ← (pure s1);
  let {f1 := f1, f2 := other_name_for_f2} ← (pure s1);
  let {f1 := {f1 := f1, f2 := f2}, f2 := other_name_for_f2} ← (pure s2);
  let
    {_end := _end,
     _def := _def,
     _theorem := _theorem,
     _structure := _structure,
     _inductive := _inductive} ← (pure s3);
  let _ ← (pure
    (Rust_primitives.Hax.Tuple2.mk
      (Lean_tests.Structs.S1.f1 s1) (Lean_tests.Structs.S1.f2 s1)));
  let _ ← (pure
    (Rust_primitives.Hax.Tuple8.mk
      (Lean_tests.Structs.S1.f1 s1)
      (Lean_tests.Structs.S1.f2 s1)
      (Lean_tests.Structs.S1.f1 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S1.f2 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S2.f2 s2)
      (Lean_tests.Structs.S3._end s3)
      (Lean_tests.Structs.S3._def s3)
      (Lean_tests.Structs.S3._theorem s3)));
  let _ ← (pure
    (match s1 with | {f1 := f1, f2 := f2} => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match s2 with
      | {f1 := {f1 := f1, f2 := other_name_for_f2}, f2 := f2}
        => do Rust_primitives.Hax.Tuple0.mk));
  (match s3 with
    | {_end := _end,
       _def := _def,
       _theorem := _theorem,
       _structure := _structure,
       _inductive := _inductive}
      => do Rust_primitives.Hax.Tuple0.mk)

inductive Lean_tests.Loops.Errors.Error : Type
| Foo : Lean_tests.Loops.Errors.Error
| Bar : u32 -> Lean_tests.Loops.Errors.Error


def Lean_tests.Loops.Errors.loop3
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Core.Result.Result u32 Lean_tests.Loops.Errors.Error)
  := do
  let x : u32 ← (pure (0 : u32));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (1 : i32)
        (10 : i32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do
            (← if (← Rust_primitives.Hax.Machine_int.eq i (5 : i32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break
                  (Core.Result.Result.Err Lean_tests.Loops.Errors.Error.Foo)))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← x +? (5 : u32)))) :
            Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                (Core.Result.Result u32 Lean_tests.Loops.Errors.Error)
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue x)
      => do (Core.Result.Result.Ok x))

def Lean_tests.Loops.Errors.loop4
  (_ : Rust_primitives.Hax.Tuple0)
  : Result
  (Core.Result.Result
    (Rust_primitives.Hax.Tuple2 u32 u32)
    Lean_tests.Loops.Errors.Error)
  := do
  let e : u32 ← (pure (0 : u32));
  let f : Rust_primitives.Hax.Tuple0 -> Result u32 ← (pure
    (fun ⟨⟩ => (do (42 : u32) : Result u32)));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (0 : u32)
        (← Core.Ops.Function.Fn.call
            f
            (Rust_primitives.Hax.Tuple1.mk Rust_primitives.Hax.Tuple0.mk))
        (fun e _ => (do true : Result Bool))
        e
        (fun e i => (do
            (← if (← Rust_primitives.Hax.Machine_int.gt i (10 : u32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break
                  (Core.Result.Result.Err
                    (Lean_tests.Loops.Errors.Error.Bar e))))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← e +? i))) : Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                (Core.Result.Result
                  (Rust_primitives.Hax.Tuple2 u32 u32)
                  Lean_tests.Loops.Errors.Error)
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue e)
      => do (Core.Result.Result.Ok (Rust_primitives.Hax.Tuple2.mk e e)))

inductive Lean_tests.Enums.E : Type
| V1 : Lean_tests.Enums.E
| V2 : Lean_tests.Enums.E
| V3 : usize -> Lean_tests.Enums.E
| V4 : usize -> usize -> usize -> Lean_tests.Enums.E
| V5 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E
| V6 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E


inductive Lean_tests.Enums.MyList (T : Type) : Type
| Nil : Lean_tests.Enums.MyList (T : Type)
| Cons (hd : T)
       (tl : (Alloc.Boxed.Box (Lean_tests.Enums.MyList T) Alloc.Alloc.Global))
    : Lean_tests.Enums.MyList (T : Type)


def Lean_tests.Enums.enums
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let e_v1 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V1);
  let e_v2 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V2);
  let e_v3 : Lean_tests.Enums.E ← (pure (Lean_tests.Enums.E.V3 (23 : usize)));
  let e_v4 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V4 (23 : usize) (12 : usize) (1 : usize)));
  let e_v5 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V5 (f1 := (23 : usize)) (f2 := (43 : usize))));
  let e_v6 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V6 (f1 := (12 : usize)) (f2 := (13 : usize))));
  let nil ← (pure Lean_tests.Enums.MyList.Nil);
  let cons_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (1 : usize)) (tl := nil)));
  let cons_2_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (2 : usize)) (tl := cons_1)));
  (match e_v1 with
    | (Lean_tests.Enums.E.V1 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V2 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V3 _) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V4 x1 x2 x3)
      => do
        let y1 : usize ← (pure (← x1 +? x2));
        let y2 : usize ← (pure (← y1 -? x2));
        let y3 : usize ← (pure (← y2 +? x3));
        Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V5 (f1 := f1) (f2 := f2))
      => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V6 (f1 := f1) (f2 := other_name_for_f2))
      => do Rust_primitives.Hax.Tuple0.mk)

def Lean_tests.FORTYTWO : usize := 42

def Lean_tests.MINUS_FORTYTWO : isize := -42

def Lean_tests.returns42 (_ : Rust_primitives.Hax.Tuple0) : Result usize := do
  Lean_tests.FORTYTWO

def Lean_tests.add_two_numbers (x : usize) (y : usize) : Result usize := do
  (← x +? y)

def Lean_tests.letBinding (x : usize) (y : usize) : Result usize := do
  let useless : Rust_primitives.Hax.Tuple0 ← (pure
    Rust_primitives.Hax.Tuple0.mk);
  let result1 : usize ← (pure (← x +? y));
  let result2 : usize ← (pure (← result1 +? (2 : usize)));
  (← result2 +? (1 : usize))

def Lean_tests.closure (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (41 : i32));
  let f1 : i32 -> Result i32 ← (pure (fun y => (do (← y +? x) : Result i32)));
  let f2 : i32 -> i32 -> Result i32 ← (pure
    (fun y z => (do (← (← y +? x) +? z) : Result i32)));
  let res1 : i32 ← (pure
    (← Core.Ops.Function.Fn.call f1 (Rust_primitives.Hax.Tuple1.mk (1 : i32))));
  let res2 : i32 ← (pure
    (← Core.Ops.Function.Fn.call
        f2
        (Rust_primitives.Hax.Tuple2.mk (2 : i32) (3 : i32))));
  (← res1 +? res2)

@[spec]

def Lean_tests.test_before_verbatime_single_line (x : u8) : Result u8 := do
  (42 : u8)


def multiline : Unit := ()


def Lean_tests.test_before_verbatim_multi_line (x : u8) : Result u8 := do
  (32 : u8)

def Lean_tests.binop_resugarings (x : u32) : Result u32 := do
  let add : u32 ← (pure (← x +? (1 : u32)));
  let sub : u32 ← (pure (← add -? (2 : u32)));
  let mul : u32 ← (pure (← sub *? (3 : u32)));
  let rem : u32 ← (pure (← mul %? (4 : u32)));
  let div : u32 ← (pure (← rem /? (5 : u32)));
  let rshift : u32 ← (pure (← div >>>? x));
  x

def Lean_tests.Loops.loop1 (_ : Rust_primitives.Hax.Tuple0) : Result u32 := do
  let x ← (pure (0 : u32));
  let x : u32 ← (pure
    (← Rust_primitives.Hax.Folds.fold_range
        (1 : u32)
        (10 : u32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do (← x +? i) : Result u32))));
  x

def Lean_tests.Loops.loop2 (_ : Rust_primitives.Hax.Tuple0) : Result u32 := do
  let x ← (pure (0 : u32));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (1 : u32)
        (10 : u32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do
            (← if (← Rust_primitives.Hax.Machine_int.eq i (5 : u32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break x))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← x +? i))) : Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                u32
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue x) => do x)

def Lean_tests.Ite.test1 (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (← if true then do (0 : i32) else do (1 : i32)));
  (← if false then do (2 : i32) else do (3 : i32))

def Lean_tests.Ite.test2 (b : Bool) : Result i32 := do
  let x : i32 ← (pure
    (← (1 : i32) +? (← if true then do (0 : i32) else do (1 : i32))));
  let y : i32 ← (pure (0 : i32));
  let y : i32 ← (pure
    (← if true then do
      (← (← y +? x) +? (1 : i32))
    else do
      (← (← y -? x) -? (1 : i32))));
  (← if b then do
    let z : i32 ← (pure (← y +? y));
    (← (← z +? y) +? x)
  else do
    let z : i32 ← (pure (← y -? x));
    (← (← z +? y) +? x))'''
