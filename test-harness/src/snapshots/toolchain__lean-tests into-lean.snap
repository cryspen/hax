---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false



def FORTYTWO : USize := 42
def MINUS_FORTYTWO : ISize := -42
def returns42 (_ : Unit) : Result USize := do FORTYTWO

def add_two_numbers (x : USize) (y : USize) : Result USize := do (← x +? y)

def letBinding (x : USize) (y : USize) : Result USize := do
  let (useless : Unit) ← pure ();
  let (result1 : USize) ← pure (← x +? y);
  let (result2 : USize) ← pure (← result1 +? 2);
  (← result2 +? 1)

def closure (_ : Unit) : Result Int32 := do
  let (x : Int32) ← pure 41;
  let (f1 : Int32 -> Result Int32) ← pure (fun (y : Int32) => do (← y +? x));
  let (f2 : Int32 -> Int32 -> Result Int32) ← pure
    (fun (y : Int32) (z : Int32) => do (← (← y +? x) +? z));
  (← (← ops_function_Fn_call f1 (1, ())) +? (← ops_function_Fn_call f2 (2, 3)))


@[spec]
def test_before_verbatime_single_line (x : UInt8) : Result UInt8 := do 42



def multiline : Unit := ()

def test_before_verbatim_multi_line (x : UInt8) : Result UInt8 := do 32

def binop_resugarings (x : UInt32) : Result UInt32 := do
  (← (← (← x +? 1) -? (← (← (← 2 *? 3) %? 4) /? 5)) >>>? 1)

def tuples_resugaring (_ : Unit) : Result Unit := do
  let ((t : (UInt8 × UInt16 × UInt32)) : (UInt8 × UInt16 × UInt32)) ← pure
    (1, 2, 3);
  ()
'''
