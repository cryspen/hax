---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: true
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 1
stderr = """
Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0008] Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m
 \u001B[1m\u001B[94m-->\u001B[0m lean-tests/src/reject_do_dsl.rs:6:18
  \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[94m6 |\u001B[0m     let x1 = 1 + (if true { 0 } else { 1 });
  \u001B[1m\u001B[94m|\u001B[0m                  \u001B[1m\u001B[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001B[0m
  \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0008] Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m
  \u001B[1m\u001B[94m-->\u001B[0m lean-tests/src/reject_do_dsl.rs:8:11
   \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[94m 8 |\u001B[0m           + (match (1, 2) {
   \u001B[1m\u001B[94m|\u001B[0m  \u001B[1m\u001B[91m___________^\u001B[0m
\u001B[1m\u001B[94m 9 |\u001B[0m \u001B[1m\u001B[91m|\u001B[0m             _ => 0,
\u001B[1m\u001B[94m10 |\u001B[0m \u001B[1m\u001B[91m|\u001B[0m         });
   \u001B[1m\u001B[94m|\u001B[0m \u001B[1m\u001B[91m|__________^\u001B[0m
   \u001B[1m\u001B[94m|\u001B[0m"""
[[stdout.diagnostics]]
message = """
Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
\u001B[90mNote: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m"""
spans = ['Span { lo: Loc { line: 6, col: 17 }, hi: Loc { line: 6, col: 43 }, filename: Real(LocalPath("lean-tests/src/reject_do_dsl.rs")), rust_span_data: None }']

[[stdout.diagnostics]]
message = """
Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
\u001B[90mNote: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m"""
spans = ['Span { lo: Loc { line: 8, col: 10 }, hi: Loc { line: 10, col: 10 }, filename: Real(LocalPath("lean-tests/src/reject_do_dsl.rs")), rust_span_data: None }']

[stdout.files]
"Lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
open Std.Do
set_option mvcgen.warning false
set_option linter.unusedVariables false

namespace Lean_tests.Structs.Base_expressions

structure S where
  f1 : u32
  f2 : u32
  f3 : u32

def test
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let s1 : S := (S.mk (f1 := (1 : u32)) (f2 := (2 : u32)) (f3 := (3 : u32)));
  let _ := {s1 with f1 := (0 : u32)};
  let _ := {s1 with f2 := (0 : u32)};
  let _ := {s1 with f3 := (0 : u32)};
  let _ := {s1 with f1 := (0 : u32), f2 := (1 : u32)};
  let _ := {s1 with f2 := (0 : u32), f3 := (1 : u32)};
  let _ := {s1 with f3 := (0 : u32), f1 := (2 : u32)};
  let _ := {s1 with f1 := (0 : u32), f2 := (1 : u32), f3 := (0 : u32)};
  (pure Rust_primitives.Hax.Tuple0.mk)

end Lean_tests.Structs.Base_expressions


namespace Lean_tests.Comments

--  Single line doc comment
def f (_ : Rust_primitives.Hax.Tuple0) : RustM Rust_primitives.Hax.Tuple0 := do
  (pure Rust_primitives.Hax.Tuple0.mk)

/--
   Block doc-comment : Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum rutrum
  orci ac tellus ullamcorper sollicitudin. Sed fringilla mi id arcu suscipit rhoncus. Pellentesque et
  metus a ante feugiat lobortis. Nam a mauris eget nisl congue egestas. Duis et gravida
  nulla. Curabitur mattis leo vel molestie posuere. Etiam malesuada et augue eget
  varius. Pellentesque quis tincidunt erat. Vestibulum id consectetur turpis. Cras elementum magna id
  urna volutpat fermentum. In vel erat quis nunc rhoncus porta. Aliquam sed pellentesque
  tellus. Quisque odio diam, mollis ut venenatis non, scelerisque at nulla. Nunc urna ante, tristique
  quis nisi quis, congue maximus nisl. Curabitur non efficitur odio. 
  -/
def heavily_documented (_ : Rust_primitives.Hax.Tuple0) : RustM u32 := do
  (pure (4 : u32))

end Lean_tests.Comments


namespace Lean_tests.Traits.Inheritance

class T1 (Self : Type) where
  f1 : (Self -> RustM usize)

class T2 (Self : Type) where
  f2 : (Self -> RustM usize)

class T3 (Self : Type) where
  [_constr_T3_i0 : (T2 Self)]
  [_constr_T3_i1 : (T1 Self)]
  f3 : (Self -> RustM usize)

class Tp1 (Self : Type) where
  f1 : (Self -> RustM usize)

class Tp2 (Self : Type) where
  [_constr_Tp2_i0 : (Tp1 Self)]
  [_constr_Tp2_i1 : (T3 Self)]
  fp2 : (Self -> RustM usize)

structure S where
  -- no fields

instance Impl : T1 S where
  f1 (self : S) := do (pure (1 : usize))

instance Impl_1 : T2 S where
  f2 (self : S) := do (pure (2 : usize))

instance Impl_2 : T3 S where
  f3 (self : S) := do (pure (3 : usize))

instance Impl_3 : Tp1 S where
  f1 (self : S) := do (pure (10 : usize))

instance Impl_4 : Tp2 S where
  fp2 (self : S) := do
    ((← ((← ((← (Tp1.f1 self)) +? (← (T1.f1 self)))) +? (← (T2.f2 self))))
      +? (← (T3.f3 self)))

def test (_ : Rust_primitives.Hax.Tuple0) : RustM usize := do
  let s : S := S.mk;
  ((← (T3.f3 s)) +? (1 : usize))

end Lean_tests.Traits.Inheritance


namespace Lean_tests.Reject_do_dsl

def rejected
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let x1 : i32 ← ((1 : i32) +? sorry);
  let x2 : i32 ← ((1 : i32) +? sorry);
  let x : i32 := (9 : i32);
  let x3 : i32 ← ((1 : i32) +? (← (x +? (1 : i32))));
  (pure Rust_primitives.Hax.Tuple0.mk)

--  Code that should be produced from the rejected code
def accepted
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let x1_tmp : i32 ← if true then (pure (0 : i32)) else (pure (1 : i32));
  let x1 : i32 ← ((1 : i32) +? x1_tmp);
  let x2_tmp : i32 ←
    match (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32)) with
      | _ => (pure (0 : i32));
  let x2 : i32 ← ((1 : i32) +? x2_tmp);
  let x3_tmp_x : i32 := (9 : i32);
  let x3_tmp : i32 ← (x3_tmp_x +? (1 : i32));
  let x3 : i32 ← ((1 : i32) +? x3_tmp);
  (pure Rust_primitives.Hax.Tuple0.mk)

def test
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM
  (Rust_primitives.Hax.Tuple2
    Rust_primitives.Hax.Tuple0
    Rust_primitives.Hax.Tuple0)
  := do
  let x1 : i32 ←
    if true then
      let y : i32 ←
        if false then
          let z : i32 ←
            match Rust_primitives.Hax.Tuple0.mk with | _ => (pure (9 : i32));
          let z : i32 ← ((1 : i32) +? z);
          (z +? (1 : i32))
        else
          let z : i32 := (9 : i32);
          let z : i32 ← (z +? (1 : i32));
          (pure z);
      let y : i32 ← (y +? (1 : i32));
      (y +? (1 : i32))
    else
      (pure (0 : i32));
  let x1 : i32 ← (x1 +? (1 : i32));
  let x2 : i32 ←
    match (Core.Option.Option.Some (89 : i32)) with
      | (Core.Option.Option.Some a)
        =>
          let y : i32 ← ((1 : i32) +? a);
          let y : i32 ← (y +? (1 : i32));
          if (← (Rust_primitives.Hax.Machine_int.eq y (0 : i32))) then
            let z : i32 := (9 : i32);
            let z : i32 ← ((← (z +? y)) +? (1 : i32));
            (pure z)
          else
            (pure (10 : i32))
      | (Core.Option.Option.None )
        =>
          let y : i32 ←
            if false then
              (pure (9 : i32))
            else
              let z : i32 := (9 : i32);
              let z : i32 ← (z +? (1 : i32));
              (z +? (9 : i32));
          let y : i32 ← (y +? (1 : i32));
          (pure y);
  (pure (Rust_primitives.Hax.Tuple2.mk
    Rust_primitives.Hax.Tuple0.mk Rust_primitives.Hax.Tuple0.mk))

end Lean_tests.Reject_do_dsl


namespace Lean_tests.Traits.Associated_types

class Foo (Self : Type) (T : Type) where


class Bar (Self : Type) where


structure S where
  -- no fields

instance Impl_2 : Bar i16 where
  -- no fields

instance Impl_3 (A : Type) : Foo (Rust_primitives.Hax.Tuple2 u32 A) i16 where
  -- no fields

class T1 (Self : Type) where
  T : Type
  f : (Self -> T -> RustM T)

class T3 (Self : Type) where
  T : Type
  [_constr_T_i0 : (Bar T)]
  Tp : Type
  [_constr_Tp_i0 : (Foo Tp T)]
  f (A : Type) [(Bar A)] : (Self -> T -> Tp -> RustM usize)

instance Impl : T1 S where
  T := i32
  f (self : S) (x : i32) := do (pure (2121 : i32))

class T2 (Self : Type) where
  T : Type
  [_constr_T_i0 : (T1 T)]
  f : (Self -> T -> RustM usize)

instance Impl_1 : T2 S where
  T := S
  f (self : S) (x : S) := do (pure (21 : usize))

end Lean_tests.Traits.Associated_types


namespace Lean_tests.Traits.Bounds

class T1 (Self : Type) where
  f1 : (Self -> RustM usize)

class T2 (Self : Type) where
  f2 : (Self -> RustM usize)

class Test (Self : Type) (T : Type) where
  [_constr_Test_i0 : (T2 Self)]
  [_constr_Test_i1 : (T1 T)]
  f_test : (Self -> T -> RustM usize)

structure S1 where
  -- no fields

instance Impl : T1 S1 where
  f1 (self : S1) := do (pure (0 : usize))

structure S2 where
  -- no fields

instance Impl_1 : T2 S2 where
  f2 (self : S2) := do (pure (1 : usize))

instance Impl_2 : Test S2 S1 where
  f_test (self : S2) (x : S1) := do
    ((← ((← (T1.f1 x)) +? (← (T2.f2 self)))) +? (1 : usize))

def test (x1 : S1) (x2 : S2) : RustM usize := do
  ((← (Test.f_test x2 x1)) +? (← (T1.f1 x1)))

end Lean_tests.Traits.Bounds


namespace Lean_tests.Enums

inductive E : Type
| V1 : E
| V2 : E
| V3 : usize -> E
| V4 : usize -> usize -> usize -> E
| V5 (f1 : usize) (f2 : usize) : E
| V6 (f1 : usize) (f2 : usize) : E

inductive MyList (T : Type) : Type
| Nil : MyList (T : Type) 
| Cons (hd : T) (tl : (Alloc.Boxed.Box (MyList T) Alloc.Alloc.Global)) : MyList
  (T : Type) 

def enums
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let e_v1 : E := E.V1;
  let e_v2 : E := E.V2;
  let e_v3 : E := (E.V3 (23 : usize));
  let e_v4 : E := (E.V4 (23 : usize) (12 : usize) (1 : usize));
  let e_v5 : E := (E.V5 (f1 := (23 : usize)) (f2 := (43 : usize)));
  let e_v6 : E := (E.V6 (f1 := (12 : usize)) (f2 := (13 : usize)));
  let nil : (MyList usize) := MyList.Nil;
  let cons_1 : (MyList usize) := (MyList.Cons (hd := (1 : usize)) (tl := nil));
  let cons_2_1 : (MyList usize) :=
    (MyList.Cons (hd := (2 : usize)) (tl := cons_1));
  match e_v1 with
    | (E.V1 ) => (pure Rust_primitives.Hax.Tuple0.mk)
    | (E.V2 ) => (pure Rust_primitives.Hax.Tuple0.mk)
    | (E.V3 _) => (pure Rust_primitives.Hax.Tuple0.mk)
    | (E.V4 x1 x2 x3)
      =>
        let y1 : usize ← (x1 +? x2);
        let y2 : usize ← (y1 -? x2);
        let y3 : usize ← (y2 +? x3);
        (pure Rust_primitives.Hax.Tuple0.mk)
    | (E.V5 (f1 := f1) (f2 := f2)) => (pure Rust_primitives.Hax.Tuple0.mk)
    | (E.V6 (f1 := f1) (f2 := other_name_for_f2))
      => (pure Rust_primitives.Hax.Tuple0.mk)

end Lean_tests.Enums


namespace Lean_tests.Structs.Miscellaneous

structure S where
  f : i32

def test_tuples
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM (Rust_primitives.Hax.Tuple2 i32 i32)
  := do
  let lit : i32 := (1 : i32);
  let constr : S := (S.mk (f := (42 : i32)));
  let proj : i32 := (S.f constr);
  let ite : (Rust_primitives.Hax.Tuple2 i32 i32) ←
    if true then
      (pure (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32)))
    else
      let z : i32 ← ((1 : i32) +? (2 : i32));
      (pure (Rust_primitives.Hax.Tuple2.mk z z));
  (pure (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32)))

end Lean_tests.Structs.Miscellaneous


namespace Lean_tests.Loops

def loop1 (_ : Rust_primitives.Hax.Tuple0) : RustM u32 := do
  let x : u32 := (0 : u32);
  let x : u32 ←
    (Rust_primitives.Hax.Folds.fold_range
      (1 : u32)
      (10 : u32)
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i => (do (x +? i) : RustM u32)));
  (pure x)

def loop2 (_ : Rust_primitives.Hax.Tuple0) : RustM u32 := do
  let x : u32 := (0 : u32);
  match
    (← (Rust_primitives.Hax.Folds.fold_range_return
      (1 : u32)
      (10 : u32)
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i => (do
        if (← (Rust_primitives.Hax.Machine_int.eq i (5 : u32))) then
          (pure (Core.Ops.Control_flow.ControlFlow.Break
            (Core.Ops.Control_flow.ControlFlow.Break x)))
        else
          (pure (Core.Ops.Control_flow.ControlFlow.Continue (← (x +? i)))) :
        RustM
        (Core.Ops.Control_flow.ControlFlow
          (Core.Ops.Control_flow.ControlFlow
            u32
            (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
          u32)))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => (pure ret)
    | (Core.Ops.Control_flow.ControlFlow.Continue x) => (pure x)

end Lean_tests.Loops


namespace Lean_tests.Traits.Default

class Easy (Self : Type) where
  dft (self : Self) : RustM usize := do (pure (32 : usize))

instance Impl : Easy usize where
  dft (self : usize) := do (self +? (1 : usize))

instance Impl_1 : Easy u32 where
  -- no fields

class T1 (Self : Type) where
  f1 : (Self -> RustM usize)
  f2 (self : Self) : RustM usize := do (pure (1 : usize))
  f3 (A : Type) (self : Self) (x : A) : RustM usize := do (pure (1 : usize))
  f4 (A : Type) [(Easy A)] (self : Self) (x : A) : RustM usize := do
    ((← (Easy.dft x)) +? (1 : usize))

structure S (A : Type) where
  _0 : usize
  _1 : A

instance Impl_2 : T1 (S usize) where
  f1 (self : (S usize)) := do ((S._0 self) +? (S._1 self))
  f2 (self : (S usize)) := do (pure (S._1 self))

instance Impl_3 : T1 (S Bool) where
  f1 (self : (S Bool)) := do
    if (S._1 self) then (pure (S._0 self)) else (pure (9 : usize))
  f2 (self : (S Bool)) := do ((S._0 self) +? (1 : usize))

instance Impl_4 : T1 (S Alloc.String.String) where
  f1 (self : (S Alloc.String.String)) := do (pure (0 : usize))

end Lean_tests.Traits.Default


namespace Lean_tests.Traits.Basic

class T1 (Self : Type) where
  f1 : (Self -> RustM usize)
  f2 : (Self -> Self -> RustM usize)

structure S where
  -- no fields

instance Impl : T1 S where
  f1 (self : S) := do (pure (42 : usize))
  f2 (self : S) (other : S) := do (pure (43 : usize))

def f (T : Type) [(T1 T)] (x : T) : RustM usize := do
  ((← (T1.f1 x)) +? (← (T1.f2 x x)))

end Lean_tests.Traits.Basic


namespace Lean_tests.Structs

structure T0 where
  -- no fields

structure T1 (A : Type) where
  _0 : A

structure T2 (A : Type) (B : Type) where
  _0 : A
  _1 : B

structure T3 (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : B
  _2 : C

structure T3p (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : (T2 B C)

def tuple_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let t0 : T0 := T0.mk;
  let t1 : (T1 i32) := (T1.mk (1 : i32));
  let t2 : (T2 i32 i32) := (T2.mk (1 : i32) (2 : i32));
  let t3 : (T3 T0 (T1 i32) (T2 i32 i32)) :=
    (T3.mk T0.mk (T1.mk (1 : i32)) (T2.mk (1 : i32) (2 : i32)));
  let t3p : (T3p T0 (T1 i32) (T2 i32 i32)) :=
    (T3p.mk T0.mk (T2.mk (T1.mk (1 : i32)) (T2.mk (1 : i32) (2 : i32))));
  let ⟨⟩ := t0;
  let ⟨u1⟩ := t1;
  let ⟨u2, u3⟩ := t2;
  let ⟨⟨⟩, ⟨_⟩, ⟨_, _⟩⟩ := t3;
  let ⟨⟨⟩, ⟨⟨_⟩, ⟨_, _⟩⟩⟩ := t3p;
  let _ := (T1._0 t1);
  let _ := (T2._0 t2);
  let _ := (T2._1 t2);
  let _ := (T3._0 t3);
  let _ := (T3._1 t3);
  let _ := (T3._2 t3);
  let _ := (T2._1 (T3._2 t3));
  let _ := (T3p._0 t3p);
  let _ := (T3p._1 t3p);
  let _ := (T2._0 (T2._1 (T3p._1 t3p)));
  let _ := (T2._0 (T3p._1 t3p));
  let _ := (T2._1 (T3p._1 t3p));
  let _ ← match t0 with | ⟨⟩ => (pure Rust_primitives.Hax.Tuple0.mk);
  let _ ← match t1 with | ⟨u1⟩ => (pure Rust_primitives.Hax.Tuple0.mk);
  let _ ← match t2 with | ⟨u2, u3⟩ => (pure Rust_primitives.Hax.Tuple0.mk);
  let _ ←
    match t3 with
      | ⟨⟨⟩, ⟨u1⟩, ⟨u2, u3⟩⟩ => (pure Rust_primitives.Hax.Tuple0.mk);
  let _ ←
    match t3p with
      | ⟨⟨⟩, ⟨⟨u1⟩, ⟨u2, u3⟩⟩⟩ => (pure Rust_primitives.Hax.Tuple0.mk);
  (pure Rust_primitives.Hax.Tuple0.mk)

structure S1 where
  f1 : usize
  f2 : usize

structure S2 where
  f1 : S1
  f2 : usize

structure S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

def normal_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let s1 : S1 := (S1.mk (f1 := (0 : usize)) (f2 := (1 : usize)));
  let s2 : S2 :=
    (S2.mk
      (f1 := (S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
      (f2 := (4 : usize)));
  let s3 : S3 :=
    (S3.mk
      (_end := (0 : usize))
      (_def := (0 : usize))
      (_theorem := (0 : usize))
      (_structure := (0 : usize))
      (_inductive := (0 : usize)));
  let {f1 := f1, f2 := f2} := s1;
  let {f1 := f1, f2 := other_name_for_f2} := s1;
  let {f1 := {f1 := f1, f2 := f2}, f2 := other_name_for_f2} := s2;
  let
    {_end := _end,
     _def := _def,
     _theorem := _theorem,
     _structure := _structure,
     _inductive := _inductive} :=
    s3;
  let _ := (Rust_primitives.Hax.Tuple2.mk (S1.f1 s1) (S1.f2 s1));
  let _ :=
    (Rust_primitives.Hax.Tuple8.mk
      (S1.f1 s1)
      (S1.f2 s1)
      (S1.f1 (S2.f1 s2))
      (S1.f2 (S2.f1 s2))
      (S2.f2 s2)
      (S3._end s3)
      (S3._def s3)
      (S3._theorem s3));
  let _ ←
    match s1 with
      | {f1 := f1, f2 := f2} => (pure Rust_primitives.Hax.Tuple0.mk);
  let _ ←
    match s2 with
      | {f1 := {f1 := f1, f2 := other_name_for_f2}, f2 := f2}
        => (pure Rust_primitives.Hax.Tuple0.mk);
  match s3 with
    | {_end := _end,
       _def := _def,
       _theorem := _theorem,
       _structure := _structure,
       _inductive := _inductive}
      => (pure Rust_primitives.Hax.Tuple0.mk)

end Lean_tests.Structs


namespace Lean_tests.Constants

def C1 : u32 := RustM.of_isOk (do (pure (5678 : u32))) (by rfl)

def C2 : u32 := RustM.of_isOk (do (C1 +? (1 : u32))) (by rfl)

def C3 : u32 :=
  RustM.of_isOk
    (do if true then (pure (890 : u32)) else ((9 : u32) /? (0 : u32)))
    (by rfl)

def computation (x : u32) : RustM u32 := do ((← (x +? x)) +? (1 : u32))

def C4 : u32 := RustM.of_isOk (do ((← (computation C1)) +? C2)) (by rfl)

def test
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let x : u32 ← (C1 +? (1 : u32));
  let y : u32 ← (C2 +? C3);
  let z : u32 ← (C4 -? C3);
  (pure Rust_primitives.Hax.Tuple0.mk)

end Lean_tests.Constants


namespace Lean_tests

def FORTYTWO : usize := RustM.of_isOk (do (pure (42 : usize))) (by rfl)

def MINUS_FORTYTWO : isize := RustM.of_isOk (do (pure (-42 : isize))) (by rfl)

def returns42 (_ : Rust_primitives.Hax.Tuple0) : RustM usize := do
  (pure FORTYTWO)

def add_two_numbers (x : usize) (y : usize) : RustM usize := do (x +? y)

def letBinding (x : usize) (y : usize) : RustM usize := do
  let useless : Rust_primitives.Hax.Tuple0 := Rust_primitives.Hax.Tuple0.mk;
  let result1 : usize ← (x +? y);
  let result2 : usize ← (result1 +? (2 : usize));
  (result2 +? (1 : usize))

def closure (_ : Rust_primitives.Hax.Tuple0) : RustM i32 := do
  let x : i32 := (41 : i32);
  let f1 : (i32 -> RustM i32) := (fun y => (do (y +? x) : RustM i32));
  let f2 : (i32 -> i32 -> RustM i32) :=
    (fun y z => (do ((← (y +? x)) +? z) : RustM i32));
  let res1 : i32 ←
    (Core.Ops.Function.Fn.call f1 (Rust_primitives.Hax.Tuple1.mk (1 : i32)));
  let res2 : i32 ←
    (Core.Ops.Function.Fn.call
      f2
      (Rust_primitives.Hax.Tuple2.mk (2 : i32) (3 : i32)));
  (res1 +? res2)

def _ : Rust_primitives.Hax.Tuple0 :=
  RustM.of_isOk (do (pure Rust_primitives.Hax.Tuple0.mk)) (by rfl)

@[spec]

def test_before_verbatime_single_line (x : u8) : RustM u8 := do (pure (42 : u8))

def __1 : Rust_primitives.Hax.Tuple0 :=
  RustM.of_isOk (do (pure Rust_primitives.Hax.Tuple0.mk)) (by rfl)


def multiline : Unit := ()


def test_before_verbatim_multi_line (x : u8) : RustM u8 := do (pure (32 : u8))

def binop_resugarings (x : u32) : RustM u32 := do
  let add : u32 ← (x +? (1 : u32));
  let sub : u32 ← (add -? (2 : u32));
  let mul : u32 ← (sub *? (3 : u32));
  let rem : u32 ← (mul %? (4 : u32));
  let div : u32 ← (rem /? (5 : u32));
  let rshift : u32 ← (div >>>? x);
  (pure x)

end Lean_tests


namespace Lean_tests.Loops.Errors

inductive Error : Type
| Foo : Error
| Bar : u32 -> Error

def loop3
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM (Core.Result.Result u32 Error)
  := do
  let x : u32 := (0 : u32);
  let _end : u32 := (10 : u32);
  match
    (← (Rust_primitives.Hax.Folds.fold_range_return
      (1 : u32)
      _end
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i => (do
        if (← (Rust_primitives.Hax.Machine_int.eq i (5 : u32))) then
          (pure (Core.Ops.Control_flow.ControlFlow.Break
            (Core.Ops.Control_flow.ControlFlow.Break
              (Core.Result.Result.Err Error.Foo))))
        else
          (pure (Core.Ops.Control_flow.ControlFlow.Continue
            (← (x +? (5 : u32))))) : RustM
        (Core.Ops.Control_flow.ControlFlow
          (Core.Ops.Control_flow.ControlFlow
            (Core.Result.Result u32 Error)
            (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
          u32)))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => (pure ret)
    | (Core.Ops.Control_flow.ControlFlow.Continue x)
      => (pure (Core.Result.Result.Ok x))

def loop4
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM (Core.Result.Result (Rust_primitives.Hax.Tuple2 u32 u32) Error)
  := do
  let e : u32 := (0 : u32);
  let f : (Rust_primitives.Hax.Tuple0 -> RustM u32) :=
    (fun ⟨⟩ => (do (pure (42 : u32)) : RustM u32));
  match
    (← (Rust_primitives.Hax.Folds.fold_range_return
      (0 : u32)
      (← (Core.Ops.Function.Fn.call
        f
        (Rust_primitives.Hax.Tuple1.mk Rust_primitives.Hax.Tuple0.mk)))
      (fun e _ => (do (pure true) : RustM Bool))
      e
      (fun e i => (do
        if (← (Rust_primitives.Hax.Machine_int.gt i (10 : u32))) then
          (pure (Core.Ops.Control_flow.ControlFlow.Break
            (Core.Ops.Control_flow.ControlFlow.Break
              (Core.Result.Result.Err (Error.Bar e)))))
        else
          (pure (Core.Ops.Control_flow.ControlFlow.Continue (← (e +? i)))) :
        RustM
        (Core.Ops.Control_flow.ControlFlow
          (Core.Ops.Control_flow.ControlFlow
            (Core.Result.Result (Rust_primitives.Hax.Tuple2 u32 u32) Error)
            (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
          u32)))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => (pure ret)
    | (Core.Ops.Control_flow.ControlFlow.Continue e)
      => (pure (Core.Result.Result.Ok (Rust_primitives.Hax.Tuple2.mk e e)))

end Lean_tests.Loops.Errors


namespace Lean_tests.Monadic

structure S where
  f : u32

def test
  (_ : Rust_primitives.Hax.Tuple0)
  : RustM Rust_primitives.Hax.Tuple0
  := do
  let _ := (9 : i32);
  let _ ← ((9 : i32) +? (9 : i32));
  let _ := (S.mk (f := (9 : u32)));
  let _ := (S.mk (f := (← ((9 : u32) +? (9 : u32)))));
  let _ := (S.f (S.mk (f := (← ((9 : u32) +? (9 : u32))))));
  let _ ← ((S.f (S.mk (f := (← ((9 : u32) +? (9 : u32)))))) +? (9 : u32));
  let _ ← if true then ((3 : i32) +? (4 : i32)) else ((3 : i32) -? (4 : i32));
  let _ ←
    if
    (← (Rust_primitives.Hax.Machine_int.eq
      (← ((9 : i32) +? (9 : i32)))
      (0 : i32))) then
      ((3 : i32) +? (4 : i32))
    else
      ((3 : i32) -? (4 : i32));
  let _ ←
    if true then
      let x : i32 := (9 : i32);
      let _ ← ((3 : i32) +? x);
      (pure Rust_primitives.Hax.Tuple0.mk)
    else
      let y : i32 := (19 : i32);
      let _ ← ((← ((3 : i32) +? y)) -? (4 : i32));
      (pure Rust_primitives.Hax.Tuple0.mk);
  (pure Rust_primitives.Hax.Tuple0.mk)

end Lean_tests.Monadic


namespace Lean_tests.Traits.Overlapping_methods

class T1 (Self : Type) where
  f : (Self -> RustM usize)

class T2 (Self : Type) where
  f : (Self -> RustM usize)

class T3 (Self : Type) where
  f : (Self -> RustM usize)

instance Impl : T1 u32 where
  f (self : u32) := do (pure (0 : usize))

instance Impl_1 : T2 u32 where
  f (self : u32) := do (pure (1 : usize))

instance Impl_2 : T3 u32 where
  f (self : u32) := do (pure (2 : usize))

def test (_ : Rust_primitives.Hax.Tuple0) : RustM usize := do
  let x : u32 := (9 : u32);
  ((← ((← (T1.f x)) +? (← (T2.f x)))) +? (← (T3.f x)))

end Lean_tests.Traits.Overlapping_methods


namespace Lean_tests.Ite

def test1 (_ : Rust_primitives.Hax.Tuple0) : RustM i32 := do
  let x : i32 ← if true then (pure (0 : i32)) else (pure (1 : i32));
  if false then (pure (2 : i32)) else (pure (3 : i32))

def test2 (b : Bool) : RustM i32 := do
  let x : i32 ← if b then (pure (0 : i32)) else (pure (9 : i32));
  let y : i32 := (0 : i32);
  let y : i32 ←
    if true then ((← (y +? x)) +? (1 : i32)) else ((← (y -? x)) -? (1 : i32));
  if b then
    let z : i32 ← (y +? y);
    ((← (z +? y)) +? x)
  else
    let z : i32 ← (y -? x);
    ((← (z +? y)) +? x)

end Lean_tests.Ite

'''
