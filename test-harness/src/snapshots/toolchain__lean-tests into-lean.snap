---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"Lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

class Lean_tests.Traits.Overlapping_methods.T1 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T2 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T3 (Self : Type) where
  f : Self -> Result usize

instance Lean_tests.Traits.Overlapping_methods.Impl :
  Lean_tests.Traits.Overlapping_methods.T1 u32
  where
  f (self : u32) := do (0 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_1 :
  Lean_tests.Traits.Overlapping_methods.T2 u32
  where
  f (self : u32) := do (1 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_2 :
  Lean_tests.Traits.Overlapping_methods.T3 u32
  where
  f (self : u32) := do (2 : usize)

def Lean_tests.Traits.Overlapping_methods.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result usize
  := do
  let (x : u32) ← (pure (9 : u32));
  (← (← (← Lean_tests.Traits.Overlapping_methods.T1.f x)
      +? (← Lean_tests.Traits.Overlapping_methods.T2.f x))
    +? (← Lean_tests.Traits.Overlapping_methods.T3.f x))

class Lean_tests.Traits.Bounds.T1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Bounds.T2 (Self : Type) where
  f2 : Self -> Result usize

class Lean_tests.Traits.Bounds.Test (Self : Type) (T : Type) where
  [_constr_11094313111027375411 : (Lean_tests.Traits.Bounds.T2 Self)]
  [_constr_11502165326992889641 : (Lean_tests.Traits.Bounds.T1 T)]
  f_test : Self -> T -> Result usize

structure Lean_tests.Traits.Bounds.S1 where


instance Lean_tests.Traits.Bounds.Impl :
  Lean_tests.Traits.Bounds.T1 Lean_tests.Traits.Bounds.S1
  where
  f1 (self : Lean_tests.Traits.Bounds.S1) := do (0 : usize)

structure Lean_tests.Traits.Bounds.S2 where


instance Lean_tests.Traits.Bounds.Impl_1 :
  Lean_tests.Traits.Bounds.T2 Lean_tests.Traits.Bounds.S2
  where
  f2 (self : Lean_tests.Traits.Bounds.S2) := do (1 : usize)

instance Lean_tests.Traits.Bounds.Impl_2 :
  Lean_tests.Traits.Bounds.Test
  Lean_tests.Traits.Bounds.S2
  Lean_tests.Traits.Bounds.S1
  where
  f_test (self : Lean_tests.Traits.Bounds.S2)
         (x : Lean_tests.Traits.Bounds.S1)
    := do
    (← (← (← Lean_tests.Traits.Bounds.T1.f1 x)
        +? (← Lean_tests.Traits.Bounds.T2.f2 self))
      +? (1 : usize))

def Lean_tests.Traits.Bounds.test
  (x1 : Lean_tests.Traits.Bounds.S1)
  (x2 : Lean_tests.Traits.Bounds.S2)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Bounds.Test.f_test x2 x1)
    +? (← Lean_tests.Traits.Bounds.T1.f1 x1))

class Lean_tests.Traits.Basic.T1 (Self : Type) where
  f1 : Self -> Result usize
  f2 : Self -> Self -> Result usize

structure Lean_tests.Traits.Basic.S where


instance Lean_tests.Traits.Basic.Impl :
  Lean_tests.Traits.Basic.T1 Lean_tests.Traits.Basic.S
  where
  f1 (self : Lean_tests.Traits.Basic.S) := do (42 : usize)
  f2 (self : Lean_tests.Traits.Basic.S)
     (other : Lean_tests.Traits.Basic.S)
    := do
    (43 : usize)

def Lean_tests.Traits.Basic.f
  (T : Type) [(Lean_tests.Traits.Basic.T1 T)] (x : T)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Basic.T1.f1 x)
    +? (← Lean_tests.Traits.Basic.T1.f2 x x))

class Lean_tests.Traits.Associated_types.Foo (Self : Type) (T : Type) where


class Lean_tests.Traits.Associated_types.Bar (Self : Type) where


class Lean_tests.Traits.Associated_types.T1 (Self : Type) where
  T : Type
  f : Self -> T -> Result T

class Lean_tests.Traits.Associated_types.T3 (Self : Type) where
  T : Type
  [_constr_14712917225944295424 :
    (Lean_tests.Traits.Associated_types.Foo T Rust_primitives.Hax.Tuple0)]
  Tp : Type
  [_constr_17020143134338090706 : (Lean_tests.Traits.Associated_types.Foo Tp T)]
  f (A : Type) [(Lean_tests.Traits.Associated_types.Bar A)] :
    Self -> T -> Tp -> Result usize

class Lean_tests.Traits.Associated_types.T2 (Self : Type) where
  T : Type
  [_constr_11855681382024687155 : (Lean_tests.Traits.Associated_types.T1 T)]
  f : Self -> T -> Result usize

structure Lean_tests.Structs.Miscellaneous.S where
  f : i32

def Lean_tests.Structs.Miscellaneous.test_tuples
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Rust_primitives.Hax.Tuple2 i32 i32)
  := do
  let lit : i32 ← (pure (1 : i32));
  let constr : Lean_tests.Structs.Miscellaneous.S ← (pure
    (Lean_tests.Structs.Miscellaneous.S.mk (f := (42 : i32))));
  let proj : i32 ← (pure (Lean_tests.Structs.Miscellaneous.S.f constr));
  let ite : (Rust_primitives.Hax.Tuple2 i32 i32) ← (pure
    (← if true then do
      (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))
    else do
      let z : i32 ← (pure (← (1 : i32) +? (2 : i32)));
      (Rust_primitives.Hax.Tuple2.mk z z)));
  (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))

structure Lean_tests.Structs.T0 where


structure Lean_tests.Structs.T1 (A : Type) where
  _0 : A

structure Lean_tests.Structs.T2 (A : Type) (B : Type) where
  _0 : A
  _1 : B

structure Lean_tests.Structs.T3 (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : B
  _2 : C

structure Lean_tests.Structs.T3p (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : (Lean_tests.Structs.T2 B C)

def Lean_tests.Structs.tuple_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let t0 : Lean_tests.Structs.T0 ← (pure Lean_tests.Structs.T0.mk);
  let t1 : (Lean_tests.Structs.T1 i32) ← (pure
    (Lean_tests.Structs.T1.mk (1 : i32)));
  let t2 : (Lean_tests.Structs.T2 i32 i32) ← (pure
    (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)));
  let
    t3 : (Lean_tests.Structs.T3
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T1.mk (1 : i32))
      (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32))));
  let
    t3p : (Lean_tests.Structs.T3p
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3p.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T2.mk
        (Lean_tests.Structs.T1.mk (1 : i32))
        (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)))));
  let (⟨⟩ : Lean_tests.Structs.T0) ← (pure t0);
  let (⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)) ← (pure t1);
  let (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32)) ← (pure t2);
  let
    (⟨(⟨⟩ : Lean_tests.Structs.T0),
      (⟨(_ : i32)⟩ : (Lean_tests.Structs.T1 i32)),
      (⟨(_ : i32), (_ : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
    (Lean_tests.Structs.T3
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32))) ← (pure t3);
  let
    (⟨(⟨⟩ : Lean_tests.Structs.T0),
      (⟨(⟨(_ : i32)⟩ : (Lean_tests.Structs.T1 i32)),
        (⟨(_ : i32), (_ : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
      (Lean_tests.Structs.T2
        (Lean_tests.Structs.T1 i32)
        (Lean_tests.Structs.T2 i32 i32)))⟩ : (Lean_tests.Structs.T3p
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32))) ← (pure t3p);
  let (_ : i32) ← (pure (Lean_tests.Structs.T1._0 t1));
  let (_ : i32) ← (pure (Lean_tests.Structs.T2._0 t2));
  let (_ : i32) ← (pure (Lean_tests.Structs.T2._1 t2));
  let (_ : Lean_tests.Structs.T0) ← (pure (Lean_tests.Structs.T3._0 t3));
  let (_ : (Lean_tests.Structs.T1 i32)) ← (pure (Lean_tests.Structs.T3._1 t3));
  let (_ : (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3._2 t3));
  let (_ : i32) ← (pure
    (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3._2 t3)));
  let (_ : Lean_tests.Structs.T0) ← (pure (Lean_tests.Structs.T3p._0 t3p));
  let
    (_ : (Lean_tests.Structs.T2
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32))) ← (pure
    (Lean_tests.Structs.T3p._1 t3p));
  let (_ : i32) ← (pure
    (Lean_tests.Structs.T2._0
        (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p))));
  let (_ : (Lean_tests.Structs.T1 i32)) ← (pure
    (Lean_tests.Structs.T2._0 (Lean_tests.Structs.T3p._1 t3p)));
  let (_ : (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p)));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match t0 with | ⟨⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match t1 with | ⟨(u1 : i32)⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match t2 with
      | ⟨(u2 : i32), (u3 : i32)⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match t3 with
      | ⟨(⟨⟩ : Lean_tests.Structs.T0),
         (⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)),
         (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩
        => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match t3p with
      | ⟨(⟨⟩ : Lean_tests.Structs.T0),
         (⟨(⟨(u1 : i32)⟩ : (Lean_tests.Structs.T1 i32)),
           (⟨(u2 : i32), (u3 : i32)⟩ : (Lean_tests.Structs.T2 i32 i32))⟩ :
         (Lean_tests.Structs.T2
           (Lean_tests.Structs.T1 i32)
           (Lean_tests.Structs.T2 i32 i32)))⟩
        => do Rust_primitives.Hax.Tuple0.mk));
  Rust_primitives.Hax.Tuple0.mk

structure Lean_tests.Structs.S1 where
  f1 : usize
  f2 : usize

structure Lean_tests.Structs.S2 where
  f1 : Lean_tests.Structs.S1
  f2 : usize

structure Lean_tests.Structs.S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

def Lean_tests.Structs.normal_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let s1 : Lean_tests.Structs.S1 ← (pure
    (Lean_tests.Structs.S1.mk (f1 := (0 : usize)) (f2 := (1 : usize))));
  let s2 : Lean_tests.Structs.S2 ← (pure
    (Lean_tests.Structs.S2.mk
      (f1 := (Lean_tests.Structs.S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
      (f2 := (4 : usize))));
  let s3 : Lean_tests.Structs.S3 ← (pure
    (Lean_tests.Structs.S3.mk
      (_end := (0 : usize))
      (_def := (0 : usize))
      (_theorem := (0 : usize))
      (_structure := (0 : usize))
      (_inductive := (0 : usize))));
  let ({f1 := (f1 : usize), f2 := (f2 : usize)} : Lean_tests.Structs.S1) ← (pure
    s1);
  let
    ({f1 := (f1 : usize), f2 := (other_name_for_f2 : usize)} :
    Lean_tests.Structs.S1) ← (pure s1);
  let
    ({f1 := ({f1 := (f1 : usize), f2 := (f2 : usize)} : Lean_tests.Structs.S1),
      f2 := (other_name_for_f2 : usize)} : Lean_tests.Structs.S2) ← (pure s2);
  let
    ({_end := (_end : usize),
      _def := (_def : usize),
      _theorem := (_theorem : usize),
      _structure := (_structure : usize),
      _inductive := (_inductive : usize)} : Lean_tests.Structs.S3) ← (pure s3);
  let (_ : (Rust_primitives.Hax.Tuple2 usize usize)) ← (pure
    (Rust_primitives.Hax.Tuple2.mk
      (Lean_tests.Structs.S1.f1 s1) (Lean_tests.Structs.S1.f2 s1)));
  let
    (_ : (Rust_primitives.Hax.Tuple8
      usize
      usize
      usize
      usize
      usize
      usize
      usize
      usize)) ← (pure
    (Rust_primitives.Hax.Tuple8.mk
      (Lean_tests.Structs.S1.f1 s1)
      (Lean_tests.Structs.S1.f2 s1)
      (Lean_tests.Structs.S1.f1 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S1.f2 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S2.f2 s2)
      (Lean_tests.Structs.S3._end s3)
      (Lean_tests.Structs.S3._def s3)
      (Lean_tests.Structs.S3._theorem s3)));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match s1 with
      | {f1 := (f1 : usize), f2 := (f2 : usize)}
        => do Rust_primitives.Hax.Tuple0.mk));
  let (_ : Rust_primitives.Hax.Tuple0) ← (pure
    (match s2 with
      | {f1 := ({f1 := (f1 : usize), f2 := (other_name_for_f2 : usize)} :
         Lean_tests.Structs.S1),
         f2 := (f2 : usize)}
        => do Rust_primitives.Hax.Tuple0.mk));
  (match s3 with
    | {_end := (_end : usize),
       _def := (_def : usize),
       _theorem := (_theorem : usize),
       _structure := (_structure : usize),
       _inductive := (_inductive : usize)}
      => do Rust_primitives.Hax.Tuple0.mk)

inductive Lean_tests.Enums.E : Type
| V1 : Lean_tests.Enums.E 
| V2 : Lean_tests.Enums.E 
| V3 : usize -> Lean_tests.Enums.E 
| V4 : usize -> usize -> usize -> Lean_tests.Enums.E 
| V5 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E 
| V6 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E 


inductive Lean_tests.Enums.MyList (T : Type) : Type
| Nil : Lean_tests.Enums.MyList (T : Type) 
| Cons (hd : T)
       (tl : (Alloc.Boxed.Box (Lean_tests.Enums.MyList T) Alloc.Alloc.Global))
    : Lean_tests.Enums.MyList (T : Type) 


def Lean_tests.Enums.enums
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let e_v1 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V1);
  let e_v2 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V2);
  let e_v3 : Lean_tests.Enums.E ← (pure (Lean_tests.Enums.E.V3 (23 : usize)));
  let e_v4 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V4 (23 : usize) (12 : usize) (1 : usize)));
  let e_v5 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V5 (f1 := (23 : usize)) (f2 := (43 : usize))));
  let e_v6 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V6 (f1 := (12 : usize)) (f2 := (13 : usize))));
  let (nil : (Lean_tests.Enums.MyList usize)) ← (pure
    Lean_tests.Enums.MyList.Nil);
  let cons_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (1 : usize)) (tl := nil)));
  let cons_2_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (2 : usize)) (tl := cons_1)));
  (match e_v1 with
    | (Lean_tests.Enums.E.V1 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V2 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V3 (_ : usize)) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V4 (x1 : usize) (x2 : usize) (x3 : usize))
      => do
        let y1 : usize ← (pure (← x1 +? x2));
        let y2 : usize ← (pure (← y1 -? x2));
        let y3 : usize ← (pure (← y2 +? x3));
        Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V5 (f1 := (f1 : usize)) (f2 := (f2 : usize)))
      => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V6
        (f1 := (f1 : usize)) (f2 := (other_name_for_f2 : usize)))
      => do Rust_primitives.Hax.Tuple0.mk)

def Lean_tests.FORTYTWO : usize := 42

def Lean_tests.MINUS_FORTYTWO : isize := -42

def Lean_tests.returns42 (_ : Rust_primitives.Hax.Tuple0) : Result usize := do
  Lean_tests.FORTYTWO

def Lean_tests.add_two_numbers (x : usize) (y : usize) : Result usize := do
  (← x +? y)

def Lean_tests.letBinding (x : usize) (y : usize) : Result usize := do
  let useless : Rust_primitives.Hax.Tuple0 ← (pure
    Rust_primitives.Hax.Tuple0.mk);
  let result1 : usize ← (pure (← x +? y));
  let result2 : usize ← (pure (← result1 +? (2 : usize)));
  (← result2 +? (1 : usize))

def Lean_tests.closure (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (41 : i32));
  let f1 : i32 -> Result i32 ← (pure
    (fun (y : i32) => (do (← y +? x) : Result i32)));
  let f2 : i32 -> i32 -> Result i32 ← (pure
    (fun (y : i32) (z : i32) => (do (← (← y +? x) +? z) : Result i32)));
  let res1 : i32 ← (pure
    (← Core.Ops.Function.Fn.call f1 (Rust_primitives.Hax.Tuple1.mk (1 : i32))));
  let res2 : i32 ← (pure
    (← Core.Ops.Function.Fn.call
        f2
        (Rust_primitives.Hax.Tuple2.mk (2 : i32) (3 : i32))));
  (← res1 +? res2)

@[spec]

def Lean_tests.test_before_verbatime_single_line (x : u8) : Result u8 := do
  (42 : u8)


def multiline : Unit := ()


def Lean_tests.test_before_verbatim_multi_line (x : u8) : Result u8 := do
  (32 : u8)

def Lean_tests.binop_resugarings (x : u32) : Result u32 := do
  let add : u32 ← (pure (← x +? (1 : u32)));
  let sub : u32 ← (pure (← add -? (2 : u32)));
  let mul : u32 ← (pure (← sub *? (3 : u32)));
  let rem : u32 ← (pure (← mul %? (4 : u32)));
  let div : u32 ← (pure (← rem /? (5 : u32)));
  let rshift : u32 ← (pure (← div >>>? x));
  x'''
