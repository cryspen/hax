---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false


namespace lean_tests.array

@[spec]
def f (N : usize) (x : (RustArray u8 N)) :
    RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def g (N : usize) (x : (RustArray u8 N)) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ ← (f (N) x);
  let _ ←
    (f ((10 : usize)) (← (rust_primitives.hax.repeat (0 : u8) (10 : usize))));
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.array


namespace lean_tests.associated_types.projection

class T1.AssociatedTypes (Self : Type) where
  A1 : Type

attribute [reducible] T1.AssociatedTypes.A1

abbrev T1.A1 :=
  T1.AssociatedTypes.A1

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where

end lean_tests.associated_types.projection


namespace lean_tests.associated_types.multiple_projections

class FnOnce.AssociatedTypes (Self : Type) (T : Type) where
  Output : Type

attribute [reducible] FnOnce.AssociatedTypes.Output

abbrev FnOnce.Output :=
  FnOnce.AssociatedTypes.Output

class FnOnce (Self : Type) (T : Type)
  [associatedTypes : outParam (FnOnce.AssociatedTypes (Self : Type) (T : Type))]
  where

@[spec]
def func
    (T : Type)
    (U : Type)
    (D : Type)
    (F : Type)
    [trait_constr_func_associated_type_i0 : FnOnce.AssociatedTypes F T]
    [trait_constr_func_i0 : FnOnce
      F
      T
      (associatedTypes := {
        show FnOnce.AssociatedTypes F T
        by infer_instance
        with Output := U})]
    [trait_constr_func_associated_type_i1 : FnOnce.AssociatedTypes D T]
    [trait_constr_func_i1 : FnOnce
      D
      T
      (associatedTypes := {
        show FnOnce.AssociatedTypes D T
        by infer_instance
        with Output := U})]
    (d : D)
    (f : F)
    (u : U) :
    RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.associated_types.multiple_projections


namespace lean_tests.casts

--  Returns true if all casting edge cases behave as expected.
def casting_edge_cases (_dummy : Bool) : RustM Bool := do
  let case1 : Bool ←
    (rust_primitives.hax.machine_int.eq
      (← (rust_primitives.hax.cast_op (256 : u16) : RustM u8))
      (0 : u8));
  let case2 : Bool ←
    (rust_primitives.hax.machine_int.eq
      (← (rust_primitives.hax.cast_op (-1 : i16) : RustM u8))
      (255 : u8));
  let case3 : Bool ←
    (rust_primitives.hax.machine_int.eq
      (← (rust_primitives.hax.cast_op (-1 : i8) : RustM i16))
      (-1 : i16));
  let case4 : Bool ←
    (rust_primitives.hax.machine_int.eq
      (← (rust_primitives.hax.cast_op (128 : u8) : RustM i8))
      (-128 : i8));
  let case5 : Bool ←
    (rust_primitives.hax.machine_int.eq
      (← (rust_primitives.hax.cast_op (4294967295 : u32) : RustM i32))
      (-1 : i32));
  ((← ((← ((← (case1 &&? case2)) &&? case3)) &&? case4)) &&? case5)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def casting_edge_cases.spec (_dummy : Bool) :
    Spec
      (requires := do pure True)
      (ensures := fun result => do (pure result))
      (casting_edge_cases (_dummy : Bool)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [casting_edge_cases] <;> bv_decide
}

--  https://github.com/cryspen/hax/issues/1912
@[spec]
def shift_after_cast (x : u16) (n : u8) : RustM u32 := do
  ((← (rust_primitives.hax.cast_op x : RustM u32))
    <<<? (← (rust_primitives.hax.cast_op n : RustM u32)))

--  https://github.com/cryspen/hax/issues/1911
@[spec]
def add_after_cast (a : u8) (b : u8) (c : u8) : RustM u16 := do
  ((← ((← (rust_primitives.hax.cast_op a : RustM u16))
      +? (← (rust_primitives.hax.cast_op b : RustM u16))))
    +? (← (rust_primitives.hax.cast_op c : RustM u16)))

end lean_tests.casts


namespace lean_tests.comments

--  Single line doc comment
@[spec]
def f (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

/--
   Block doc-comment : Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum rutrum
  orci ac tellus ullamcorper sollicitudin. Sed fringilla mi id arcu suscipit rhoncus. Pellentesque et
  metus a ante feugiat lobortis. Nam a mauris eget nisl congue egestas. Duis et gravida
  nulla. Curabitur mattis leo vel molestie posuere. Etiam malesuada et augue eget
  varius. Pellentesque quis tincidunt erat. Vestibulum id consectetur turpis. Cras elementum magna id
  urna volutpat fermentum. In vel erat quis nunc rhoncus porta. Aliquam sed pellentesque
  tellus. Quisque odio diam, mollis ut venenatis non, scelerisque at nulla. Nunc urna ante, tristique
  quis nisi quis, congue maximus nisl. Curabitur non efficitur odio. 
  -/
@[spec]
def heavily_documented (_ : rust_primitives.hax.Tuple0) : RustM u32 := do
  (pure (4 : u32))

end lean_tests.comments


namespace lean_tests.constants

def C1 : u32 := (5678 : u32)

def C2 : u32 := RustM.of_isOk (do (C1 +? (1 : u32))) (by rfl)

def C3 : u32 :=
  RustM.of_isOk
    (do if true then do (pure (890 : u32)) else do ((9 : u32) /? (0 : u32)))
    (by rfl)

@[spec]
def computation (x : u32) : RustM u32 := do ((← (x +? x)) +? (1 : u32))

def C4 : u32 := RustM.of_isOk (do ((← (computation C1)) +? C2)) (by rfl)

@[spec]
def test (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let x : u32 ← (C1 +? (1 : u32));
  let y : u32 ← (C2 +? C3);
  let z : u32 ← (C4 -? C3);
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.constants


namespace lean_tests.constants.const_parameters

--  Function with const parameter
@[spec]
def f (N : usize) (_ : rust_primitives.hax.Tuple0) : RustM usize := do (pure N)

def N0 : usize := (1 : usize)

def N1 : usize := (10 : usize)

@[spec]
def test (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ ←
    ((← (f ((9 : usize)) rust_primitives.hax.Tuple0.mk))
      +? (← (f ((10 : usize)) rust_primitives.hax.Tuple0.mk)));
  (pure rust_primitives.hax.Tuple0.mk)

--  Trait definition
class T.AssociatedTypes (Self : Type) (N_TRAIT : usize) where

class T (Self : Type) (N_TRAIT : usize)
  [associatedTypes : outParam (T.AssociatedTypes (Self : Type) (N_TRAIT :
      usize))]
  where
  f (Self) (N_TRAIT) (N_FIELD : usize) : (Self -> RustM usize)

--  Struct definition
structure S (N : usize) where
  _0 : u32

@[reducible] instance Impl.AssociatedTypes (N_TRAIT : usize) :
  T.AssociatedTypes (S (N_TRAIT)) (N_TRAIT)
  where

instance Impl (N_TRAIT : usize) : T (S (N_TRAIT)) (N_TRAIT) where
  f := fun (N_FIELD : usize) (self : (S (N_TRAIT))) => do (N_TRAIT -? N_FIELD)

@[spec]
def test2
    (N2 : usize)
    (A : Type)
    [trait_constr_test2_associated_type_i0 : T.AssociatedTypes A (N2)]
    [trait_constr_test2_i0 : T A (N2) ]
    (x : A) :
    RustM usize := do
  let s : (S ((10 : usize))) := (S.mk (9 : u32));
  let _ ←
    ((← (T.f (S ((10 : usize))) ((10 : usize)) ((1 : usize)) s))
      +? (← (T.f A (N2) ((11 : usize)) x)));
  let s : (S ((3 : usize))) := (S.mk (9 : u32));
  (T.f A (N2) ((4 : usize)) x)

end lean_tests.constants.const_parameters


namespace lean_tests.enums

inductive E : Type
| V1 : E
| V2 : E
| V3 : usize -> E
| V4 : usize -> usize -> usize -> E
| V5 (f1 : usize) (f2 : usize) : E
| V6 (f1 : usize) (f2 : usize) : E

end lean_tests.enums


namespace lean_tests.floats

def N : f32 := (1.0 : f32)

@[spec]
def test (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let l0 : f64 := (1.0 : f64);
  let l1 : f64 := (0.9 : f64);
  let l2 : f32 := (5.0 : f32);
  let l5 : f32 := N;
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def f (x : f64) (y : f32) : RustM f32 := do (pure y)

end lean_tests.floats


namespace lean_tests.ite

@[spec]
def test1 (_ : rust_primitives.hax.Tuple0) : RustM i32 := do
  let x : i32 ← if true then do (pure (0 : i32)) else do (pure (1 : i32));
  if false then do (pure (2 : i32)) else do (pure (3 : i32))

@[spec]
def test2 (b : Bool) : RustM i32 := do
  let x : i32 ← if b then do (pure (0 : i32)) else do (pure (9 : i32));
  let y : i32 := (0 : i32);
  let y : i32 ←
    if true then do
      ((← (y +? x)) +? (1 : i32))
    else do
      ((← (y -? x)) -? (1 : i32));
  if b then do
    let z : i32 ← (y +? y);
    ((← (z +? y)) +? x)
  else do
    let z : i32 ← (y -? x);
    ((← (z +? y)) +? x)

end lean_tests.ite


namespace lean_tests.loops

@[spec]
def loop1 (_ : rust_primitives.hax.Tuple0) : RustM u32 := do
  let x : u32 := (0 : u32);
  let x : u32 ←
    (rust_primitives.hax.folds.fold_range
      (1 : u32)
      (10 : u32)
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i => (do (x +? i) : RustM u32)));
  (pure x)

@[spec]
def loop2 (_ : rust_primitives.hax.Tuple0) : RustM u32 := do
  let x : u32 := (0 : u32);
  match
    (← (rust_primitives.hax.folds.fold_range_return
      (1 : u32)
      (10 : u32)
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i =>
        (do
        if (← (rust_primitives.hax.machine_int.eq i (5 : u32))) then do
          (pure (core_models.ops.control_flow.ControlFlow.Break
            (core_models.ops.control_flow.ControlFlow.Break x)))
        else do
          (pure (core_models.ops.control_flow.ControlFlow.Continue
            (← (x +? i)))) :
        RustM
        (core_models.ops.control_flow.ControlFlow
          (core_models.ops.control_flow.ControlFlow
            u32
            (rust_primitives.hax.Tuple2 rust_primitives.hax.Tuple0 u32))
          u32)))))
  with
    | (core_models.ops.control_flow.ControlFlow.Break  ret) => do (pure ret)
    | (core_models.ops.control_flow.ControlFlow.Continue  x) => do (pure x)

def while_loop1 (s : u32) : RustM u32 := do
  let x : u32 := s;
  let x : u32 ←
    (rust_primitives.hax.while_loop
      (fun x => (do (pure true) : RustM Bool))
      (fun x =>
        (do (rust_primitives.hax.machine_int.gt x (0 : u32)) : RustM Bool))
      (fun x =>
        (do (rust_primitives.hax.int.from_machine x) : RustM hax_lib.int.Int))
      x
      (fun x => (do let x : u32 ← (x -? (1 : u32)); (pure x) : RustM u32)));
  (pure x)

set_option hax_mvcgen.specset "int" in
@[hax_spec]
def while_loop1.spec (s : u32) :
    Spec
      (requires := do pure True)
      (ensures := fun r => do (rust_primitives.hax.machine_int.eq r (0 : u32)))
      (while_loop1 (s : u32)) := {
  pureRequires := by hax_construct_pure <;> grind
  pureEnsures := by hax_construct_pure <;> grind
  contract := by hax_mvcgen [while_loop1] <;> grind
}

end lean_tests.loops


namespace lean_tests.loops.errors

inductive Error : Type
| Foo : Error
| Bar : u32 -> Error

@[spec]
def loop3 (_ : rust_primitives.hax.Tuple0) :
    RustM (core_models.result.Result u32 Error) := do
  let x : u32 := (0 : u32);
  let _end : u32 := (10 : u32);
  match
    (← (rust_primitives.hax.folds.fold_range_return
      (1 : u32)
      _end
      (fun x _ => (do (pure true) : RustM Bool))
      x
      (fun x i =>
        (do
        if (← (rust_primitives.hax.machine_int.eq i (5 : u32))) then do
          (pure (core_models.ops.control_flow.ControlFlow.Break
            (core_models.ops.control_flow.ControlFlow.Break
              (core_models.result.Result.Err Error.Foo))))
        else do
          (pure (core_models.ops.control_flow.ControlFlow.Continue
            (← (x +? (5 : u32))))) :
        RustM
        (core_models.ops.control_flow.ControlFlow
          (core_models.ops.control_flow.ControlFlow
            (core_models.result.Result u32 Error)
            (rust_primitives.hax.Tuple2 rust_primitives.hax.Tuple0 u32))
          u32)))))
  with
    | (core_models.ops.control_flow.ControlFlow.Break  ret) => do (pure ret)
    | (core_models.ops.control_flow.ControlFlow.Continue  x) => do
      (pure (core_models.result.Result.Ok x))

@[spec]
def loop4 (_ : rust_primitives.hax.Tuple0) :
    RustM
    (core_models.result.Result (rust_primitives.hax.Tuple2 u32 u32) Error)
    := do
  let e : u32 := (0 : u32);
  let f : (rust_primitives.hax.Tuple0 -> RustM u32) :=
    (fun ⟨⟩ => (do (pure (42 : u32)) : RustM u32));
  match
    (← (rust_primitives.hax.folds.fold_range_return
      (0 : u32)
      (← (core_models.ops.function.Fn.call
        (rust_primitives.hax.Tuple0 -> RustM u32)
        (rust_primitives.hax.Tuple1 rust_primitives.hax.Tuple0)
        f
        (rust_primitives.hax.Tuple1.mk rust_primitives.hax.Tuple0.mk)))
      (fun e _ => (do (pure true) : RustM Bool))
      e
      (fun e i =>
        (do
        if (← (rust_primitives.hax.machine_int.gt i (10 : u32))) then do
          (pure (core_models.ops.control_flow.ControlFlow.Break
            (core_models.ops.control_flow.ControlFlow.Break
              (core_models.result.Result.Err (Error.Bar e)))))
        else do
          (pure (core_models.ops.control_flow.ControlFlow.Continue
            (← (e +? i)))) :
        RustM
        (core_models.ops.control_flow.ControlFlow
          (core_models.ops.control_flow.ControlFlow
            (core_models.result.Result
              (rust_primitives.hax.Tuple2 u32 u32)
              Error)
            (rust_primitives.hax.Tuple2 rust_primitives.hax.Tuple0 u32))
          u32)))))
  with
    | (core_models.ops.control_flow.ControlFlow.Break  ret) => do (pure ret)
    | (core_models.ops.control_flow.ControlFlow.Continue  e) => do
      (pure (core_models.result.Result.Ok (rust_primitives.hax.Tuple2.mk e e)))

end lean_tests.loops.errors


namespace lean_tests.matching

@[spec]
def test_const_matching (x : u32) (c : Char) (s : String) (b : Bool) :
    RustM u32 := do
  let x : u32 ←
    match x with | 0 => do (pure (42 : u32)) | _ => do (pure (0 : u32));
  let c : u32 ←
    match c with | 'a' => do (pure (42 : u32)) | _ => do (pure (0 : u32));
  let s : u32 ←
    match s with | "Hello" => do (pure (42 : u32)) | _ => do (pure (0 : u32));
  let b : u32 ←
    match b with | true => do (pure (42 : u32)) | false => do (pure (0 : u32));
  ((← ((← (x +? c)) +? s)) +? b)

@[spec]
def test_binding_subpattern_matching
    (x : (rust_primitives.hax.Tuple2 u8 (rust_primitives.hax.Tuple2 u8 u8))) :
    RustM u8 := do
  match x with
    | ⟨0, pair@⟨a, b⟩⟩ => do
      ((← ((← (a +? b)) +? (rust_primitives.hax.Tuple2._0 pair)))
        +? (rust_primitives.hax.Tuple2._1 pair))
    | _ => do (pure (0 : u8))

end lean_tests.matching


namespace lean_tests.monadic

structure S where
  f : u32

@[spec]
def test (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ := (9 : i32);
  let _ ← ((9 : i32) +? (9 : i32));
  let _ := (S.mk (f := (9 : u32)));
  let _ := (S.mk (f := (← ((9 : u32) +? (9 : u32)))));
  let _ := (S.f (S.mk (f := (← ((9 : u32) +? (9 : u32))))));
  let _ ← ((S.f (S.mk (f := (← ((9 : u32) +? (9 : u32)))))) +? (9 : u32));
  let _ ←
    if true then do ((3 : i32) +? (4 : i32)) else do ((3 : i32) -? (4 : i32));
  let _ ←
    if
    (← (rust_primitives.hax.machine_int.eq
      (← ((9 : i32) +? (9 : i32)))
      (0 : i32))) then do
      ((3 : i32) +? (4 : i32))
    else do
      ((3 : i32) -? (4 : i32));
  let _ ←
    if true then do
      let x : i32 := (9 : i32);
      let _ ← ((3 : i32) +? x);
      (pure rust_primitives.hax.Tuple0.mk)
    else do
      let y : i32 := (19 : i32);
      let _ ← ((← ((3 : i32) +? y)) -? (4 : i32));
      (pure rust_primitives.hax.Tuple0.mk);
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.monadic


namespace lean_tests.monadic.trait_constants

class Foo.AssociatedTypes (Self : Type) where

class Foo (Self : Type)
  [associatedTypes : outParam (Foo.AssociatedTypes (Self : Type))]
  where
  F (Self) : u32

class Bar.AssociatedTypes (Self : Type) where

class Bar (Self : Type)
  [associatedTypes : outParam (Bar.AssociatedTypes (Self : Type))]
  where
  B (Self) : u32

structure Baz where
  -- no fields

@[reducible] instance Impl.AssociatedTypes : Foo.AssociatedTypes Baz where

instance Impl : Foo Baz where
  F := (1 : u32)

@[reducible] instance Impl_1.AssociatedTypes : Bar.AssociatedTypes Baz where

instance Impl_1 : Bar Baz where
  B := RustM.of_isOk (do ((Foo.F Baz) -? (1 : u32))) (by rfl)

end lean_tests.monadic.trait_constants


namespace lean_tests.nested_control_flow

@[spec]
def nested_control_flow (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let x1 : i32 ←
    ((1 : i32)
      +? (← if true then do (pure (0 : i32)) else do (pure (1 : i32))));
  let x2 : i32 ←
    ((1 : i32)
      +? (← match (rust_primitives.hax.Tuple2.mk (1 : i32) (2 : i32)) with
        | _ => do (pure (0 : i32))));
  let x : i32 := (9 : i32);
  let x3 : i32 ← ((1 : i32) +? (← (x +? (1 : i32))));
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def explicit_hoisting (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let x1_tmp : i32 ← if true then do (pure (0 : i32)) else do (pure (1 : i32));
  let x1 : i32 ← ((1 : i32) +? x1_tmp);
  let x2_tmp : i32 ←
    match (rust_primitives.hax.Tuple2.mk (1 : i32) (2 : i32)) with
      | _ => do (pure (0 : i32));
  let x2 : i32 ← ((1 : i32) +? x2_tmp);
  let x3_tmp_x : i32 := (9 : i32);
  let x3_tmp : i32 ← (x3_tmp_x +? (1 : i32));
  let x3 : i32 ← ((1 : i32) +? x3_tmp);
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def complex_nesting (_ : rust_primitives.hax.Tuple0) :
    RustM
    (rust_primitives.hax.Tuple2
      rust_primitives.hax.Tuple0
      rust_primitives.hax.Tuple0)
    := do
  let x1 : i32 ←
    if true then do
      let y : i32 ←
        if false then do
          let z : i32 ←
            match rust_primitives.hax.Tuple0.mk with | _ => do (pure (9 : i32));
          let z : i32 ← ((1 : i32) +? z);
          (z +? (1 : i32))
        else do
          let z : i32 := (9 : i32);
          let z : i32 ← (z +? (1 : i32));
          (pure z);
      let y : i32 ← (y +? (1 : i32));
      (y +? (1 : i32))
    else do
      (pure (0 : i32));
  let x1 : i32 ← (x1 +? (1 : i32));
  let x2 : i32 ←
    match (core_models.option.Option.Some (89 : i32)) with
      | (core_models.option.Option.Some  a) => do
        let y : i32 ← ((1 : i32) +? a);
        let y : i32 ← (y +? (1 : i32));
        if (← (rust_primitives.hax.machine_int.eq y (0 : i32))) then do
          let z : i32 := (9 : i32);
          let z : i32 ← ((← (z +? y)) +? (1 : i32));
          (pure z)
        else do
          (pure (10 : i32))
      | (core_models.option.Option.None ) => do
        let y : i32 ←
          if false then do
            (pure (9 : i32))
          else do
            let z : i32 := (9 : i32);
            let z : i32 ← (z +? (1 : i32));
            (z +? (9 : i32));
        let y : i32 ← (y +? (1 : i32));
        (pure y);
  (pure (rust_primitives.hax.Tuple2.mk
    rust_primitives.hax.Tuple0.mk
    rust_primitives.hax.Tuple0.mk))

end lean_tests.nested_control_flow


namespace lean_tests.opaque

opaque an_opaque_fn (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 

class T.AssociatedTypes (Self : Type) where
  A : Type

attribute [reducible] T.AssociatedTypes.A

abbrev T.A :=
  T.AssociatedTypes.A

class T (Self : Type)
  [associatedTypes : outParam (T.AssociatedTypes (Self : Type))]
  where
  f (Self) : (rust_primitives.hax.Tuple0 -> RustM rust_primitives.hax.Tuple0)

structure S where
  -- no fields

@[instance] opaque Impl.AssociatedTypes :
  T.AssociatedTypes S :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl : T S := by constructor <;> exact Inhabited.default

opaque OpaqueStruct : Type

end lean_tests.opaque


namespace lean_tests.specs

def test (x : u8) : RustM u8 := do (pure x)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def test.spec (x : u8) :
    Spec
      (requires := do (rust_primitives.hax.machine_int.gt x (0 : u8)))
      (ensures := fun r => do (rust_primitives.hax.machine_int.eq r x))
      (test (x : u8)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [test] <;> bv_decide
}

def use_previous_result (x : u8) : RustM u8 := do (test x)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def use_previous_result.spec (x : u8) :
    Spec
      (requires := do (rust_primitives.hax.machine_int.gt x (0 : u8)))
      (ensures := fun r => do (rust_primitives.hax.machine_int.eq r x))
      (use_previous_result (x : u8)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [use_previous_result] <;> bv_decide
}

def test_proof (x : u8) : RustM u8 := do (pure x)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def test_proof.spec (x : u8) :
    Spec
      (requires := do (rust_primitives.hax.machine_int.gt x (0 : u8)))
      (ensures := fun r => do (rust_primitives.hax.machine_int.eq r x))
      (test_proof (x : u8)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by unfold lean_tests.specs.test_proof; hax_bv_decide
}

def square (x : u8) : RustM u8 := do (x *? x)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def square.spec (x : u8) :
    Spec
      (requires := do (rust_primitives.hax.machine_int.lt x (16 : u8)))
      (ensures := fun res => do (rust_primitives.hax.machine_int.ge res x))
      (square (x : u8)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [square] <;> bv_decide
}

def forall_and_exists (x : u8) : RustM u8 := do (pure x)

set_option hax_mvcgen.specset "int" in
@[hax_spec]
def forall_and_exists.spec (x : u8) :
    Spec
      (requires := do
        (hax_lib.prop.constructors.forall
          (fun i =>
            (do
            (hax_lib.prop.constructors.implies
              (← (hax_lib.prop.constructors.from_bool
                (← (rust_primitives.hax.machine_int.lt i (20 : u8)))))
              (← (hax_lib.prop.constructors.from_bool
                (← (rust_primitives.hax.machine_int.gt x i))))) :
            RustM hax_lib.prop.Prop))))
      (ensures := fun
          r => do
          (hax_lib.prop.constructors.not
            (← (hax_lib.prop.constructors.exists
              (fun i =>
                (do
                (hax_lib.prop.constructors.not
                  (← (hax_lib.prop.constructors.implies
                    (← (hax_lib.prop.constructors.from_bool
                      (← (rust_primitives.hax.machine_int.lt i (20 : u8)))))
                    (← (hax_lib.prop.constructors.from_bool
                      (← (rust_primitives.hax.machine_int.gt r i))))))) :
                RustM hax_lib.prop.Prop))))))
      (forall_and_exists (x : u8)) := {
  pureRequires := by hax_construct_pure <;> grind
  pureEnsures := by hax_construct_pure <;> grind
  contract := by hax_mvcgen [forall_and_exists] <;> grind
}

--  Test function without arguments
--  https://github.com/cryspen/hax/issues/1856
def fn_without_args (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def fn_without_args.spec (_ : rust_primitives.hax.Tuple0) :
    Spec
      (requires := do pure True)
      (ensures := fun _ => do (pure true))
      (fn_without_args ⟨⟩) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [fn_without_args] <;> bv_decide
}

end lean_tests.specs


namespace lean_tests.specs.issue_1852

structure T where
  -- no fields

@[spec]
def Impl.test (self : T) : RustM Bool := do (pure true)

def Impl.func (self : T) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def Impl.func.spec (self : T) :
    Spec
      (requires := do (Impl.test self))
      (ensures := fun _ => pure True)
      (Impl.func (self : T)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [Impl.func] <;> bv_decide
}

end lean_tests.specs.issue_1852


namespace lean_tests.specs

def custom_pure_proofs (x : u8) : RustM rust_primitives.hax.Tuple0 := do
  (pure rust_primitives.hax.Tuple0.mk)

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def custom_pure_proofs.spec (x : u8) :
    Spec
      (requires := do (pure true))
      (ensures := fun r => do (pure true))
      (custom_pure_proofs (x : u8)) := {
  pureRequires := ⟨True, by mvcgen⟩
  pureEnsures := ⟨fun _ => True, by intros; mvcgen⟩
  contract := by hax_mvcgen [custom_pure_proofs] <;> bv_decide
}

end lean_tests.specs


namespace lean_tests.structs

structure T0 where
  -- no fields

structure T1 (A : Type) where
  _0 : A

structure T2 (A : Type) (B : Type) where
  _0 : A
  _1 : B

structure T3 (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : B
  _2 : C

structure T3p (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : (T2 B C)

@[spec]
def tuple_structs (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let t0 : T0 := T0.mk;
  let t1 : (T1 i32) := (T1.mk (1 : i32));
  let t2 : (T2 i32 i32) := (T2.mk (1 : i32) (2 : i32));
  let t3 : (T3 T0 (T1 i32) (T2 i32 i32)) :=
    (T3.mk T0.mk (T1.mk (1 : i32)) (T2.mk (1 : i32) (2 : i32)));
  let t3p : (T3p T0 (T1 i32) (T2 i32 i32)) :=
    (T3p.mk T0.mk (T2.mk (T1.mk (1 : i32)) (T2.mk (1 : i32) (2 : i32))));
  let ⟨⟩ := t0;
  let ⟨u1⟩ := t1;
  let ⟨u2, u3⟩ := t2;
  let ⟨⟨⟩, ⟨_⟩, ⟨_, _⟩⟩ := t3;
  let ⟨⟨⟩, ⟨⟨_⟩, ⟨_, _⟩⟩⟩ := t3p;
  let _ := (T1._0 t1);
  let _ := (T2._0 t2);
  let _ := (T2._1 t2);
  let _ := (T3._0 t3);
  let _ := (T3._1 t3);
  let _ := (T3._2 t3);
  let _ := (T2._1 (T3._2 t3));
  let _ := (T3p._0 t3p);
  let _ := (T3p._1 t3p);
  let _ := (T2._0 (T2._1 (T3p._1 t3p)));
  let _ := (T2._0 (T3p._1 t3p));
  let _ := (T2._1 (T3p._1 t3p));
  let _ ← match t0 with | ⟨⟩ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ← match t1 with | ⟨u1⟩ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ← match t2 with | ⟨u2, u3⟩ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ←
    match t3 with
      | ⟨⟨⟩, ⟨u1⟩, ⟨u2, u3⟩⟩ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ←
    match t3p with
      | ⟨⟨⟩, ⟨⟨u1⟩, ⟨u2, u3⟩⟩⟩ => do (pure rust_primitives.hax.Tuple0.mk);
  (pure rust_primitives.hax.Tuple0.mk)

structure S1 where
  f1 : usize
  f2 : usize

structure S2 where
  f1 : S1
  f2 : usize

structure S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

@[spec]
def normal_structs (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let s1 : S1 := (S1.mk (f1 := (0 : usize)) (f2 := (1 : usize)));
  let s2 : S2 :=
    (S2.mk
      (f1 := (S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
      (f2 := (4 : usize)));
  let s3 : S3 :=
    (S3.mk
      (_end := (0 : usize))
      (_def := (0 : usize))
      (_theorem := (0 : usize))
      (_structure := (0 : usize))
      (_inductive := (0 : usize)));
  let {f1 := f1, f2 := f2} := s1;
  let {f1 := f1, f2 := other_name_for_f2} := s1;
  let {f1 := {f1 := f1, f2 := f2}, f2 := other_name_for_f2} := s2;
  let
    {_end := _end,
     _def := _def,
     _theorem := _theorem,
     _structure := _structure,
     _inductive := _inductive} :=
    s3;
  let _ := (rust_primitives.hax.Tuple2.mk (S1.f1 s1) (S1.f2 s1));
  let _ :=
    (rust_primitives.hax.Tuple8.mk
      (S1.f1 s1)
      (S1.f2 s1)
      (S1.f1 (S2.f1 s2))
      (S1.f2 (S2.f1 s2))
      (S2.f2 s2)
      (S3._end s3)
      (S3._def s3)
      (S3._theorem s3));
  let _ ←
    match s1 with
      | {f1 := f1, f2 := f2} => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ←
    match s2 with
      | {f1 := {f1 := f1, f2 := other_name_for_f2}, f2 := f2} => do
        (pure rust_primitives.hax.Tuple0.mk);
  match s3 with
    | {_end := _end,
       _def := _def,
       _theorem := _theorem,
       _structure := _structure,
       _inductive := _inductive} => do
      (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.structs


namespace lean_tests.structs.miscellaneous

structure S where
  f : i32

@[spec]
def test_tuples (_ : rust_primitives.hax.Tuple0) :
    RustM (rust_primitives.hax.Tuple2 i32 i32) := do
  let lit : i32 := (1 : i32);
  let constr : S := (S.mk (f := (42 : i32)));
  let proj : i32 := (S.f constr);
  let ite : (rust_primitives.hax.Tuple2 i32 i32) ←
    if true then do
      (pure (rust_primitives.hax.Tuple2.mk (1 : i32) (2 : i32)))
    else do
      let z : i32 ← ((1 : i32) +? (2 : i32));
      (pure (rust_primitives.hax.Tuple2.mk z z));
  (pure (rust_primitives.hax.Tuple2.mk (1 : i32) (2 : i32)))

end lean_tests.structs.miscellaneous


namespace lean_tests.structs.base_expressions

structure S where
  f1 : u32
  f2 : u32
  f3 : u32

@[spec]
def test (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let s1 : S := (S.mk (f1 := (1 : u32)) (f2 := (2 : u32)) (f3 := (3 : u32)));
  let _ := {s1 with f1 := (0 : u32)};
  let _ := {s1 with f2 := (0 : u32)};
  let _ := {s1 with f3 := (0 : u32)};
  let _ := {s1 with f1 := (0 : u32), f2 := (1 : u32)};
  let _ := {s1 with f2 := (0 : u32), f3 := (1 : u32)};
  let _ := {s1 with f3 := (0 : u32), f1 := (2 : u32)};
  let _ := {s1 with f1 := (0 : u32), f2 := (1 : u32), f3 := (0 : u32)};
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.structs.base_expressions


namespace lean_tests.traits.basic

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f1 (Self) : (Self -> RustM usize)
  f2 (Self) : (Self -> Self -> RustM usize)

structure S where
  -- no fields

@[reducible] instance Impl.AssociatedTypes : T1.AssociatedTypes S where

instance Impl : T1 S where
  f1 := fun (self : S) => do (pure (42 : usize))
  f2 := fun (self : S) (other : S) => do (pure (43 : usize))

@[spec]
def f
    (T : Type)
    [trait_constr_f_associated_type_i0 : T1.AssociatedTypes T]
    [trait_constr_f_i0 : T1 T ]
    (x : T) :
    RustM usize := do
  ((← (T1.f1 T x)) +? (← (T1.f2 T x x)))

end lean_tests.traits.basic


namespace lean_tests.traits.bounds

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f1 (Self) : (Self -> RustM usize)

class T2.AssociatedTypes (Self : Type) where

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  f2 (Self) : (Self -> RustM usize)

class Test.AssociatedTypes (Self : Type) (T : Type) where
  [trait_constr_Test_i0 : T2.AssociatedTypes Self]
  [trait_constr_Test_i1 : T1.AssociatedTypes T]

attribute [instance] Test.AssociatedTypes.trait_constr_Test_i0

attribute [instance] Test.AssociatedTypes.trait_constr_Test_i1

class Test (Self : Type) (T : Type)
  [associatedTypes : outParam (Test.AssociatedTypes (Self : Type) (T : Type))]
  where
  [trait_constr_Test_i0 : T2 Self]
  [trait_constr_Test_i1 : T1 T]
  f_test (Self) (T) : (Self -> T -> RustM usize)

attribute [instance] Test.trait_constr_Test_i0

attribute [instance] Test.trait_constr_Test_i1

structure S1 where
  -- no fields

@[reducible] instance Impl.AssociatedTypes : T1.AssociatedTypes S1 where

instance Impl : T1 S1 where
  f1 := fun (self : S1) => do (pure (0 : usize))

structure S2 where
  -- no fields

@[reducible] instance Impl_1.AssociatedTypes : T2.AssociatedTypes S2 where

instance Impl_1 : T2 S2 where
  f2 := fun (self : S2) => do (pure (1 : usize))

@[reducible] instance Impl_2.AssociatedTypes : Test.AssociatedTypes S2 S1 where

instance Impl_2 : Test S2 S1 where
  f_test := fun (self : S2) (x : S1) => do
    ((← ((← (T1.f1 S1 x)) +? (← (T2.f2 S2 self)))) +? (1 : usize))

@[spec]
def test (x1 : S1) (x2 : S2) : RustM usize := do
  ((← (Test.f_test S2 S1 x2 x1)) +? (← (T1.f1 S1 x1)))

end lean_tests.traits.bounds


namespace lean_tests.traits.associated_types

class Foo.AssociatedTypes (Self : Type) (T : Type) where

class Foo (Self : Type) (T : Type)
  [associatedTypes : outParam (Foo.AssociatedTypes (Self : Type) (T : Type))]
  where

class Bar.AssociatedTypes (Self : Type) where

class Bar (Self : Type)
  [associatedTypes : outParam (Bar.AssociatedTypes (Self : Type))]
  where

structure S where
  -- no fields

@[reducible] instance Impl_2.AssociatedTypes : Bar.AssociatedTypes i16 where

instance Impl_2 : Bar i16 where

@[reducible] instance Impl_3.AssociatedTypes (A : Type) :
  Foo.AssociatedTypes (rust_primitives.hax.Tuple2 u32 A) i16
  where

instance Impl_3 (A : Type) : Foo (rust_primitives.hax.Tuple2 u32 A) i16 where

class Chain0.AssociatedTypes (Self : Type) where

class Chain0 (Self : Type)
  [associatedTypes : outParam (Chain0.AssociatedTypes (Self : Type))]
  where

@[reducible] instance Impl_4.AssociatedTypes : Chain0.AssociatedTypes u8 where

instance Impl_4 : Chain0 u8 where

end lean_tests.traits.associated_types


namespace lean_tests.traits.overlapping_methods

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f (Self) : (Self -> RustM usize)

class T2.AssociatedTypes (Self : Type) where

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  f (Self) : (Self -> RustM usize)

class T3.AssociatedTypes (Self : Type) where

class T3 (Self : Type)
  [associatedTypes : outParam (T3.AssociatedTypes (Self : Type))]
  where
  f (Self) : (Self -> RustM usize)

@[reducible] instance Impl.AssociatedTypes : T1.AssociatedTypes u32 where

instance Impl : T1 u32 where
  f := fun (self : u32) => do (pure (0 : usize))

@[reducible] instance Impl_1.AssociatedTypes : T2.AssociatedTypes u32 where

instance Impl_1 : T2 u32 where
  f := fun (self : u32) => do (pure (1 : usize))

@[reducible] instance Impl_2.AssociatedTypes : T3.AssociatedTypes u32 where

instance Impl_2 : T3 u32 where
  f := fun (self : u32) => do (pure (2 : usize))

@[spec]
def test (_ : rust_primitives.hax.Tuple0) : RustM usize := do
  let x : u32 := (9 : u32);
  ((← ((← (T1.f u32 x)) +? (← (T2.f u32 x)))) +? (← (T3.f u32 x)))

end lean_tests.traits.overlapping_methods


namespace lean_tests.traits.inheritance

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f1 (Self) : (Self -> RustM usize)

class T2.AssociatedTypes (Self : Type) where

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  f2 (Self) : (Self -> RustM usize)

class T3.AssociatedTypes (Self : Type) where
  [trait_constr_T3_i0 : T2.AssociatedTypes Self]
  [trait_constr_T3_i1 : T1.AssociatedTypes Self]

attribute [instance] T3.AssociatedTypes.trait_constr_T3_i0

attribute [instance] T3.AssociatedTypes.trait_constr_T3_i1

class T3 (Self : Type)
  [associatedTypes : outParam (T3.AssociatedTypes (Self : Type))]
  where
  [trait_constr_T3_i0 : T2 Self]
  [trait_constr_T3_i1 : T1 Self]
  f3 (Self) : (Self -> RustM usize)

attribute [instance] T3.trait_constr_T3_i0

attribute [instance] T3.trait_constr_T3_i1

class Tp1.AssociatedTypes (Self : Type) where

class Tp1 (Self : Type)
  [associatedTypes : outParam (Tp1.AssociatedTypes (Self : Type))]
  where
  f1 (Self) : (Self -> RustM usize)

class Tp2.AssociatedTypes (Self : Type) where
  [trait_constr_Tp2_i0 : Tp1.AssociatedTypes Self]
  [trait_constr_Tp2_i1 : T3.AssociatedTypes Self]

attribute [instance] Tp2.AssociatedTypes.trait_constr_Tp2_i0

attribute [instance] Tp2.AssociatedTypes.trait_constr_Tp2_i1

class Tp2 (Self : Type)
  [associatedTypes : outParam (Tp2.AssociatedTypes (Self : Type))]
  where
  [trait_constr_Tp2_i0 : Tp1 Self]
  [trait_constr_Tp2_i1 : T3 Self]
  fp2 (Self) : (Self -> RustM usize)

attribute [instance] Tp2.trait_constr_Tp2_i0

attribute [instance] Tp2.trait_constr_Tp2_i1

structure S where
  -- no fields

@[reducible] instance Impl.AssociatedTypes : T1.AssociatedTypes S where

instance Impl : T1 S where
  f1 := fun (self : S) => do (pure (1 : usize))

@[reducible] instance Impl_1.AssociatedTypes : T2.AssociatedTypes S where

instance Impl_1 : T2 S where
  f2 := fun (self : S) => do (pure (2 : usize))

@[reducible] instance Impl_2.AssociatedTypes : T3.AssociatedTypes S where

instance Impl_2 : T3 S where
  f3 := fun (self : S) => do (pure (3 : usize))

@[reducible] instance Impl_3.AssociatedTypes : Tp1.AssociatedTypes S where

instance Impl_3 : Tp1 S where
  f1 := fun (self : S) => do (pure (10 : usize))

@[reducible] instance Impl_4.AssociatedTypes : Tp2.AssociatedTypes S where

instance Impl_4 : Tp2 S where
  fp2 := fun (self : S) => do
    ((← ((← ((← (Tp1.f1 S self)) +? (← (T1.f1 S self)))) +? (← (T2.f2 S self))))
      +? (← (T3.f3 S self)))

@[spec]
def test (_ : rust_primitives.hax.Tuple0) : RustM usize := do
  let s : S := S.mk;
  ((← (T3.f3 S s)) +? (1 : usize))

end lean_tests.traits.inheritance


namespace lean_tests.traits.default

class Easy.AssociatedTypes (Self : Type) where

class Easy (Self : Type)
  [associatedTypes : outParam (Easy.AssociatedTypes (Self : Type))]
  where
  dft (Self) (self : Self) :RustM usize := do (pure (32 : usize))

@[reducible] instance Impl.AssociatedTypes : Easy.AssociatedTypes usize where

instance Impl : Easy usize where
  dft := fun (self : usize) => do (self +? (1 : usize))

@[reducible] instance Impl_1.AssociatedTypes : Easy.AssociatedTypes u32 where

instance Impl_1 : Easy u32 where

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f1 (Self) : (Self -> RustM usize)
  f2 (Self) (self : Self) :RustM usize := do (pure (1 : usize))
  f3 (Self) (A : Type) (self : Self) (x : A) :RustM usize := do
    (pure (1 : usize))
  f4 (Self)
    (A : Type)
    [trait_constr_f4_associated_type_i1 : Easy.AssociatedTypes A]
    [trait_constr_f4_i1 : Easy A ] (self : Self) (x : A) :RustM usize := do
    ((← (Easy.dft A x)) +? (1 : usize))

structure S (A : Type) where
  _0 : usize
  _1 : A

@[reducible] instance Impl_2.AssociatedTypes :
  T1.AssociatedTypes (S usize)
  where

instance Impl_2 : T1 (S usize) where
  f1 := fun (self : (S usize)) => do ((S._0 self) +? (S._1 self))
  f2 := fun (self : (S usize)) => do (pure (S._1 self))

@[reducible] instance Impl_3.AssociatedTypes : T1.AssociatedTypes (S Bool) where

instance Impl_3 : T1 (S Bool) where
  f1 := fun (self : (S Bool)) => do
    if (S._1 self) then do (pure (S._0 self)) else do (pure (9 : usize))
  f2 := fun (self : (S Bool)) => do ((S._0 self) +? (1 : usize))

@[reducible] instance Impl_4.AssociatedTypes :
  T1.AssociatedTypes (S alloc.string.String)
  where

instance Impl_4 : T1 (S alloc.string.String) where
  f1 := fun (self : (S alloc.string.String)) => do (pure (0 : usize))

end lean_tests.traits.default


namespace lean_tests.traits.trait_level_args

class T1.AssociatedTypes (Self : Type) (A : Type) (B : Type) where

class T1 (Self : Type) (A : Type) (B : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type) (A : Type) (B :
      Type))]
  where
  f1 (Self) (A) (B) (C : Type) (D : Type) :
    (Self -> RustM rust_primitives.hax.Tuple0)
  f2 (Self) (A) (B) (C : Type) (D : Type) :
    (Self -> A -> RustM rust_primitives.hax.Tuple0)
  f3 (Self) (A) (B) (C : Type) (D : Type) :
    (Self -> A -> B -> RustM rust_primitives.hax.Tuple0)

@[reducible] instance Impl.AssociatedTypes :
  T1.AssociatedTypes usize u32 u64
  where

instance Impl : T1 usize u32 u64 where
  f1 := fun (C : Type) (D : Type) (self : usize) => do
    (pure rust_primitives.hax.Tuple0.mk)
  f2 := fun (C : Type) (D : Type) (self : usize) (x : u32) => do
    (pure rust_primitives.hax.Tuple0.mk)
  f3 := fun (C : Type) (D : Type) (self : usize) (x : u32) (y : u64) => do
    (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def test
    (A : Type)
    (B : Type)
    (C : Type)
    (D : Type)
    (U : Type)
    [trait_constr_test_associated_type_i0 : T1.AssociatedTypes U A B]
    [trait_constr_test_i0 : T1 U A B ]
    (x : U)
    (a : A)
    (b : B) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ ← (T1.f1 U A B C D x);
  let _ ← (T1.f2 U A B C D x a);
  let _ ← (T1.f3 U A B C D x a b);
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.traits.trait_level_args


namespace lean_tests.traits.trait_with_constraints

class T1.AssociatedTypes (Self : Type) where

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where

class T2.AssociatedTypes (Self : Type) where

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  func (Self)
    [trait_constr_func_associated_type_i1 : T1.AssociatedTypes Self]
    [trait_constr_func_i1 : T1 Self ] :
    (Self -> RustM Bool)

@[reducible] instance Impl.AssociatedTypes
  (A : Type)
  [trait_constr_Impl_associated_type_i0 : T1.AssociatedTypes A]
  [trait_constr_Impl_i0 : T1 A ] :
  T2.AssociatedTypes A
  where

instance Impl
  (A : Type)
  [trait_constr_Impl_associated_type_i0 : T1.AssociatedTypes A]
  [trait_constr_Impl_i0 : T1 A ] :
  T2 A
  where
  func :=
    fun
      [trait_constr_func_associated_type_i1 : T1.AssociatedTypes A]
      [trait_constr_func_i1 : T1 A ] (self : A) => do
    (pure true)

end lean_tests.traits.trait_with_constraints


namespace lean_tests.traits.associated_constant

class Foo.AssociatedTypes (Self : Type) where

class Foo (Self : Type)
  [associatedTypes : outParam (Foo.AssociatedTypes (Self : Type))]
  where
  f (Self) : Bool
  x (Self) : u8

structure Bar where
  -- no fields

@[reducible] instance Impl.AssociatedTypes : Foo.AssociatedTypes Bar where

instance Impl : Foo Bar where
  f := true
  x := RustM.of_isOk (do ((1 : u8) +? (1 : u8))) (by rfl)

class Baz.AssociatedTypes (Self : Type) where

class Baz (Self : Type)
  [associatedTypes : outParam (Baz.AssociatedTypes (Self : Type))]
  where
  One (Self) :u32 := (1 : u32)

@[spec]
def foo
    (F : Type)
    [trait_constr_foo_associated_type_i0 : Baz.AssociatedTypes F]
    [trait_constr_foo_i0 : Baz F ]
    (n : u32) :
    RustM u32 := do
  (n +? (Baz.One F))

end lean_tests.traits.associated_constant


namespace lean_tests.types

abbrev UsizeAlias : Type := usize

abbrev MyOption (A : Type) : Type := (core_models.option.Option A)

abbrev MyResult (A : Type) (B : Type) :
  Type :=
  (core_models.result.Result (core_models.option.Option A) B)

abbrev ErrorMonad (A : Type) (E : Type) :
  Type :=
  (core_models.result.Result A E)

abbrev StateMonad (A : Type) (S : Type) :
  Type :=
  (rust_primitives.hax.Tuple2 A S)

abbrev ESMonad (A : Type) (S : Type) (E : Type) :
  Type :=
  (rust_primitives.hax.Tuple2 (core_models.result.Result A E) S)

end lean_tests.types


namespace lean_tests

def FORTYTWO : usize := (42 : usize)

def MINUS_FORTYTWO : isize := (-42 : isize)

@[spec]
def returns42 (_ : rust_primitives.hax.Tuple0) : RustM usize := do
  (pure FORTYTWO)

@[spec]
def add_two_numbers (x : usize) (y : usize) : RustM usize := do (x +? y)

@[spec]
def letBinding (x : usize) (y : usize) : RustM usize := do
  let useless : rust_primitives.hax.Tuple0 := rust_primitives.hax.Tuple0.mk;
  let result1 : usize ← (x +? y);
  let result2 : usize ← (result1 +? (2 : usize));
  (result2 +? (1 : usize))

@[spec]
def closure (_ : rust_primitives.hax.Tuple0) : RustM i32 := do
  let x : i32 := (41 : i32);
  let f1 : (i32 -> RustM i32) := (fun y => (do (y +? x) : RustM i32));
  let f2 : (i32 -> i32 -> RustM i32) :=
    (fun y z => (do ((← (y +? x)) +? z) : RustM i32));
  let res1 : i32 ←
    (core_models.ops.function.Fn.call
      (i32 -> RustM i32)
      (rust_primitives.hax.Tuple1 i32)
      f1
      (rust_primitives.hax.Tuple1.mk (1 : i32)));
  let res2 : i32 ←
    (core_models.ops.function.Fn.call
      (i32 -> i32 -> RustM i32)
      (rust_primitives.hax.Tuple2 i32 i32)
      f2
      (rust_primitives.hax.Tuple2.mk (2 : i32) (3 : i32)));
  (res1 +? res2)

example : Nat := 42

@[spec]
def test_before_verbatime_single_line (x : u8) : RustM u8 := do (pure (42 : u8))


def multiline : Unit := ()


@[spec]
def test_before_verbatim_multi_line (x : u8) : RustM u8 := do (pure (32 : u8))

@[spec]
def binop_resugarings (x : u32) : RustM u32 := do
  let add : u32 ← (x +? (1 : u32));
  let sub : u32 ← (add -? (2 : u32));
  let mul : u32 ← (sub *? (3 : u32));
  let rem : u32 ← (mul %? (4 : u32));
  let div : u32 ← (rem /? (5 : u32));
  let rshift : u32 ← (div >>>? x);
  let lshift : u32 ← (div <<<? x);
  (pure x)

end lean_tests


namespace lean_tests.associated_types.basic

class Iterable.AssociatedTypes (Self : Type) where
  Item : Type

attribute [reducible] Iterable.AssociatedTypes.Item

abbrev Iterable.Item :=
  Iterable.AssociatedTypes.Item

class Iterable (Self : Type)
  [associatedTypes : outParam (Iterable.AssociatedTypes (Self : Type))]
  where
  first (Self) : (Self -> RustM associatedTypes.Item)

end lean_tests.associated_types.basic


namespace lean_tests.associated_types.projection

class T2.AssociatedTypes (Self : Type) where
  A2 : Type

attribute [reducible] T2.AssociatedTypes.A2

abbrev T2.A2 :=
  T2.AssociatedTypes.A2

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  [trait_constr_A2_associated_type_i1 : T1.AssociatedTypes associatedTypes.A2]
  [trait_constr_A2_i1 : T1 associatedTypes.A2 ]
  f (Self) : (rust_primitives.hax.Tuple0 -> RustM (T1.A1 associatedTypes.A2))

end lean_tests.associated_types.projection


namespace lean_tests.associated_types.multiple_associated_types

class Pair.AssociatedTypes (Self : Type) where
  First : Type
  Second : Type

attribute [reducible] Pair.AssociatedTypes.First

attribute [reducible] Pair.AssociatedTypes.Second

abbrev Pair.First :=
  Pair.AssociatedTypes.First

abbrev Pair.Second :=
  Pair.AssociatedTypes.Second

class Pair (Self : Type)
  [associatedTypes : outParam (Pair.AssociatedTypes (Self : Type))]
  where
  first (Self) : (Self -> RustM associatedTypes.First)
  second (Self) : (Self -> RustM associatedTypes.Second)

end lean_tests.associated_types.multiple_associated_types


namespace lean_tests.enums

inductive MyList (T : Type) : Type
| Nil : MyList (T : Type)
| Cons (hd : T) (tl : (MyList T)) : MyList (T : Type)

end lean_tests.enums


namespace lean_tests.recursion

@[spec]
def factorial (n : u32) : RustM u32 := do
  if (← (rust_primitives.hax.machine_int.eq n (0 : u32))) then do
    (pure (1 : u32))
  else do
    (n *? (← (factorial (← (n -? (1 : u32))))))
partial_fixpoint

end lean_tests.recursion


namespace lean_tests.traits.associated_types

class T1.AssociatedTypes (Self : Type) where
  T : Type

attribute [reducible] T1.AssociatedTypes.T

abbrev T1.T :=
  T1.AssociatedTypes.T

class T1 (Self : Type)
  [associatedTypes : outParam (T1.AssociatedTypes (Self : Type))]
  where
  f (Self) : (Self -> associatedTypes.T -> RustM associatedTypes.T)

class T3.AssociatedTypes (Self : Type) where
  T : Type
  Tp : Type

attribute [reducible] T3.AssociatedTypes.T

attribute [reducible] T3.AssociatedTypes.Tp

abbrev T3.T :=
  T3.AssociatedTypes.T

abbrev T3.Tp :=
  T3.AssociatedTypes.Tp

class T3 (Self : Type)
  [associatedTypes : outParam (T3.AssociatedTypes (Self : Type))]
  where
  [trait_constr_T_associated_type_i1 : Bar.AssociatedTypes associatedTypes.T]
  [trait_constr_T_i1 : Bar associatedTypes.T ]
  (A : Type)
  [trait_constr_Tp_associated_type_i1 : Foo.AssociatedTypes
    associatedTypes.Tp
    associatedTypes.T]
  [trait_constr_Tp_i1 : Foo associatedTypes.Tp associatedTypes.T ]
  f (Self)
    (A : Type)
    [trait_constr_f_associated_type_i1 : Bar.AssociatedTypes A]
    [trait_constr_f_i1 : Bar A ] :
    (Self -> associatedTypes.T -> associatedTypes.Tp -> RustM usize)

class Chain1.AssociatedTypes (Self : Type) where
  A : Type
  B : Type

attribute [reducible] Chain1.AssociatedTypes.A

attribute [reducible] Chain1.AssociatedTypes.B

abbrev Chain1.A :=
  Chain1.AssociatedTypes.A

abbrev Chain1.B :=
  Chain1.AssociatedTypes.B

class Chain1 (Self : Type)
  [associatedTypes : outParam (Chain1.AssociatedTypes (Self : Type))]
  where
  [trait_constr_A_associated_type_i1 : Chain0.AssociatedTypes associatedTypes.A]
  [trait_constr_A_i1 : Chain0 associatedTypes.A ]
  [trait_constr_B_associated_type_i1 : Chain0.AssociatedTypes associatedTypes.B]
  [trait_constr_B_i1 : Chain0 associatedTypes.B ]

end lean_tests.traits.associated_types


namespace lean_tests.associated_types.basic

@[spec]
def just_the_first
    (I : Type)
    [trait_constr_just_the_first_associated_type_i0 : Iterable.AssociatedTypes
      I]
    [trait_constr_just_the_first_i0 : Iterable I ]
    (iter : I) :
    RustM (Iterable.Item I) := do
  (Iterable.first I iter)

@[spec]
def first_plus_1
    (I : Type)
    [trait_constr_first_plus_1_associated_type_i0 : Iterable.AssociatedTypes I]
    [trait_constr_first_plus_1_i0 : Iterable
      I
      (associatedTypes := {
        show Iterable.AssociatedTypes I
        by infer_instance
        with Item := i32})]
    (iter : I) :
    RustM i32 := do
  ((← (Iterable.first I iter)) +? (1 : i32))

@[reducible] instance Impl.AssociatedTypes : Iterable.AssociatedTypes Bool where
  Item := i32

instance Impl : Iterable Bool where
  first := fun (self : Bool) => do (pure (3 : i32))

@[spec]
def a (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let _ ← (first_plus_1 Bool true);
  (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.associated_types.basic


namespace lean_tests.associated_types.multiple_associated_types

@[spec]
def get_both
    (P : Type)
    [trait_constr_get_both_associated_type_i0 : Pair.AssociatedTypes P]
    [trait_constr_get_both_i0 : Pair P ]
    (pair : P) :
    RustM (rust_primitives.hax.Tuple2 (Pair.First P) (Pair.Second P)) := do
  (pure (rust_primitives.hax.Tuple2.mk
    (← (Pair.first P pair))
    (← (Pair.second P pair))))

@[reducible] instance Impl.AssociatedTypes :
  Pair.AssociatedTypes (rust_primitives.hax.Tuple2 i32 Bool)
  where
  First := i32
  Second := Bool

instance Impl : Pair (rust_primitives.hax.Tuple2 i32 Bool) where
  first := fun (self : (rust_primitives.hax.Tuple2 i32 Bool)) => do
    (pure (rust_primitives.hax.Tuple2._0 self))
  second := fun (self : (rust_primitives.hax.Tuple2 i32 Bool)) => do
    (pure (rust_primitives.hax.Tuple2._1 self))

@[spec]
def b (_ : rust_primitives.hax.Tuple0) : RustM rust_primitives.hax.Tuple0 := do
  let pair : (rust_primitives.hax.Tuple2 i32 Bool) :=
    (rust_primitives.hax.Tuple2.mk (42 : i32) true);
  let both : (rust_primitives.hax.Tuple2 i32 Bool) ←
    (get_both (rust_primitives.hax.Tuple2 i32 Bool) pair);
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def get_first_as_i32
    (P : Type)
    [trait_constr_get_first_as_i32_associated_type_i0 : Pair.AssociatedTypes P]
    [trait_constr_get_first_as_i32_i0 : Pair
      P
      (associatedTypes := {
        show Pair.AssociatedTypes P
        by infer_instance
        with First := i32})]
    (pair : P) :
    RustM i32 := do
  (Pair.first P pair)

end lean_tests.associated_types.multiple_associated_types


namespace lean_tests.enums

@[spec]
def enums (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let e_v1 : E := E.V1;
  let e_v2 : E := E.V2;
  let e_v3 : E := (E.V3 (23 : usize));
  let e_v4 : E := (E.V4 (23 : usize) (12 : usize) (1 : usize));
  let e_v5 : E := (E.V5 (f1 := (23 : usize)) (f2 := (43 : usize)));
  let e_v6 : E := (E.V6 (f1 := (12 : usize)) (f2 := (13 : usize)));
  let nil : (MyList usize) := MyList.Nil;
  let cons_1 : (MyList usize) := (MyList.Cons (hd := (1 : usize)) (tl := nil));
  let cons_2_1 : (MyList usize) :=
    (MyList.Cons (hd := (2 : usize)) (tl := cons_1));
  match e_v1 with
    | (E.V1 ) => do (pure rust_primitives.hax.Tuple0.mk)
    | (E.V2 ) => do (pure rust_primitives.hax.Tuple0.mk)
    | (E.V3  _) => do (pure rust_primitives.hax.Tuple0.mk)
    | (E.V4  x1 x2 x3) => do
      let y1 : usize ← (x1 +? x2);
      let y2 : usize ← (y1 -? x2);
      let y3 : usize ← (y2 +? x3);
      (pure rust_primitives.hax.Tuple0.mk)
    | (E.V5  (f1 := f1) (f2 := f2)) => do (pure rust_primitives.hax.Tuple0.mk)
    | (E.V6  (f1 := f1) (f2 := other_name_for_f2)) => do
      (pure rust_primitives.hax.Tuple0.mk)

end lean_tests.enums


namespace lean_tests.traits.associated_types

@[reducible] instance Impl.AssociatedTypes : T1.AssociatedTypes S where
  T := i32

instance Impl : T1 S where
  f := fun (self : S) (x : i32) => do (pure (2121 : i32))

class Chain2.AssociatedTypes (Self : Type) where
  [trait_constr_Chain2_i0 : Chain1.AssociatedTypes Self]

attribute [instance] Chain2.AssociatedTypes.trait_constr_Chain2_i0

class Chain2 (Self : Type)
  [associatedTypes : outParam (Chain2.AssociatedTypes (Self : Type))]
  where
  [trait_constr_Chain2_i0 : Chain1 Self]

attribute [instance] Chain2.trait_constr_Chain2_i0

class Chain3.AssociatedTypes (Self : Type) where
  [trait_constr_Chain3_i0 : Chain2.AssociatedTypes Self]

attribute [instance] Chain3.AssociatedTypes.trait_constr_Chain3_i0

class Chain3 (Self : Type)
  [associatedTypes : outParam (Chain3.AssociatedTypes (Self : Type))]
  where
  [trait_constr_Chain3_i0 : Chain2 Self]
  f (Self) : (rust_primitives.hax.Tuple0 -> RustM (Chain1.A Self))

attribute [instance] Chain3.trait_constr_Chain3_i0

@[reducible] instance Impl_5.AssociatedTypes : Chain1.AssociatedTypes u8 where
  A := u8
  B := u8

instance Impl_5 : Chain1 u8 where

@[reducible] instance Impl_6.AssociatedTypes : Chain2.AssociatedTypes u8 where

instance Impl_6 : Chain2 u8 where

@[reducible] instance Impl_7.AssociatedTypes : Chain3.AssociatedTypes u8 where

instance Impl_7 : Chain3 u8 where
  f := fun (_ : rust_primitives.hax.Tuple0) => do (pure (0 : u8))

class T2.AssociatedTypes (Self : Type) where
  T : Type

attribute [reducible] T2.AssociatedTypes.T

abbrev T2.T :=
  T2.AssociatedTypes.T

class T2 (Self : Type)
  [associatedTypes : outParam (T2.AssociatedTypes (Self : Type))]
  where
  [trait_constr_T_associated_type_i1 : T1.AssociatedTypes associatedTypes.T]
  [trait_constr_T_i1 : T1 associatedTypes.T ]
  f (Self) : (Self -> associatedTypes.T -> RustM usize)

@[reducible] instance Impl_1.AssociatedTypes : T2.AssociatedTypes S where
  T := S

instance Impl_1 : T2 S where
  f := fun (self : S) (x : S) => do (pure (21 : usize))

end lean_tests.traits.associated_types

'''
