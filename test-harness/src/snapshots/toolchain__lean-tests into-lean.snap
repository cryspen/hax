---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: true
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 1
stderr = """
Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0008] Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m
 \u001B[1m\u001B[94m-->\u001B[0m lean-tests/src/reject_do_dsl.rs:6:18
  \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[94m6 |\u001B[0m     let x1 = 1 + (if true { 0 } else { 1 });
  \u001B[1m\u001B[94m|\u001B[0m                  \u001B[1m\u001B[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001B[0m
  \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0008] Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
Note: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m
  \u001B[1m\u001B[94m-->\u001B[0m lean-tests/src/reject_do_dsl.rs:8:11
   \u001B[1m\u001B[94m|\u001B[0m
\u001B[1m\u001B[94m 8 |\u001B[0m           + (match (1, 2) {
   \u001B[1m\u001B[94m|\u001B[0m  \u001B[1m\u001B[91m___________^\u001B[0m
\u001B[1m\u001B[94m 9 |\u001B[0m \u001B[1m\u001B[91m|\u001B[0m             _ => 0,
\u001B[1m\u001B[94m10 |\u001B[0m \u001B[1m\u001B[91m|\u001B[0m         });
   \u001B[1m\u001B[94m|\u001B[0m \u001B[1m\u001B[91m|__________^\u001B[0m
   \u001B[1m\u001B[94m|\u001B[0m"""
[[stdout.diagnostics]]
message = """
Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
\u001B[90mNote: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m"""
spans = ['Span { lo: Loc { line: 6, col: 17 }, hi: Loc { line: 6, col: 43 }, filename: Real(LocalPath("lean-tests/src/reject_do_dsl.rs")), rust_span_data: None }']

[[stdout.diagnostics]]
message = """
Explicit rejection by a phase in the Hax engine:
This interleaving of expression and statements does not fit in Lean's do-notation DSL.
You may try hoisting out let-bindings and control-flow.

This is discussed in issue https://github.com/hacspec/hax/issues/1741.
Please upvote or comment this issue if you see this error message.
\u001B[90mNote: the error was labeled with context `Engine phase (RejectNotDoLeanDSL)`.
\u001B[0m"""
spans = ['Span { lo: Loc { line: 8, col: 10 }, hi: Loc { line: 10, col: 10 }, filename: Real(LocalPath("lean-tests/src/reject_do_dsl.rs")), rust_span_data: None }']

[stdout.files]
"Lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

class Lean_tests.Traits.Overlapping_methods.T1 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T2 (Self : Type) where
  f : Self -> Result usize

class Lean_tests.Traits.Overlapping_methods.T3 (Self : Type) where
  f : Self -> Result usize

instance Lean_tests.Traits.Overlapping_methods.Impl :
  Lean_tests.Traits.Overlapping_methods.T1 u32
  where
  f (self : u32) := do (0 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_1 :
  Lean_tests.Traits.Overlapping_methods.T2 u32
  where
  f (self : u32) := do (1 : usize)

instance Lean_tests.Traits.Overlapping_methods.Impl_2 :
  Lean_tests.Traits.Overlapping_methods.T3 u32
  where
  f (self : u32) := do (2 : usize)

def Lean_tests.Traits.Overlapping_methods.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result usize
  := do
  let x ← (pure (9 : u32));
  (← (← (← Lean_tests.Traits.Overlapping_methods.T1.f x)
      +? (← Lean_tests.Traits.Overlapping_methods.T2.f x))
    +? (← Lean_tests.Traits.Overlapping_methods.T3.f x))

class Lean_tests.Traits.Inheritance.T1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Inheritance.T2 (Self : Type) where
  f2 : Self -> Result usize

class Lean_tests.Traits.Inheritance.T3 (Self : Type) where
  [_constr_5860918688139008796 : (Lean_tests.Traits.Inheritance.T2 Self)]
  [_constr_2614080591691505761 : (Lean_tests.Traits.Inheritance.T1 Self)]
  f3 : Self -> Result usize

class Lean_tests.Traits.Inheritance.Tp1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Inheritance.Tp2 (Self : Type) where
  [_constr_9900012313089209274 : (Lean_tests.Traits.Inheritance.Tp1 Self)]
  [_constr_3518312647081482353 : (Lean_tests.Traits.Inheritance.T3 Self)]
  fp2 : Self -> Result usize

structure Lean_tests.Traits.Inheritance.S where


instance Lean_tests.Traits.Inheritance.Impl :
  Lean_tests.Traits.Inheritance.T1 Lean_tests.Traits.Inheritance.S
  where
  f1 (self : Lean_tests.Traits.Inheritance.S) := do (1 : usize)

instance Lean_tests.Traits.Inheritance.Impl_1 :
  Lean_tests.Traits.Inheritance.T2 Lean_tests.Traits.Inheritance.S
  where
  f2 (self : Lean_tests.Traits.Inheritance.S) := do (2 : usize)

instance Lean_tests.Traits.Inheritance.Impl_2 :
  Lean_tests.Traits.Inheritance.T3 Lean_tests.Traits.Inheritance.S
  where
  f3 (self : Lean_tests.Traits.Inheritance.S) := do (3 : usize)

instance Lean_tests.Traits.Inheritance.Impl_3 :
  Lean_tests.Traits.Inheritance.Tp1 Lean_tests.Traits.Inheritance.S
  where
  f1 (self : Lean_tests.Traits.Inheritance.S) := do (10 : usize)

instance Lean_tests.Traits.Inheritance.Impl_4 :
  Lean_tests.Traits.Inheritance.Tp2 Lean_tests.Traits.Inheritance.S
  where
  fp2 (self : Lean_tests.Traits.Inheritance.S) := do
    (← (← (← (← Lean_tests.Traits.Inheritance.Tp1.f1 self)
          +? (← Lean_tests.Traits.Inheritance.T1.f1 self))
        +? (← Lean_tests.Traits.Inheritance.T2.f2 self))
      +? (← Lean_tests.Traits.Inheritance.T3.f3 self))

def Lean_tests.Traits.Inheritance.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result usize
  := do
  let s : Lean_tests.Traits.Inheritance.S ← (pure
    Lean_tests.Traits.Inheritance.S.mk);
  (← (← Lean_tests.Traits.Inheritance.T3.f3 s) +? (1 : usize))

class Lean_tests.Traits.Bounds.T1 (Self : Type) where
  f1 : Self -> Result usize

class Lean_tests.Traits.Bounds.T2 (Self : Type) where
  f2 : Self -> Result usize

class Lean_tests.Traits.Bounds.Test (Self : Type) (T : Type) where
  [_constr_11094313111027375411 : (Lean_tests.Traits.Bounds.T2 Self)]
  [_constr_11502165326992889641 : (Lean_tests.Traits.Bounds.T1 T)]
  f_test : Self -> T -> Result usize

structure Lean_tests.Traits.Bounds.S1 where


instance Lean_tests.Traits.Bounds.Impl :
  Lean_tests.Traits.Bounds.T1 Lean_tests.Traits.Bounds.S1
  where
  f1 (self : Lean_tests.Traits.Bounds.S1) := do (0 : usize)

structure Lean_tests.Traits.Bounds.S2 where


instance Lean_tests.Traits.Bounds.Impl_1 :
  Lean_tests.Traits.Bounds.T2 Lean_tests.Traits.Bounds.S2
  where
  f2 (self : Lean_tests.Traits.Bounds.S2) := do (1 : usize)

instance Lean_tests.Traits.Bounds.Impl_2 :
  Lean_tests.Traits.Bounds.Test
  Lean_tests.Traits.Bounds.S2
  Lean_tests.Traits.Bounds.S1
  where
  f_test (self : Lean_tests.Traits.Bounds.S2)
    (x : Lean_tests.Traits.Bounds.S1)
    := do
    (← (← (← Lean_tests.Traits.Bounds.T1.f1 x)
        +? (← Lean_tests.Traits.Bounds.T2.f2 self))
      +? (1 : usize))

def Lean_tests.Traits.Bounds.test
  (x1 : Lean_tests.Traits.Bounds.S1)
  (x2 : Lean_tests.Traits.Bounds.S2)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Bounds.Test.f_test x2 x1)
    +? (← Lean_tests.Traits.Bounds.T1.f1 x1))

class Lean_tests.Traits.Basic.T1 (Self : Type) where
  f1 : Self -> Result usize
  f2 : Self -> Self -> Result usize

structure Lean_tests.Traits.Basic.S where


instance Lean_tests.Traits.Basic.Impl :
  Lean_tests.Traits.Basic.T1 Lean_tests.Traits.Basic.S
  where
  f1 (self : Lean_tests.Traits.Basic.S) := do (42 : usize)
  f2 (self : Lean_tests.Traits.Basic.S)
    (other : Lean_tests.Traits.Basic.S)
    := do
    (43 : usize)

def Lean_tests.Traits.Basic.f
  (T : Type) [(Lean_tests.Traits.Basic.T1 T)] (x : T)
  : Result usize
  := do
  (← (← Lean_tests.Traits.Basic.T1.f1 x)
    +? (← Lean_tests.Traits.Basic.T1.f2 x x))

class Lean_tests.Traits.Associated_types.Foo (Self : Type) (T : Type) where


class Lean_tests.Traits.Associated_types.Bar (Self : Type) where


structure Lean_tests.Traits.Associated_types.S where


instance Lean_tests.Traits.Associated_types.Impl_2 :
  Lean_tests.Traits.Associated_types.Bar i16
  where


instance Lean_tests.Traits.Associated_types.Impl_3 (A : Type) :
  Lean_tests.Traits.Associated_types.Foo (Rust_primitives.Hax.Tuple2 u32 A) i16
  where


class Lean_tests.Traits.Associated_types.T1 (Self : Type) where
  T : Type
  f : Self -> T -> Result T

class Lean_tests.Traits.Associated_types.T3 (Self : Type) where
  T : Type
  [_constr_9884638762124940061 : (Lean_tests.Traits.Associated_types.Bar T)]
  Tp : Type
  [_constr_16271648697586611929 : (Lean_tests.Traits.Associated_types.Foo Tp T)]
  f (A : Type) [(Lean_tests.Traits.Associated_types.Bar A)] :
    Self -> T -> Tp -> Result usize

instance Lean_tests.Traits.Associated_types.Impl :
  Lean_tests.Traits.Associated_types.T1 Lean_tests.Traits.Associated_types.S
  where
  T := i32
  f (self : Lean_tests.Traits.Associated_types.S) (x : i32) := do (2121 : i32)

class Lean_tests.Traits.Associated_types.T2 (Self : Type) where
  T : Type
  [_constr_11855681382024687155 : (Lean_tests.Traits.Associated_types.T1 T)]
  f : Self -> T -> Result usize

instance Lean_tests.Traits.Associated_types.Impl_1 :
  Lean_tests.Traits.Associated_types.T2 Lean_tests.Traits.Associated_types.S
  where
  T := Lean_tests.Traits.Associated_types.S
  f (self : Lean_tests.Traits.Associated_types.S)
    (x : Lean_tests.Traits.Associated_types.S)
    := do
    (21 : usize)

structure Lean_tests.Structs.Miscellaneous.S where
  f : i32

def Lean_tests.Structs.Miscellaneous.test_tuples
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Rust_primitives.Hax.Tuple2 i32 i32)
  := do
  let lit : i32 ← (pure (1 : i32));
  let constr : Lean_tests.Structs.Miscellaneous.S ← (pure
    (Lean_tests.Structs.Miscellaneous.S.mk (f := (42 : i32))));
  let proj : i32 ← (pure (Lean_tests.Structs.Miscellaneous.S.f constr));
  let ite : (Rust_primitives.Hax.Tuple2 i32 i32) ← (pure
    (← if true then do
      (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))
    else do
      let z : i32 ← (pure (← (1 : i32) +? (2 : i32)));
      (Rust_primitives.Hax.Tuple2.mk z z)));
  (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32))

structure Lean_tests.Structs.Base_expressions.S where
  f1 : u32
  f2 : u32
  f3 : u32

def Lean_tests.Structs.Base_expressions.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let s1 : Lean_tests.Structs.Base_expressions.S ← (pure
    (Lean_tests.Structs.Base_expressions.S.mk
      (f1 := (1 : u32)) (f2 := (2 : u32)) (f3 := (3 : u32))));
  let _ ← (pure {s1 with f1 := (0 : u32)});
  let _ ← (pure {s1 with f2 := (0 : u32)});
  let _ ← (pure {s1 with f3 := (0 : u32)});
  let _ ← (pure {s1 with f1 := (0 : u32), f2 := (1 : u32)});
  let _ ← (pure {s1 with f2 := (0 : u32), f3 := (1 : u32)});
  let _ ← (pure {s1 with f3 := (0 : u32), f1 := (2 : u32)});
  let _ ← (pure {s1 with f1 := (0 : u32), f2 := (1 : u32), f3 := (0 : u32)});
  Rust_primitives.Hax.Tuple0.mk

structure Lean_tests.Structs.T0 where


structure Lean_tests.Structs.T1 (A : Type) where
  _0 : A

structure Lean_tests.Structs.T2 (A : Type) (B : Type) where
  _0 : A
  _1 : B

structure Lean_tests.Structs.T3 (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : B
  _2 : C

structure Lean_tests.Structs.T3p (A : Type) (B : Type) (C : Type) where
  _0 : A
  _1 : (Lean_tests.Structs.T2 B C)

def Lean_tests.Structs.tuple_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let t0 : Lean_tests.Structs.T0 ← (pure Lean_tests.Structs.T0.mk);
  let t1 : (Lean_tests.Structs.T1 i32) ← (pure
    (Lean_tests.Structs.T1.mk (1 : i32)));
  let t2 : (Lean_tests.Structs.T2 i32 i32) ← (pure
    (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)));
  let
    t3 : (Lean_tests.Structs.T3
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T1.mk (1 : i32))
      (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32))));
  let
    t3p : (Lean_tests.Structs.T3p
      Lean_tests.Structs.T0
      (Lean_tests.Structs.T1 i32)
      (Lean_tests.Structs.T2 i32 i32)) ← (pure
    (Lean_tests.Structs.T3p.mk
      Lean_tests.Structs.T0.mk
      (Lean_tests.Structs.T2.mk
        (Lean_tests.Structs.T1.mk (1 : i32))
        (Lean_tests.Structs.T2.mk (1 : i32) (2 : i32)))));
  let ⟨⟩ ← (pure t0);
  let ⟨u1⟩ ← (pure t1);
  let ⟨u2, u3⟩ ← (pure t2);
  let ⟨⟨⟩, ⟨_⟩, ⟨_, _⟩⟩ ← (pure t3);
  let ⟨⟨⟩, ⟨⟨_⟩, ⟨_, _⟩⟩⟩ ← (pure t3p);
  let _ ← (pure (Lean_tests.Structs.T1._0 t1));
  let _ ← (pure (Lean_tests.Structs.T2._0 t2));
  let _ ← (pure (Lean_tests.Structs.T2._1 t2));
  let _ ← (pure (Lean_tests.Structs.T3._0 t3));
  let _ ← (pure (Lean_tests.Structs.T3._1 t3));
  let _ ← (pure (Lean_tests.Structs.T3._2 t3));
  let _ ← (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3._2 t3)));
  let _ ← (pure (Lean_tests.Structs.T3p._0 t3p));
  let _ ← (pure (Lean_tests.Structs.T3p._1 t3p));
  let _ ← (pure
    (Lean_tests.Structs.T2._0
        (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p))));
  let _ ← (pure (Lean_tests.Structs.T2._0 (Lean_tests.Structs.T3p._1 t3p)));
  let _ ← (pure (Lean_tests.Structs.T2._1 (Lean_tests.Structs.T3p._1 t3p)));
  let _ ← (pure (match t0 with | ⟨⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure (match t1 with | ⟨u1⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure (match t2 with | ⟨u2, u3⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match t3 with | ⟨⟨⟩, ⟨u1⟩, ⟨u2, u3⟩⟩ => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match t3p with
      | ⟨⟨⟩, ⟨⟨u1⟩, ⟨u2, u3⟩⟩⟩ => do Rust_primitives.Hax.Tuple0.mk));
  Rust_primitives.Hax.Tuple0.mk

structure Lean_tests.Structs.S1 where
  f1 : usize
  f2 : usize

structure Lean_tests.Structs.S2 where
  f1 : Lean_tests.Structs.S1
  f2 : usize

structure Lean_tests.Structs.S3 where
  _end : usize
  _def : usize
  _theorem : usize
  _structure : usize
  _inductive : usize

def Lean_tests.Structs.normal_structs
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let s1 : Lean_tests.Structs.S1 ← (pure
    (Lean_tests.Structs.S1.mk (f1 := (0 : usize)) (f2 := (1 : usize))));
  let s2 : Lean_tests.Structs.S2 ← (pure
    (Lean_tests.Structs.S2.mk
      (f1 := (Lean_tests.Structs.S1.mk (f1 := (2 : usize)) (f2 := (3 : usize))))
      (f2 := (4 : usize))));
  let s3 : Lean_tests.Structs.S3 ← (pure
    (Lean_tests.Structs.S3.mk
      (_end := (0 : usize))
      (_def := (0 : usize))
      (_theorem := (0 : usize))
      (_structure := (0 : usize))
      (_inductive := (0 : usize))));
  let {f1 := f1, f2 := f2} ← (pure s1);
  let {f1 := f1, f2 := other_name_for_f2} ← (pure s1);
  let {f1 := {f1 := f1, f2 := f2}, f2 := other_name_for_f2} ← (pure s2);
  let
    {_end := _end,
     _def := _def,
     _theorem := _theorem,
     _structure := _structure,
     _inductive := _inductive} ← (pure s3);
  let _ ← (pure
    (Rust_primitives.Hax.Tuple2.mk
      (Lean_tests.Structs.S1.f1 s1) (Lean_tests.Structs.S1.f2 s1)));
  let _ ← (pure
    (Rust_primitives.Hax.Tuple8.mk
      (Lean_tests.Structs.S1.f1 s1)
      (Lean_tests.Structs.S1.f2 s1)
      (Lean_tests.Structs.S1.f1 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S1.f2 (Lean_tests.Structs.S2.f1 s2))
      (Lean_tests.Structs.S2.f2 s2)
      (Lean_tests.Structs.S3._end s3)
      (Lean_tests.Structs.S3._def s3)
      (Lean_tests.Structs.S3._theorem s3)));
  let _ ← (pure
    (match s1 with | {f1 := f1, f2 := f2} => do Rust_primitives.Hax.Tuple0.mk));
  let _ ← (pure
    (match s2 with
      | {f1 := {f1 := f1, f2 := other_name_for_f2}, f2 := f2}
        => do Rust_primitives.Hax.Tuple0.mk));
  (match s3 with
    | {_end := _end,
       _def := _def,
       _theorem := _theorem,
       _structure := _structure,
       _inductive := _inductive}
      => do Rust_primitives.Hax.Tuple0.mk)

inductive Lean_tests.Loops.Errors.Error : Type
| Foo : Lean_tests.Loops.Errors.Error 
| Bar : u32 -> Lean_tests.Loops.Errors.Error 


def Lean_tests.Loops.Errors.loop3
  (_ : Rust_primitives.Hax.Tuple0)
  : Result (Core.Result.Result u32 Lean_tests.Loops.Errors.Error)
  := do
  let x : u32 ← (pure (0 : u32));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (1 : i32)
        (10 : i32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do
            (← if (← Rust_primitives.Hax.Machine_int.eq i (5 : i32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break
                  (Core.Result.Result.Err Lean_tests.Loops.Errors.Error.Foo)))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← x +? (5 : u32)))) :
            Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                (Core.Result.Result u32 Lean_tests.Loops.Errors.Error)
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue x)
      => do (Core.Result.Result.Ok x))

def Lean_tests.Loops.Errors.loop4
  (_ : Rust_primitives.Hax.Tuple0)
  : Result
  (Core.Result.Result
    (Rust_primitives.Hax.Tuple2 u32 u32)
    Lean_tests.Loops.Errors.Error)
  := do
  let e : u32 ← (pure (0 : u32));
  let f : Rust_primitives.Hax.Tuple0 -> Result u32 ← (pure
    (fun ⟨⟩ => (do (42 : u32) : Result u32)));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (0 : u32)
        (← Core.Ops.Function.Fn.call
            f
            (Rust_primitives.Hax.Tuple1.mk Rust_primitives.Hax.Tuple0.mk))
        (fun e _ => (do true : Result Bool))
        e
        (fun e i => (do
            (← if (← Rust_primitives.Hax.Machine_int.gt i (10 : u32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break
                  (Core.Result.Result.Err
                    (Lean_tests.Loops.Errors.Error.Bar e))))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← e +? i))) : Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                (Core.Result.Result
                  (Rust_primitives.Hax.Tuple2 u32 u32)
                  Lean_tests.Loops.Errors.Error)
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue e)
      => do (Core.Result.Result.Ok (Rust_primitives.Hax.Tuple2.mk e e)))

inductive Lean_tests.Enums.E : Type
| V1 : Lean_tests.Enums.E 
| V2 : Lean_tests.Enums.E 
| V3 : usize -> Lean_tests.Enums.E 
| V4 : usize -> usize -> usize -> Lean_tests.Enums.E 
| V5 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E 
| V6 (f1 : usize) (f2 : usize) : Lean_tests.Enums.E 


inductive Lean_tests.Enums.MyList (T : Type) : Type
| Nil : Lean_tests.Enums.MyList (T : Type) 
| Cons (hd : T)
       (tl : (Alloc.Boxed.Box (Lean_tests.Enums.MyList T) Alloc.Alloc.Global))
    : Lean_tests.Enums.MyList (T : Type) 


def Lean_tests.Enums.enums
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let e_v1 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V1);
  let e_v2 : Lean_tests.Enums.E ← (pure Lean_tests.Enums.E.V2);
  let e_v3 : Lean_tests.Enums.E ← (pure (Lean_tests.Enums.E.V3 (23 : usize)));
  let e_v4 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V4 (23 : usize) (12 : usize) (1 : usize)));
  let e_v5 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V5 (f1 := (23 : usize)) (f2 := (43 : usize))));
  let e_v6 : Lean_tests.Enums.E ← (pure
    (Lean_tests.Enums.E.V6 (f1 := (12 : usize)) (f2 := (13 : usize))));
  let nil ← (pure Lean_tests.Enums.MyList.Nil);
  let cons_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (1 : usize)) (tl := nil)));
  let cons_2_1 : (Lean_tests.Enums.MyList usize) ← (pure
    (Lean_tests.Enums.MyList.Cons (hd := (2 : usize)) (tl := cons_1)));
  (match e_v1 with
    | (Lean_tests.Enums.E.V1 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V2 ) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V3 _) => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V4 x1 x2 x3)
      => do
        let y1 : usize ← (pure (← x1 +? x2));
        let y2 : usize ← (pure (← y1 -? x2));
        let y3 : usize ← (pure (← y2 +? x3));
        Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V5 (f1 := f1) (f2 := f2))
      => do Rust_primitives.Hax.Tuple0.mk
    | (Lean_tests.Enums.E.V6 (f1 := f1) (f2 := other_name_for_f2))
      => do Rust_primitives.Hax.Tuple0.mk)

def Lean_tests.FORTYTWO : usize := 42

def Lean_tests.MINUS_FORTYTWO : isize := -42

def Lean_tests.returns42 (_ : Rust_primitives.Hax.Tuple0) : Result usize := do
  Lean_tests.FORTYTWO

def Lean_tests.add_two_numbers (x : usize) (y : usize) : Result usize := do
  (← x +? y)

def Lean_tests.letBinding (x : usize) (y : usize) : Result usize := do
  let useless : Rust_primitives.Hax.Tuple0 ← (pure
    Rust_primitives.Hax.Tuple0.mk);
  let result1 : usize ← (pure (← x +? y));
  let result2 : usize ← (pure (← result1 +? (2 : usize)));
  (← result2 +? (1 : usize))

def Lean_tests.closure (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (41 : i32));
  let f1 : i32 -> Result i32 ← (pure (fun y => (do (← y +? x) : Result i32)));
  let f2 : i32 -> i32 -> Result i32 ← (pure
    (fun y z => (do (← (← y +? x) +? z) : Result i32)));
  let res1 : i32 ← (pure
    (← Core.Ops.Function.Fn.call f1 (Rust_primitives.Hax.Tuple1.mk (1 : i32))));
  let res2 : i32 ← (pure
    (← Core.Ops.Function.Fn.call
        f2
        (Rust_primitives.Hax.Tuple2.mk (2 : i32) (3 : i32))));
  (← res1 +? res2)

@[spec]

def Lean_tests.test_before_verbatime_single_line (x : u8) : Result u8 := do
  (42 : u8)


def multiline : Unit := ()


def Lean_tests.test_before_verbatim_multi_line (x : u8) : Result u8 := do
  (32 : u8)

def Lean_tests.binop_resugarings (x : u32) : Result u32 := do
  let add : u32 ← (pure (← x +? (1 : u32)));
  let sub : u32 ← (pure (← add -? (2 : u32)));
  let mul : u32 ← (pure (← sub *? (3 : u32)));
  let rem : u32 ← (pure (← mul %? (4 : u32)));
  let div : u32 ← (pure (← rem /? (5 : u32)));
  let rshift : u32 ← (pure (← div >>>? x));
  x

def Lean_tests.Reject_do_dsl.rejected
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let x1 : i32 ← (pure (← (1 : i32) +? sorry));
  let x2 : i32 ← (pure (← (1 : i32) +? sorry));
  let x : i32 ← (pure (9 : i32));
  let x3 : i32 ← (pure (← (1 : i32) +? (← x +? (1 : i32))));
  Rust_primitives.Hax.Tuple0.mk

--  Code that should be produced from the rejected code
def Lean_tests.Reject_do_dsl.accepted
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  let x1_tmp : i32 ← (pure (← if true then do (0 : i32) else do (1 : i32)));
  let x1 : i32 ← (pure (← (1 : i32) +? x1_tmp));
  let x2_tmp : i32 ← (pure
    (match (Rust_primitives.Hax.Tuple2.mk (1 : i32) (2 : i32)) with
      | _ => do (0 : i32)));
  let x2 : i32 ← (pure (← (1 : i32) +? x2_tmp));
  let x3_tmp_x : i32 ← (pure (9 : i32));
  let x3_tmp : i32 ← (pure (← x3_tmp_x +? (1 : i32)));
  let x3 : i32 ← (pure (← (1 : i32) +? x3_tmp));
  Rust_primitives.Hax.Tuple0.mk

def Lean_tests.Reject_do_dsl.test
  (_ : Rust_primitives.Hax.Tuple0)
  : Result
  (Rust_primitives.Hax.Tuple2
    Rust_primitives.Hax.Tuple0
    Rust_primitives.Hax.Tuple0)
  := do
  let x1 : i32 ← (pure
    (← if true then do
      let y : i32 ← (pure
        (← if false then do
          let z : i32 ← (pure
            (match Rust_primitives.Hax.Tuple0.mk with | _ => do (9 : i32)));
          let z : i32 ← (pure (← (1 : i32) +? z));
          (← z +? (1 : i32))
        else do
          let z : i32 ← (pure (9 : i32));
          let z : i32 ← (pure (← z +? (1 : i32)));
          z));
      let y : i32 ← (pure (← y +? (1 : i32)));
      (← y +? (1 : i32))
    else do
      (0 : i32)));
  let x1 : i32 ← (pure (← x1 +? (1 : i32)));
  let x2 : i32 ← (pure
    (match (Core.Option.Option.Some (89 : i32)) with
      | (Core.Option.Option.Some a)
        => do
          let y : i32 ← (pure (← (1 : i32) +? a));
          let y : i32 ← (pure (← y +? (1 : i32)));
          (← if (← Rust_primitives.Hax.Machine_int.eq y (0 : i32)) then do
            let z : i32 ← (pure (9 : i32));
            let z : i32 ← (pure (← (← z +? y) +? (1 : i32)));
            z
          else do
            (10 : i32))
      | (Core.Option.Option.None )
        => do
          let y : i32 ← (pure
            (← if false then do
              (9 : i32)
            else do
              let z : i32 ← (pure (9 : i32));
              let z : i32 ← (pure (← z +? (1 : i32)));
              (← z +? (9 : i32))));
          let y : i32 ← (pure (← y +? (1 : i32)));
          y));
  (Rust_primitives.Hax.Tuple2.mk
    Rust_primitives.Hax.Tuple0.mk Rust_primitives.Hax.Tuple0.mk)

def Lean_tests.Loops.loop1 (_ : Rust_primitives.Hax.Tuple0) : Result u32 := do
  let x ← (pure (0 : u32));
  let x : u32 ← (pure
    (← Rust_primitives.Hax.Folds.fold_range
        (1 : u32)
        (10 : u32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do (← x +? i) : Result u32))));
  x

def Lean_tests.Loops.loop2 (_ : Rust_primitives.Hax.Tuple0) : Result u32 := do
  let x ← (pure (0 : u32));
  (match
    (← Rust_primitives.Hax.Folds.fold_range_return
        (1 : u32)
        (10 : u32)
        (fun x _ => (do true : Result Bool))
        x
        (fun x i => (do
            (← if (← Rust_primitives.Hax.Machine_int.eq i (5 : u32)) then do
              (Core.Ops.Control_flow.ControlFlow.Break
                (Core.Ops.Control_flow.ControlFlow.Break x))
            else do
              (Core.Ops.Control_flow.ControlFlow.Continue (← x +? i))) : Result
            (Core.Ops.Control_flow.ControlFlow
              (Core.Ops.Control_flow.ControlFlow
                u32
                (Rust_primitives.Hax.Tuple2 Rust_primitives.Hax.Tuple0 u32))
              u32))))
  with
    | (Core.Ops.Control_flow.ControlFlow.Break ret) => do ret
    | (Core.Ops.Control_flow.ControlFlow.Continue x) => do x)

def Lean_tests.Ite.test1 (_ : Rust_primitives.Hax.Tuple0) : Result i32 := do
  let x : i32 ← (pure (← if true then do (0 : i32) else do (1 : i32)));
  (← if false then do (2 : i32) else do (3 : i32))

def Lean_tests.Ite.test2 (b : Bool) : Result i32 := do
  let x : i32 ← (pure (← if b then do (0 : i32) else do (9 : i32)));
  let y : i32 ← (pure (0 : i32));
  let y : i32 ← (pure
    (← if true then do
      (← (← y +? x) +? (1 : i32))
    else do
      (← (← y -? x) -? (1 : i32))));
  (← if b then do
    let z : i32 ← (pure (← y +? y));
    (← (← z +? y) +? x)
  else do
    let z : i32 ← (pure (← y -? x));
    (← (← z +? y) +? x))

--  Single line doc comment
def Lean_tests.Comments.f
  (_ : Rust_primitives.Hax.Tuple0)
  : Result Rust_primitives.Hax.Tuple0
  := do
  Rust_primitives.Hax.Tuple0.mk

/--
   Block doc-comment : Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum rutrum
  orci ac tellus ullamcorper sollicitudin. Sed fringilla mi id arcu suscipit rhoncus. Pellentesque et
  metus a ante feugiat lobortis. Nam a mauris eget nisl congue egestas. Duis et gravida
  nulla. Curabitur mattis leo vel molestie posuere. Etiam malesuada et augue eget
  varius. Pellentesque quis tincidunt erat. Vestibulum id consectetur turpis. Cras elementum magna id
  urna volutpat fermentum. In vel erat quis nunc rhoncus porta. Aliquam sed pellentesque
  tellus. Quisque odio diam, mollis ut venenatis non, scelerisque at nulla. Nunc urna ante, tristique
  quis nisi quis, congue maximus nisl. Curabitur non efficitur odio. 
  -/
def Lean_tests.Comments.heavily_documented
  (_ : Rust_primitives.Hax.Tuple0)
  : Result u32
  := do
  (4 : u32)'''
